## 2025-12-18

### Alineación del pulso BPM central con Loops
- Se ha ajustado el cálculo del **strong beat** que alimenta tanto el pulso central de la mesa como el pequeño acento de velocidad en las notas Sampleplay disparadas en cada negra. Hasta ahora, la lógica consideraba como fuerte el beat con índice `0` dentro del compás de 4/4 (`beatInBar = b % 4; strong = (beatInBar == 0)`), lo que en práctica hacía que el pulso grande del centro de la mesa apareciera visualmente en el tercer tiempo percibido cuando se reproducían Loops basados en el reloj global.
- En `MainComponent_Audio::timerCallback` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L2585-L2615)) se mantiene la derivación de `wholeBeats` a partir de `audioEngine_.transportBeats()`, pero se cambia la condición de acento a `strong = (beatInBar == 2)`. Con este desplazamiento de **dos tiempos dentro del compás 4/4**, el pulso fuerte del centro y el pequeño realce de `velocity01` aplicado en `triggerSampleplayNotesOnBeat(strong)` pasan a coincidir con el primer tiempo percibido en la mayoría de loops de 4 beats usados en las sesiones actuales.
- El resto de elementos sincronizados con el transporte (barra de reproducción roja y trail blanco en los módulos Loop, secuenciador de 16 steps y conexiones visuales) siguen basándose en la misma posición global en beats (`transportBeats_ + beatPhase_`). El cambio se limita al criterio visual de qué beat dentro del compás se considera acentuado para el pulso central y para el acento de Sampleplay, de forma que la sensación de “beat grande” en el centro de la mesa quede alineada con la base rítmica de los Loops.

### Velocidad de expansión de los pulsos centrales
- Se ha acelerado la animación de los pulsos concéntricos del centro de la mesa reduciendo su vida útil visual. En `MainComponent_Audio::timerCallback` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L2195-L2210)) el envejecimiento de cada `Pulse` se basaba en un tiempo de vida fijo de 1.0 s (`pulseLifetimeSeconds = 1.0`), de modo que cada círculo se expandía desde el radio base hasta el máximo y se desvanecía a lo largo de aproximadamente un segundo real.
- Ahora el tiempo de vida se ha reducido a `pulseLifetimeSeconds = 0.5`, por lo que el incremento de `age` por tick (`ageStep = dt / pulseLifetimeSeconds`) es el doble de rápido. El código de pintado en [core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L430-L455) sigue mapeando `pulse.age` a un factor normalizado `t = clamp(age, 0, 1)`, de manera que el radio y la opacidad recorren el mismo rango que antes pero en aproximadamente medio segundo.
- Este ajuste hace que, a un mismo BPM, la sensación visual de “latido” en el centro de la mesa sea más ágil, con ondas que aparecen, se expanden y desaparecen con mayor rapidez, sin alterar el momento en que se generan los pulsos (que sigue anclado a los beats enteros del transporte global) ni la alineación previa con los Loops.

### Rejilla interna de 8 pulsos y compensación de fase del beat
- Se ha cambiado la generación de pulsos del centro de la mesa para que utilice una **rejilla interna de 8 subdivisiones por compás de 4/4** (dos pulsos por beat) en lugar de depender únicamente del contador entero de beats. En `MainComponent_Audio::timerCallback` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L2585-L2625)) se introduce un contador `lastPulseStep_` y se calcula `pulseStepNow = floor((engineBeats + kPulsePhaseOffsetBeats) * 2.0)`, donde `engineBeats` es la posición global de transporte en beats derivada del motor de audio.
- A partir de esa rejilla de 8 pasos (`stepInBar = step % 8`), sólo se generan realmente pulsos visuales y disparos de Sampleplay en los **pasos de negra** (`stepInBar` par), manteniendo así cuatro pulsos “visibles” por compás como antes. El acento fuerte se conserva en la última negra del compás (`stepInBar == 6`), equivalente al beat de índice 3 dentro del 4/4, de forma coherente con la alineación previa establecida para los Loops.
- Para corregir el desfase observado de aproximadamente **medio pulso** respecto a la base de los Loops, se aplica un pequeño desplazamiento de fase puramente visual `kPulsePhaseOffsetBeats = -0.5`, que adelanta los pulsos de la rejilla medio beat sin modificar la posición real del transporte de audio ni el cálculo de `transportBeats_`/`beatPhase_`. El motor de audio y el secuenciador siguen trabajando con `engineBeats` sin offset; sólo la generación de `pulses_` y de los acentos de Sampleplay se basa en la rejilla desplazada.
- Con este cambio, el número de pulsos visibles por compás sigue siendo el mismo (cuatro ondas concéntricas por 4/4), pero su fase se ajusta con resolución de 1/8 de compás gracias a la rejilla interna de 8 pasos, reduciendo la sensación de que el pulso central va “medio tiempo” retrasado respecto a la base rítmica de los Loops.

### Refactorización de módulos con Envelope: AudioModuleWithEnvelope
- Se ha introducido una nueva clase base `AudioModuleWithEnvelope` en [core/src/core/AudioModules.h](core/src/core/AudioModules.h) para unificar la gestión de envolventes ADSR en los módulos de audio que las utilizan. Esta clase hereda de `soundtable::AudioModule` y expone un miembro protegido `Envelope envelope_` junto con dos accesores públicos: `[[nodiscard]] const Envelope& envelope() const` y `Envelope& mutable_envelope()`. El constructor de `AudioModuleWithEnvelope` se delega completamente al de `AudioModule` mediante `using AudioModule::AudioModule`, de modo que los módulos derivados pueden seguir inicializando la parte base con los mismos argumentos que antes.
- Los módulos que previamente mantenían su propia instancia de `Envelope` han pasado a heredar de `AudioModuleWithEnvelope` en lugar de `AudioModule` y han eliminado los campos y getters duplicados:
  - `OscillatorModule` ahora declara `class OscillatorModule : public AudioModuleWithEnvelope` y reutiliza los accesores de la base para su envolvente, manteniendo el resto de su API intacta.
  - `FilterModule` hereda también de `AudioModuleWithEnvelope`; sus métodos específicos `set_envelope_attack/decay/duration/release` siguen operando sobre `envelope_`, pero este miembro se declara ahora en la clase base. La inicialización por defecto de la envolvente (valores en ms y publicación como parámetros `attack/decay/duration/release`) permanece en [core/src/core/AudioModules.cpp](core/src/core/AudioModules.cpp#L80-L120).
  - Los módulos `DelayModule`, `ModulatorModule`, `WaveShaperModule`, `InputModule` y `LoopModule` se han actualizado para heredar de `AudioModuleWithEnvelope` y han eliminado sus campos locales `Envelope envelope_{}`. Sus getters `envelope()`/`mutable_envelope()` ahora provienen de la clase base sin necesidad de redefinirlos, manteniendo la misma interfaz pública para consumidores como `MainComponent_Audio` y los loaders de patches RTP.
- En las implementaciones de constructores de [core/src/core/AudioModules.cpp](core/src/core/AudioModules.cpp) se han actualizado las listas de inicialización para llamar a la nueva base intermedia en lugar de a `AudioModule` directamente:
  - `OscillatorModule`, `FilterModule`, `DelayModule`, `ModulatorModule`, `WaveShaperModule`, `InputModule` y `LoopModule` inicializan ahora con `AudioModuleWithEnvelope(id, ModuleType::..., /*produces_audio=*/..., /*consumes_audio=*/..., /*produces_midi=*/..., /*consumes_midi=*/...)`, preservando exactamente los mismos flags de capacidades de audio/MIDI que antes.
  - El resto de lógica en los constructores (colores, etiquetas, descripciones, configuración de puertos y parámetros por defecto) no se ha modificado.
- Las referencias a `envelope()` en la UI y en los tests siguen funcionando de forma transparente al apoyar ahora en la nueva clase base:
  - En [core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L1351-L1358 y core/src/MainComponent_Audio.cpp#L1985-L1999) se continúa accediendo a `loopModule->envelope()` y `oscModule->envelope()` para configurar las envolventes en el motor de audio sin cambios en la firma.
  - En los tests de dominio de [tests/scene_tests.cpp](tests/scene_tests.cpp#L932-L963) que validan la inicialización y los setters de `FilterModule` se sigue verificando el mismo comportamiento sobre `filter.envelope()` y los parámetros de escena asociados (`attack/decay/duration/release`), confirmando que la migración del miembro `envelope_` a la base no altera la API observada.
- Tras el refactor se ha recompilado todo el proyecto mediante CMake desde `build/` (target `soundtable-core-lib` y binarios asociados) y se ha ejecutado la batería de tests con `ctest --output-on-failure`, obteniendo de nuevo que pasan los ejecutables `soundtable-core-tests` y `soundtable-tracker-tests` sin regresiones. Esto confirma que la introducción de `AudioModuleWithEnvelope` no ha cambiado el comportamiento observable de los módulos ni su integración con la UI o el motor de audio, y deja preparada una base común para futuros módulos que requieran envolventes.

### Alineación del selector de sample en LoopModule
- Se ha corregido la alineación del triángulo selector de sample en los módulos `Loop` dentro del control lateral izquierdo (Freq). Hasta ahora, la punta del triángulo se posicionaba mediante una interpolación lineal vertical entre `sliderBottom` y `sliderTop`, mientras que los cuatro segmentos de la barra se distribuían uniformemente en ángulo a lo largo del arco visible (que deja un margen de 3 px arriba y abajo respecto al semicírculo completo). Esta discrepancia provocaba que, al rotar el fiducial del Loop, el triángulo pareciera entrar en el siguiente segmento antes de que el slot activo cambiara realmente, generando una sensación de desalineación.
- En `MainComponent::paint` ([core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L1688-L1820)) el cálculo de la posición del triángulo se ha actualizado para reutilizar el mismo rango angular que ya usan los segmentos de la barra. En lugar de mapear `sampleParam` directamente a una coordenada Y lineal, ahora se obtiene un ángulo `triAngle` mediante `juce::jmap(sampleParam, 0.0f, 1.0f, angleBottom, angleTop)` y se proyecta la punta del triángulo sobre el mismo círculo de radio `ringRadius` (`barX = cx - ringRadius * cos(triAngle)`, `triY = cy + ringRadius * sin(triAngle)`). De este modo, el triángulo recorre exactamente el mismo arco visible que los cuatro segmentos, respetando el margen de 3 px en la parte superior e inferior.
- El índice de segmento activo (`activeIndex`) sigue derivándose de `sampleParam` cuantizado en cuatro slots (`int(sampleParam * 4.0f)`), de forma que el resaltado de segmento y la posición angular del triángulo permanecen sincronizados: cuando el usuario gira el fiducial, el triángulo cruza los límites entre segmentos en el mismo instante en que cambia el slot de sample reproducido. Esto elimina el efecto visual de “ya está en el otro segmento pero aún no cambia”.

### Barra de reproducción y trail para LoopModule
- Se ha añadido una barra de reproducción visual alrededor de los módulos `Loop` en la UI principal de `soundtable-core`. Para cada `LoopModule` dentro del área musical se dibuja ahora una línea fina roja de 2 px que orbita entre el cuerpo circular del módulo y el anillo de controles laterales (Freq/Gain), siguiendo una trayectoria circular completa alrededor del nodo.
- La posición angular de la barra roja se calcula a partir del mismo reloj de transporte que usa el motor de audio: en `MainComponent_Audio::timerCallback` ya se sincroniza `transportBeats_` y `beatPhase_` con `audioEngine_.transportBeats()`, y en `MainComponent::paint` ([core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L1460-L1785)) se obtiene una fase normalizada de loop `phase01` aplicando un `fmod` de `transportBeats_ + beatPhase_` por el número de beats declarados en el `LoopDefinition` activo. Esto garantiza que la barra de reproducción está bloqueada en fase con la posición real del sample que se está reproduciendo en el motor de audio.
- Para cada `LoopModule` se mantiene ahora un pequeño historial de muestras de fase en `loopPlayTrails_` ([core/src/MainComponent.h](core/src/MainComponent.h#L120-L170)), donde cada entrada almacena `phase01` y un timestamp en segundos. En cada frame de pintado se inserta la muestra actual y se purgan las que superan una ventana de 300 ms o exceden un máximo de 15 segmentos, de forma que el coste de mantenimiento del trail permanece acotado.
- A partir de ese historial, el pintado dibuja primero la traza blanca (trail) y después la barra roja actual: para cada muestra reciente de `loopPlayTrails_` se calcula el ángulo correspondiente y se traza una pequeña barra radial blanca en el mismo anillo, con una opacidad que decae linealmente desde 1.0 a 0.0 a lo largo de los 300 ms de ventana. El resultado es una estela blanca que sigue a la barra roja y se desvanece rápidamente, reforzando visualmente el sentido de movimiento continuo del loop.
- La barra roja actual se dibuja siempre por encima del trail (plena opacidad, color `juce::Colours::red`) utilizando un radio interior `innerRadius = nodeRadius + 3.0f` y uno exterior `outerRadius = ringRadius - 3.0f`, de modo que queda claramente situada en el espacio entre el círculo del módulo y las barras de Freq/Gain sin solaparlas. Como todo el pintado del nodo se realiza dentro de una `AffineTransform::rotation` alrededor del centro del módulo, la barra de reproducción mantiene su órbita correctamente alineada con la orientación del nodo y con la radial de audio hacia el master.
- La lógica de la barra de reproducción sólo se activa cuando el loop activo tiene un metadato de beats válido (`LoopDefinition::beats > 0`); en ese caso el ángulo se deriva de la fase de beat global y el número de beats del loop, garantizando que los cambios de slot (cuando el usuario rota o hace scroll sobre el módulo Loop) mantienen los distintos samples perfectamente alineados con el transporte.

### Indicador visual de tráfico OSC/TUIO en soundtable-core
- Se ha añadido un pequeño indicador de actividad de entrada en la UI principal de `soundtable-core` para mostrar de forma discreta si la aplicación está recibiendo tráfico de tracking vía OSC propietario (`/soundtable/*`) o vía TUIO estándar (`/tuio/*`). El indicador aparece como una etiqueta compacta `OSC` o `TUIO` en la esquina superior derecha de la mesa, justo a la izquierda del dock, y se oculta automáticamente si pasan 60 segundos sin recibir ningún mensaje de entrada.
- Para ello se ha extendido `TrackingOscReceiver` en [core/src/TrackingOscReceiver.h](core/src/TrackingOscReceiver.h) y [core/src/TrackingOscReceiver.cpp](core/src/TrackingOscReceiver.cpp) con un nuevo enum `ActivityKind { kOsc, kTuio }` y un callback opcional `setActivityCallback(std::function<void(ActivityKind)>)`. El receptor invoca este callback cada vez que clasifica un mensaje entrante como tráfico OSC propietario (`/soundtable/object`, `/soundtable/remove`) o como tráfico TUIO (`/tuio/hello`, `/tuio/2Dobj`, `/tuio/2Dcur)`; los mensajes en otras rutas siguen tratándose únicamente como logs de depuración y no disparan el indicador.
- `MainComponent` mantiene ahora un pequeño estado de actividad en [core/src/MainComponent.h](core/src/MainComponent.h): un enum interno `InputActivityKind { kNone, kOsc, kTuio }`, un timestamp `lastInputActivitySeconds_` y otro `inputActivityPulseSeconds_`. El callback registrado en el constructor ([core/src/MainComponent.cpp](core/src/MainComponent.cpp)) traduce `ActivityKind` a `InputActivityKind`, actualiza los timestamps con el reloj de alta resolución de JUCE y solicita un `repaintWithRateLimit()` para que la UI refleje el nuevo mensaje sin superar el límite global de FPS.
- En `MainComponent::paint` ([core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp)) se calcula siempre un rectángulo de referencia para el dock (`dockAreaUi`) a partir de `calculateDockWidth`, independientemente de que existan o no objetos docked. A partir de ese rectángulo se dibuja, si corresponde, una cápsula semitransparente alineada con la parte superior de la mesa y situada justo a la izquierda del dock, que contiene el texto `TUIO` o `OSC` y una pequeña bolita verde. El texto se muestra mientras `now - lastInputActivitySeconds_ <= 60` y cambia automáticamente de `OSC` a `TUIO` cuando el último mensaje procesado pertenece al flujo TUIO.
- La bolita verde funciona como un “parpadeo” de tráfico: cada vez que llega un mensaje válido el callback actualiza `inputActivityPulseSeconds_` y el bloque de pintado muestra el círculo durante un intervalo corto (≈250 ms) calculado como `now - inputActivityPulseSeconds_ <= 0.25`. De este modo, cada paquete entrante genera un destello visible sobre la etiqueta sin necesidad de mantener un contador explícito por tick.
- Para que el indicador pueda repintarse incluso en escenas sin audio activo ni animaciones, se ha ampliado la condición `hasVisualActivity` en `MainComponent_Audio::timerCallback` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp)) para considerar también la ventana de visibilidad del indicador: mientras `lastInputActivitySeconds_` esté dentro de los últimos 60 segundos o la ventana corta del pulso esté activa, `timerCallback` llamará a `repaintWithRateLimit()`. Esto garantiza que el texto del protocolo y los destellos verdes se actualicen sin reactivar otras animaciones innecesarias.
