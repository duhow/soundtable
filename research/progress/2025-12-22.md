## AudioEngine y visualización de conexiones

- Se ha ajustado el ruteo de Loop hacia el filtro de bus para que solo los módulos Loop realmente conectados a un Filter pasen por dicho filtro; el resto se mezcla directamente al master sin procesar.
- Se ha separado la historia visual de los osciladores en pre‑filtro y post‑filtro usando dos contenedores `Voices` distintos en `AudioEngine`, alineando así los snapshots con el diseño de voces por módulo.
- Se ha actualizado la pintura de conexiones para que, al dibujar la forma de onda, utilice el snapshot pre‑filtro o post‑filtro según el `ConnectionVisualSource::Kind`, de forma que tramos como Oscillator → Filter muestren la señal original y Filter → Master la señal filtrada.
# Progreso 2025-12-22

- Definido el plan de refactor de soundwaves y Voces en [research/soundwave_voices_refactor_plan.md](research/soundwave_voices_refactor_plan.md), alineando el modelo visual con Voces por módulo y una clase dedicada a la generación de buffers de waveform, y estableciendo fases claras para migrar desde los buffers actuales en `AudioEngine`/`MainComponent` hacia un sistema unificado y extensible.

- Integrado el parser de argumentos `argparse` (v3.2, MIT) en el binario `rectai-tracker`, reemplazando el parseo manual de `argv` en `tracker/src/main.cpp`.
- Añadida la dependencia vendorizada en `external/argparse` y actualizados los includes en `tracker/CMakeLists.txt` para exponer `argparse/argparse.hpp`.
- Verificado que el proyecto compila correctamente en modo Debug con la nueva ruta de includes y que las opciones de línea de comandos del tracker mantienen el mismo contrato lógico (modo, cámara, resolución, fps, flags de depuración/OSC y filtros).

- Arreglado el mapeo de modos de filtro en `AudioEngine` para que los ids de `FilterModule` (0=lowpass, 1=bandpass, 2=highpass) coincidan con los tipos de `StateVariableTPTFilter` tanto en filtros por voz como en los buses estéreo (Sampleplay y Loop).
- Añadido un log de depuración en `MainComponent_AudioRouting` (solo en builds Debug) que reporta qué módulo `Filter` y qué parámetros (modo y cutoff) se están aplicando a los buses de Sampleplay y Loop, para poder diagnosticar fácilmente problemas de routing de filtros desde la escena.
- Actualizado el uso de los filtros de bus en `AudioEngine` para que se activen cuando `cutoffHz>0` (independientemente del modo), de forma que el modo 0 (lowpass) también se procese correctamente en Sampleplay y Loop.
- Hecho permanente el log de routing de filtros en `MainComponent_AudioRouting` (ya no está protegido por `NDEBUG`) para poder ver en Release qué filtro y qué parámetros se están usando en los buses globales mientras se estabiliza esta parte del motor.

- Extendida la lógica de routing de filtros globales en `MainComponent_AudioRouting` para que el bus de Loop use la misma heurística que Sampleplay: se selecciona el `FilterModule` más cercano con conexión Loop→Filter activa (no muteada, dentro del área musical y respetando conos dinámicos) y se aplican sus parámetros (`freq`, `q`, modo) al bus estéreo de Loop vía `AudioEngine::setLoopFilter`.
- Añadido un log compacto `[rectai-core][filter-routing]` que reporta, en cada tick de audio, qué módulo de filtro y qué parámetros efectivos se están aplicando a los buses de Sampleplay y Loop, para poder depurar escenas donde el filtro parece no afectar a Sampleplay/Loop a pesar de estar conectado visualmente.

- Ajustada la lógica de dibujo de radiales en `MainComponent_Paint` para que los módulos `Loop` se comporten como los generadores: cuando un Loop alimenta a otro módulo de audio (por ejemplo Loop→Filter) a través de una conexión activa, se oculta su radial directo al master y solo se mantiene visible la radial del módulo de destino. Esto evita el efecto visual de “doble línea” saliendo del Loop cuando está encadenado con un filtro.
- Mejorada la visualización de waveforms para cadenas Loop→Filter: ahora las conexiones Loop→X sin tap dedicado reutilizan el historial de waveform por-módulo de Loop tanto en los segmentos Loop→Filter como en las radiales agregadas de los módulos consumidores (p.ej. Filter). De este modo, cuando un filtro recibe audio únicamente desde uno o varios Loop, tanto la conexión como la radial del filtro muestran la actividad del loop en lugar de quedarse como líneas planas.

- Unificada la visualización de waveforms entre radiales y conexiones módulo→módulo para generadores y loops: las conexiones Loop→Filter y Oscillator→Filter utilizan ahora las mismas fuentes de historial (per-módulo Loop y per-voz del Oscillator) y la misma normalización/amplitud que sus radiales respectivas (`Loop→Master` y `Oscillator→Master`). Además, las radiales de filtros cuando agregan entradas desde Loop normalizan la suma y dibujan a amplitud completa, de modo que la línea Filter→Master muestra claramente la actividad del Loop incluso cuando la señal RMS es baja.

- Ajustada la amplitud visual de las conexiones cuyo origen es un Oscillator para que usen el nivel visual del propio módulo (ganancia) en lugar de depender solo del RMS de la waveform del tap. De este modo, las líneas Oscillator→Filter dejan de verse planas y recuperan una altura de onda coherente con la radial del Osc, mientras que la radial Filter→Master sigue mostrando la señal “recibida” (agregada y normalizada) desde sus entradas.

- Fijada la decisión de Fase 0B para Sampleplay en el plan de Voces (una Voz visual por `SampleplayModule`, aun con un solo `SampleplaySynth` global) y documentado el inventario actual de buffers de waveform y puntos de lectura en `AudioEngine`/`MainComponent`.
- Añadido el helper `fetchNormalisedLoopWaveform` en `core/src/MainComponent_Paint.cpp` para centralizar la lectura/normalización de waveforms de Loop en radiales y segmentos, sin cambiar el comportamiento observable y preparando el código para redirigir estas lecturas a la futura clase `Voices`.
- Creada la clase `rectai::Voices` en `core/src/core/Voices.h/.cpp`, implementando un ring buffer circular por voz (sin dependencias de JUCE) con API mínima (`setSampleRate`, `reset`, `writeSamples`, `getSnapshot`) para gestionar buffers mono por módulo productor/procesador de audio.
- Integrada `Voices` en `rectai-core-lib` a través del glob `src/core/*.cpp` del CMake de core, sin conectarla todavía a `AudioEngine` ni a la UI, de forma que el sistema actual de waveforms sigue siendo la única fuente de datos visuales mientras se prepara la siguiente fase del refactor.
- Conectada la instancia `visualVoices_` dentro de `AudioEngine` para que el hilo de audio escriba directamente en `Voices`: las voces de Oscillator usan ids `[0,kMaxVoices)` (señal post‑filtro con envolvente/ganancia) y los LoopModules reutilizan sus índices `visualWaveformIndex` como ids `[kMaxVoices,kMaxVoices+kMaxLoopWaveforms)` escribiendo `monoDry` por módulo.
- Actualizado `research/soundwave_voices_refactor_plan.md` para reflejar que la Fase 3 ya tiene Voces activas para Oscillator y Loop (alimentadas desde el callback de audio) mientras Sampleplay y FX quedan pendientes, manteniendo los buffers legacy como fuente única para la UI hasta abordar la migración visual en fases siguientes.
 - Extendida la estructura de `visualVoices_` en `AudioEngine` para reservar ids específicos de Voces visuales a nivel de bus: `kVisualVoiceIdSampleplayRaw` para la ruta mono global de Sampleplay pre‑filtro y `kVisualVoiceIdLoopBus` para la suma de Loop tras el filtro de bus, documentando el layout completo de ids (Oscillator, Loop por módulo y buses globales).
 - Restaurado el avance del transporte interno en beats (`transportBeatsInternal_` / `transportBeatsAudio_`) en `audioDeviceIOCallbackWithContext`, calculado a partir del BPM global (`loopGlobalBpm_`) y el `sampleRate_`, para que la alineación de loops y las visuales sincronizadas con beat sigan avanzando incluso cuando la escena está silenciosa.
 - Reimplementado `AudioEngine::getLoopModuleWaveformSnapshot` para que obtenga los historiales de Loop directamente desde `visualVoices_` usando el id de voz `[kMaxVoices + wfIndex]` en lugar de leer del ring buffer legacy `loopWaveformBuffers_`, de forma transparente para la UI.
 - Ajustada la descripción de la Fase 4 en `research/soundwave_voices_refactor_plan.md` para aclarar que parte de la migración de waveforms a Voces se puede hacer a través de wrappers en `AudioEngine` que ya delegan en `visualVoices_` (empezando por Loop), antes de simplificar por completo la lógica de pintado en `MainComponent_Paint`.
 - Reimplementadas también `AudioEngine::getVoiceWaveformSnapshot` y `AudioEngine::getVoiceFilteredWaveformSnapshot` para que lean de `visualVoices_` (ids `[0,kMaxVoices)`) en lugar de muestrear directamente los buffers `voicePreFilterWaveformBuffer_`/`voicePostFilterWaveformBuffer_`, de modo que todas las radiales y visuales basadas en voces de Oscillator usen ya la estructura unificada de Voces sin cambiar las llamadas en la UI.
 - Actualizada la descripción de la Fase 4 en `research/soundwave_voices_refactor_plan.md` para reflejar que, a partir de ahora, tanto LoopModules como las voces de Oscillator están abastecidos por Voces a través de los wrappers de `AudioEngine`, y que los siguientes pasos se centrarán en las conexiones (taps y `connectionVisualSources_`) y en simplificar la lógica de pintado sobre este nuevo contrato.

- Actualizada la Fase 4 del plan de Voces para dejar constancia de que las soundwaves visibles de Oscillator, Loop y Sampleplay se obtienen ya exclusivamente desde `visualVoices_` (per-voz, por módulo y bus global respectivamente), manteniendo los buffers legacy sólo como soporte interno mientras se aborda su eliminación en la Fase 5.
- Refactorizadas las secciones de pintado de radiales y conexiones en `core/src/MainComponent_Paint.cpp` para sustituir todas las lecturas de `getConnectionWaveformSnapshot` por rutas basadas en Voces: las conexiones que antes usaban taps por voz se resuelven ahora vía `ConnectionVisualSource` y `getVoiceFilteredWaveformSnapshot`, las entradas desde Loop reutilizan `getLoopModuleWaveformSnapshot` (ya delegado en `visualVoices_`) y todas las visuales relacionadas con Sampleplay (radiales y conexiones) leen de un nuevo helper `AudioEngine::getSampleplayBusWaveformSnapshot` que encapsula el id de Voz global de Sampleplay.
- Conservada la estructura `ConnectionVisualSource` y el sistema de taps en `AudioEngine` para compatibilidad hacia atrás, pero la UI ha dejado de usar `connectionWaveformBuffers_` como fuente de datos; a efectos visuales, las conexiones y radiales se apoyan exclusivamente en Voces por módulo/bus, cumpliendo el objetivo de la Fase 4 sin cambiar el contrato público de APIs existente.

- Eliminada la infraestructura interna de taps de conexión en `AudioEngine`: se han retirado el enum `ConnectionTapSourceKind`, las funciones `clearAllConnectionWaveformTaps`, `configureConnectionWaveformTap` y `getConnectionWaveformSnapshot`, junto con los buffers `connectionWaveformBuffers_`, `waveformBuffer_` y `loopWaveformBuffers_` y el índice global `waveformWriteIndex_`. Las únicas fuentes de historial de waveform en el motor pasan a ser las Voces (`visualVoices_`) y los wrappers `getVoiceWaveformSnapshot` / `getVoiceFilteredWaveformSnapshot` / `getLoopModuleWaveformSnapshot` / `getSampleplayBusWaveformSnapshot`, que ya delegan íntegramente en esa estructura.
- Simplificado `core/src/MainComponent_Audio.cpp` eliminando la reconstrucción periódica de taps por conexión basada en `connectionVisualSources_`: el mapeo visual de conexiones sigue existiendo, pero ahora sólo se utiliza desde `core/src/MainComponent_Paint.cpp` para decidir qué Voz (por módulo o bus) samplear al pintar radiales y líneas, cerrando así la Fase 5 en lo relativo a la eliminación de buffers legacy y taps en el flujo de soundwaves.

- Corregida la implementación de `rectai::Voices` en [core/src/core/Voices.h](core/src/core/Voices.h) y [core/src/core/Voices.cpp](core/src/core/Voices.cpp) para que cada voz mantenga su propio índice de escritura circular en lugar de compartir un índice global entre todas. Antes, al escribir muestras de forma incremental (una muestra por voz y por sample de audio), se introducían huecos y datos obsoletos en los historiales por voz, lo que distorsionaba la forma de onda visible de Oscillator y Loop (por ejemplo, cuadrados que se veían más cercanos a un saw y loops con soundwaves “raras”). Ahora cada voz avanza su propio índice (`writeIndices_`), de modo que los snapshots devueltos por `getSnapshot` representan una secuencia temporal continua y coherente para esa voz.
