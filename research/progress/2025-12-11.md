## 2025-12-11

### Configuración de envelope ADSR en FilterModule
- El módulo `FilterModule` incluye ahora valores por defecto para los parámetros de envelope ADSR (Attack, Decay, Duration, Release), inicializados en milisegundos:
  - `attack = 500.0F` ms
  - `decay = 500.0F` ms
  - `duration = 1000.0F` ms
  - `release = 500.0F` ms
- Estos valores se almacenan tanto en la estructura `Envelope` interna del módulo (`envelope_`) como en los parámetros lógicos del `AudioModule` mediante `SetParameter`, garantizando que estén disponibles tanto para el procesamiento futuro como para la UI y serialización.
- Se han añadido métodos públicos para configurar cada componente del envelope de forma independiente:
  - `set_envelope_attack(float attack_ms)`
  - `set_envelope_decay(float decay_ms)`
  - `set_envelope_duration(float duration_ms)`
  - `set_envelope_release(float release_ms)`
- Cada uno de estos métodos actualiza tanto el miembro `envelope_` como el parámetro correspondiente en el mapa de parámetros del módulo, manteniendo ambos sincronizados.
- El método `default_parameter_value` de `FilterModule` se ha extendido para devolver los valores configurados del envelope cuando se soliciten los parámetros `"attack"`, `"decay"`, `"duration"` o `"release"`, permitiendo que la UI y otros componentes lean estos valores mediante `GetParameterOrDefault`.
- Se han añadido tests en `tests/scene_tests.cpp` que verifican:
  - Los valores por defecto del envelope (500/500/1000/500 ms).
  - Que los parámetros pueden leerse correctamente mediante `GetParameterOrDefault`.
  - Que los setters actualizan tanto el envelope interno como los parámetros lógicos del módulo de forma coherente.
- Esta implementación prepara el terreno para que el motor de audio utilice estos parámetros de envelope en el procesamiento del filtro y para que la UI pueda exponer controles que permitan al usuario ajustar el envelope de forma dinámica.

### Touch interface visual feedback
- `MainComponent` incorpora ahora un sistema de feedback visual para simular interacciones táctiles sobre la interfaz:
  - **Cursor circular**: al hacer click/touch en la ventana, aparece un círculo con borde vacío (12px de radio, grosor de borde 8px) que representa la posición del dedo:
    - **Color rojo** (#FF0000 con opacidad 0.298, equivalente visual a #4C0000 sobre negro) cuando el touch se inicia en el área principal de la ventana (excluida la barra dock).
    - **Color gris claro** (0xFFCCCCCC) cuando el touch se inicia desde la barra dock.
  - **Rastro de movimiento con fade-out**: mientras el cursor se mantiene presionado (hold) en el área de la ventana (excluyendo el dock), se dibuja un rastro rojo (#FF0000) fino (1.5px) que sigue la trayectoria del movimiento.
    - El rastro implementa un sistema de desvanecimiento (fade-out) temporal: cada punto del rastro tiene un timestamp asociado y su opacidad disminuye linealmente durante 400ms hasta desaparecer completamente.
    - Los puntos se dibujan segmento por segmento con transparencia calculada en función de su edad: `alpha = 1.0 - (edad / 0.4s)`.
    - Los puntos que han superado los 400ms se eliminan automáticamente del vector durante `mouseDrag`, manteniendo el consumo de memoria bajo control.
    - El sistema de fade-out está controlado por la constante `kEnableTrailFade` (por defecto `true`), permitiendo desactivarlo por código si fuera necesario sin cambios estructurales.
  - **Limitación de memoria**: el rastro mantiene un máximo de 500 puntos (`kMaxTrailPoints`) como límite absoluto para prevenir consumo excesivo de memoria en movimientos largos.
- Variables de estado añadidas a `MainComponent.h`:
  - `isTouchActive_`: indica si hay un touch activo (mouseDown).
  - `isTouchHeld_`: indica si el touch está siendo mantenido (mouseDrag).
  - `touchStartedInDock_`: registra si el touch inicial fue dentro de la zona del dock, determinando el color del círculo.
  - `currentTouchPosition_`: posición actual del cursor/toque.
  - `touchTrail_`: vector de `TrailPoint` (estructura con `position` y `timestamp`) que acumula la trayectoria con información temporal para el fade-out.
  - `kEnableTrailFade`: constante booleana (true) que controla el sistema de desvanecimiento del rastro.
  - `kTrailFadeDurationSeconds`: constante que define la duración del fade-out (0.4 segundos).
- Actualizaciones en `MainComponent_Input.cpp`:
  - `mouseDown`: inicializa el estado del touch, determina si comenzó en el dock mediante el cálculo del área del dock con `calculateDockWidth`, limpia el trail previo y dispara `repaint()`.
  - `mouseDrag`: marca `isTouchHeld_` como true, actualiza la posición del cursor, añade puntos al trail con timestamp actual (usando `juce::Time::getMillisecondCounterHiRes()`), elimina puntos obsoletos (edad > 400ms) si el fade está activo, y dispara `repaint()`.
  - `mouseUp`: resetea todo el estado del touch (`isTouchActive_`, `isTouchHeld_`, `touchStartedInDock_`), limpia el trail y dispara `repaint()`.
- Renderizado en `MainComponent_Paint.cpp`:
  - El rastro se dibuja segmento por segmento (línea entre puntos consecutivos), calculando la transparencia de cada segmento según la edad del punto destino.
  - Luego se dibuja el círculo del cursor con `drawEllipse` usando el color correspondiente (#4C0000 o gris claro) y un grosor de 2px.
- El estado `isTouchHeld_` queda almacenado para poder extenderlo en futuras features que requieran conocer si el usuario está manteniendo presionado el cursor.

### Touch line cutting para alternar mute
- Implementado sistema de "corte" de líneas de audio mediante gestos táctiles para alternar el estado de silencio (mute/unmute) de forma intuitiva:
  - **Detección de intersección**: mientras el cursor está en hold (arrastre), el sistema detecta cuando el trail cruza líneas de audio:
    - **Líneas objeto-a-centro** (blancas): representan el output de sonido de cada módulo hacia el master.
    - **Hardlinks módulo-a-módulo** (rojas): conexiones fijas entre módulos.
    - **Conexiones dinámicas** (blancas curvas): conexiones que dependen del cono geométrico de 120º.
  - **Marcado visual con toggle**: cada vez que el cursor cruza una línea, ésta se marca o desmarca (toggle) y cambia a **color amarillo con grosor aumentado (3px)**, proporcionando feedback visual inmediato de que está marcada para alternar su mute.
  - **Aplicación al soltar**: cuando se suelta el ratón (`mouseUp`), todas las líneas marcadas alternan su estado de mute:
    - Líneas mutadas pasan a activas.
    - Líneas activas pasan a mutadas.
  - **Algoritmo de intersección**: nueva función helper `lineSegmentsIntersect` en `MainComponentHelpers` que calcula la distancia mínima entre dos segmentos de línea y detecta intersección con un threshold de 15px.
  - **Sistema de transiciones enter/exit**: mantiene sets de intersección actual (`touchCurrentlyIntersectingConnections_`, `touchCurrentlyIntersectingObjects_`) que detectan cuando el cursor **entra** en la zona de intersección (intersects && !wasIntersecting) para hacer toggle, y cuando **sale** (!intersects && wasIntersecting) para actualizar el estado, permitiendo cruzar repetidamente la misma línea con toggle alternado en cada cruce:
    - 1ª pasada: marca para mute (amarillo).
    - 2ª pasada: desmarca (vuelve a color original).
    - 3ª pasada: vuelve a marcar (amarillo), etc.
  - **Exclusión de drag de módulos**: no detecta líneas cuando se está moviendo un módulo (`draggedObjectId_ != 0`), evitando marcados accidentales al reposicionar objetos en la mesa.
  - **Estructuras de tracking**:
    - `touchCutConnections_`: set de claves de conexión marcadas para toggle al soltar.
    - `touchCutObjects_`: set de IDs de objetos cuyas líneas al centro están marcadas para toggle.
    - `touchCurrentlyIntersectingConnections_`/`touchCurrentlyIntersectingObjects_`: sets temporales para tracking de transiciones.
- El sistema respeta la lógica existente de visibilidad de líneas (área musical, conexiones activas, controladores globales).
- Código actualizado:
  - `MainComponent.h`: añadidos 4 sets de tracking (cut + currentlyIntersecting).
  - `MainComponent_Input.cpp`: detección de transiciones en `mouseDrag` con condición `draggedObjectId_ == 0`, aplicación de toggle en `mouseUp`, limpieza en `mouseDown`.
  - `MainComponent_Paint.cpp`: renderizado condicional de líneas en amarillo con grosor aumentado.
  - `MainComponentHelpers.{h,cpp}`: función `lineSegmentsIntersect` para geometría de intersección.

### Click-and-hold temporary mute con split rendering en líneas de audio
- Implementado nuevo comportamiento para la interacción con líneas de audio: al hacer click en una línea, el módulo se silencia temporalmente mientras se mantiene presionado el botón, con visualización parcial de la waveform:
  - **Mute temporal durante hold**: al hacer click en una línea de audio (tanto object-to-center como module-to-module), el sistema:
    - Calcula la posición normalizada (0-1) del punto de click a lo largo de la línea.
    - Aplica mute inmediato al módulo/conexión correspondiente.
    - Almacena el estado de mute previo: si la línea ya estaba silenciada antes del click, se recuerda para no desmutar al soltar.
    - Al soltar el click (`mouseUp`), se desmutea automáticamente solo si la línea no estaba previamente muteada.
  - **Split rendering visual**: durante el hold, la línea se renderiza en dos segmentos:
    - **Segmento activo** (source → split point): muestra la waveform de audio normalmente si hay señal activa, demostrando que hasta ese punto la señal sigue siendo audible.
    - **Segmento silenciado** (split point → destination): se dibuja con línea punteada (dashed) con transparencia reducida (0.6F), indicando visualmente que desde ese punto en adelante la señal está muted.
  - **Cursor blanco sin trail**: mientras se mantiene el click en una línea de audio:
    - El cursor cambia a **color blanco** (`juce::Colours::white.withAlpha(0.8F)`), diferenciándose del rojo normal para indicar modo de interacción especial.
    - El **trail rojo desaparece** (no se dibuja), eliminando el rastro de movimiento y proporcionando feedback visual claro de que estamos en modo "hold mute" y no en modo "line cutting".
  - **Estructuras de estado**:
    - Nuevo `ConnectionHoldState` en `MainComponent.h` que almacena:
      - `connection_key` o `object_id`: identifica la línea afectada.
      - `is_object_line`: distingue entre línea object-to-center (true) o module-to-module (false).
      - `split_point`: posición normalizada (0-1) donde se hizo click.
      - `was_previously_muted`: estado de mute anterior al click para restauración correcta.
    - Variable `std::optional<ConnectionHoldState> activeConnectionHold_` que marca si hay una línea siendo held.
  - **Implementación**:
    - `MainComponent_Input.cpp`:
      - `mouseDown`: al detectar click en línea (segment hit-test), calcula el `splitPoint` mediante proyección vectorial del punto de click sobre el segmento (producto punto normalizado), almacena el estado previo de mute, activa el mute inmediato y guarda todo en `activeConnectionHold_`.
      - `mouseUp`: si hay `activeConnectionHold_` activo, desmutea la línea solo si `!was_previously_muted`, luego resetea `activeConnectionHold_`.
    - `MainComponent_Paint.cpp`:
      - Render de líneas object-to-center: si `activeConnectionHold_` está activo y coincide con la línea, calcula `splitPoint` interpolado y renderiza:
        - Primer segmento con waveform (si audio activo) desde center hasta split.
        - Segundo segmento dashed desde split hasta object.
      - Render de conexiones module-to-module: similar split rendering aplicado a hardlinks y dynamic connections, usando líneas rectas desde p1 a splitPoint con waveform, y dashed desde splitPoint a p2.
      - Cursor: condición `activeConnectionHold_.has_value()` cambia color a blanco y desactiva el dibujado del trail rojo.
  - **Compatibilidad con line cutting**: el sistema convive con el mecanismo de line cutting previo (drag con trail para toggle permanente de mute), diferenciándose por el cursor blanco vs rojo y la ausencia de trail durante hold.
- Este comportamiento proporciona control temporal fino sobre el audio, permitiendo escuchar cómo suena la señal hasta un punto específico de la cadena, útil para debugging y performance en vivo.
- Código actualizado:
  - `MainComponent.h`: añadidos `#include <optional>`, estructura `ConnectionHoldState` y variable `activeConnectionHold_`.
  - `MainComponent_Input.cpp`: cálculo de split point en hit-test de líneas, almacenamiento de estado hold, lógica de unmute condicional en `mouseUp`.
  - `MainComponent_Paint.cpp`: render condicional de split en líneas object-to-center y module-to-module, cambio de cursor a blanco y supresión de trail durante hold.

#### Correcciones de bugs en click-and-hold mute
- **Separación de interacciones**: se ha corregido la lógica para prevenir que el sistema de "line cutting" (cursor rojo con trail) se active durante el modo "hold mute" (cursor blanco sin trail):
  - Añadida condición `!activeConnectionHold_.has_value()` en la detección de intersecciones de líneas durante `mouseDrag`.
  - Esto asegura que ambos modos de interacción sean mutuamente excluyentes y no interfieran entre sí.
- **Corrección de dirección de split rendering**: se ha invertido la dirección de los segmentos visuales para reflejar correctamente el flujo de audio:
  - **Segmento con waveform**: ahora va desde el **módulo (origen)** hasta el **punto de click**, mostrando que la señal de audio se genera en el módulo y viaja hasta donde el usuario presiona.
  - **Segmento punteado/silenciado**: ahora va desde el **punto de click** hasta la **salida (centro/master o módulo destino)**, indicando que desde ese punto hacia adelante la señal está cortada/muteada.
  - En líneas object-to-center: waveform de `{cx, cy}` (objeto) a `splitPoint`, dashed de `splitPoint` a `centre` (master).
  - En líneas module-to-module: waveform de `p1` (from/source) a `splitPoint`, dashed de `splitPoint` a `p2` (to/destination).
- **Visualización de waveform durante mute**: se ha corregido para que la waveform se muestre **siempre** en el segmento activo (origen → split) cuando hay señal de audio, **incluso si el módulo está temporalmente muteado** durante el hold:
  - El código de render durante `isBeingHeld` ya no filtra por estado de mute para decidir si dibuja la waveform.
  - Esto permite al usuario ver visualmente que el módulo está generando audio hasta el punto de corte, proporcionando feedback más intuitivo.
- **Unmute incondicional al soltar**: se ha corregido la lógica de `mouseUp` para que **siempre desmutee** la línea al soltar el click, independientemente de si estaba muteada previamente o no:
  - Eliminado el campo `was_previously_muted` de `ConnectionHoldState`.
  - Eliminadas las condiciones que chequeaban el estado previo antes de desmutar.
  - Ahora `mouseUp` simplemente llama a `erase()` en `mutedObjects_` o `mutedConnections_` sin condiciones, garantizando que al soltar el click la línea siempre quede activa (no muted).
- Estas correcciones mejoran la coherencia visual y funcional del sistema de control temporal de mute, alineando el comportamiento con las expectativas del usuario sobre el flujo direccional de la señal de audio.
- **Corrección crítica - generación de waveform en AudioEngine con level=0**: se ha corregido el problema fundamental donde la waveform no se mostraba durante el hold mute (mostrando solo línea blanca):
  - **Problema raíz en tres capas**:
    1. En `MainComponent_Audio.cpp`: cuando un módulo se muteaba, `level = 0` y no entraba en `if (level > 0)`, no asignando voice index.
    2. Tras corregir eso para procesar con `isBeingHeld`, el voice se configuraba con `outputLevel = 0` en el AudioEngine.
    3. **Problema final**: En `AudioEngine.cpp`, la condición `if (level > 0.0F && freq > 0.0)` impedía la generación del oscillador cuando `level = 0`, por lo que `voiceWaveformBuffer_` quedaba en 0 y no había datos que visualizar.
  - **Solución implementada en tres capas**:
    1. **AudioEngine** (`AudioEngine.cpp`): Modificada la lógica de generación de waveform para que funcione **independientemente del level**:
       - Cambiada condición de `if (level > 0.0F && freq > 0.0)` a solo `if (freq > 0.0)`.
       - Los oscilladores (sine, saw, square, noise) ahora generan waveform a **amplitud completa** (sin multiplicar por level).
       - La waveform sin escalar se almacena en `voiceWaveformBuffer_[v][bufIndex]` para visualización.
       - El `level` se aplica **después**, solo para el output mezclado: `scaledOutput = s * level`.
       - Esto permite capturar la forma de onda real del oscillador incluso cuando `level = 0`.
    2. **Motor de audio** (`MainComponent_Audio.cpp`): Lógica para procesar voices durante `isBeingHeld`:
       - Añadida detección de `isBeingHeld` verificando si objeto/conexión está en hold.
       - Cambiada condición a `if ((calculatedLevel > 0.0F || isBeingHeld))` para forzar procesamiento.
       - El `outputLevel` es 0 durante hold, silenciando la salida pero permitiendo generación interna.
    3. **Capa de renderizado** (`MainComponent_Paint.cpp`): Búsqueda directa de `voiceIndex` sin dependencias de flags de mute durante `isBeingHeld`.
  - **Resultado**: La waveform ahora se visualiza correctamente en el segmento activo (módulo → split point) durante el hold mute, mostrando la forma de onda real del audio generado internamente aunque la salida esté completamente silenciada.
  - **Corrección adicional - consistencia de waveform**: se ha corregido un problema donde la forma de onda mostrada cambiaba completamente al hacer click en diferentes posiciones de la línea:
    - **Problema**: El número de segmentos usado para dibujar la waveform variaba según `splitT` (posición del click), causando diferente muestreo del buffer `voiceWaveforms[]` en cada click.
    - **Solución**: Mantener siempre el mismo número de segmentos fijo (72 para object-to-center, 64 para module-to-module), independientemente de la longitud de la línea dibujada.
    - Esto garantiza que se muestree siempre la misma porción del buffer de waveform, mostrando un patrón consistente de la forma de onda sin importar dónde se haga click en la línea.

### Corrección de estiramiento de formas de onda según distancia
- Ajustado el render de formas de onda en `MainComponent_Paint.cpp` para que la muestra de audio utilizada en las líneas dependa de la **distancia en píxeles** y no de la longitud normalizada de la línea.
- `drawWaveformOnLine` ahora mapea un desplazamiento a lo largo de la línea (en píxeles) a la ventana de samples usando un factor fijo de "muestras por píxel" (con wrapping en el buffer), manteniendo así un patrón visual consistente (por ejemplo, el diente de sierra) aunque cambie la distancia entre un módulo y el Master o entre dos módulos conectados.
- `drawWaveformOnQuadratic` sigue el mismo principio utilizando una longitud aproximada de la curva (distancia entre extremos) para definir el avance por el buffer, de modo que las conexiones curvadas también conservan el mismo patrón de onda al mover los módulos.
- Este cambio elimina el efecto observado de formas de onda "comprimidas" cerca del centro y "estiradas" cuando los nodos se alejan, ya que la frecuencia espacial de la onda en pantalla pasa a ser estable e independiente de la longitud de la conexión.
 - Se ha incrementado la resolución del snapshot usado para visualización de cada voz de `128` a `512` samples (`kWaveformPoints`), mejorando la definición del patrón (especialmente en saw) a la vez que se sigue usando solo un ciclo estimado para repetir la forma a lo largo de líneas largas.
