## 2025-12-10

### Icono de AppImage y asociación con GNOME
- Se ha ajustado el empaquetado AppImage en el [Earthfile](Earthfile) para que el `AppDir` cumpla la convención de iconos descrita en la documentación de AppImage. En el target `appimage` el logo principal `resources/reactable-logo.png` se copia ahora como [AppDir/usr/share/icons/hicolor/256x256/apps/soundtable.png](AppDir/usr/share/icons/hicolor/256x256/apps/soundtable.png) y se crean dos symlinks en la raíz del AppDir: [AppDir/soundtable.png](AppDir/soundtable.png) y [AppDir/.DirIcon](AppDir/.DirIcon) apuntando a ese archivo. De esta forma `appimagetool` y los entornos de escritorio pueden detectar el icono de la aplicación directamente a partir del AppImage.
- El archivo `.desktop` interno generado en [AppDir/usr/share/applications/soundtable.desktop](AppDir/usr/share/applications/soundtable.desktop) se ha actualizado para que la clave `Icon` use el mismo nombre base (`Icon=soundtable`) y se ha añadido `StartupWMClass=RectaiTable`, alineándolo con el nombre de aplicación que devuelve `RectaiApplication::getApplicationName()`. Esto facilita que GNOME asocie correctamente la ventana JUCE con la entrada `.desktop` y muestre el logo en el dock/overview en lugar del icono genérico de engranaje.
- Tras observar que `linuxdeploy` emitía el error `Icon /AppDir/usr/share/icons/hicolor/256x256/apps/RectaiTable.png has invalid x resolution: 283`, se ha incorporado ImageMagick en el target `appimage` del [Earthfile](Earthfile) y se llama a `convert` para redimensionar el logo a un PNG cuadrado de 256×256 píxeles antes de registrarlo como icono del tema hicolor. Concretamente, después de copiar `resources/reactable-logo.png` se ejecuta `convert ... -resize 256x256^ -gravity center -extent 256x256 RectaiTable.png`, garantizando que el archivo bajo `hicolor/256x256/apps` cumple el tamaño esperado por el tema de iconos y por `linuxdeploy`, eliminando así el warning y permitiendo que el icono se use correctamente en el AppImage.

### AudioModules y metadata unificada
- `soundtable::Scene` ahora almacena instancias polimórficas de `AudioModule`, cada una con:
  - `ModuleType` (SEQUENCER, AUDIO, GENERATOR, FILTER, SETTINGS) para clasificar familias lógicas.
  - Capacidades de audio (`produces_audio`, `consumes_audio`) y políticas de conexión overrideables por módulo.
  - Metadatos UI (`colour_argb`, `label`, `description`, `icon_id`) más flags para reutilizar los sliders de frecuencia y ganancia según convenga.
- Nuevos módulos concretos:
  - `OscillatorModule`: generador con salida audio, sliders de freq/gain activos, color azul y conexión permitida hacia módulos FILTER/AUDIO.
  - `FilterModule`: módulo de paso con entrada/salida audio, sliders de cutoff/gain activos y política de conexión abierta.
- `MainComponent` consume ahora esta metadata para:
  - Pintar colores/aura basados en el color declarado por cada `AudioModule`.
  - Mostrar u ocultar los sliders laterales en función de `uses_frequency_control` / `uses_gain_control`.
  - Renderizar iconos mediante `icon_id` y etiquetar cada nodo con `label (logical_id)`.
  - Consultar valores por defecto de parámetros (`freq`, `gain`, etc.) a través de `AudioModule::default_parameter_value`, de modo que los `0.5F` por defecto viven en `AudioModules.cpp` en lugar de estar duplicados en `MainComponent`.
- `tests/scene_tests.cpp` se actualiza para instanciar módulos concretos (`OscillatorModule`, `FilterModule`) usando `std::unique_ptr`, reflejando la API `Scene::AddModule(std::unique_ptr<AudioModule>)`.
- Nueva cabecera `core/src/core/AudioModules.{h,cpp}` centraliza las implementaciones concretas para que puedan reutilizarse tanto por la UI como por futuros motores de audio.

### Refinado de interfaz visual según `ui-interface.md`
- Fondo y núcleo central:
  - Se mantiene el lienzo circular azul con gradiente y viñeta, actuando como superficie principal de la mesa reactiva.
  - El núcleo central incorpora ahora ondas expansivas más rítmicas y se usa como punto de convergencia visual de las conexiones.
- Nodos/objetos tangibles:
  - Cada `ObjectInstance` toma su color base del metadato `colour_argb()` expuesto por el `AudioModule` asociado (oscillator, filter, effect, sampler, controller), manteniendo la paleta de azules, verdes, púrpuras y naranjas para diferenciar tipos.
  - El aura bajo cada nodo está tintada con el color del módulo y se dibujan dos halos concéntricos suaves, aproximando el efecto de glow/bloom descrito en `ui-interface.md`.
  - Dentro del cuerpo del nodo se renderizan iconos estilizados según el tipo de módulo (onda sinusoidal para osciladores, curva tipo filtro, barras estilo sampler, anillos para controladores, etc.).
- Anillos de parámetros:
  - Se ha sustituido el único arco de parámetro por dos anillos concéntricos: uno interior que representa un valor derivado de la posición X del objeto y otro exterior que actúa como barra de progreso circular ligada a la fase de tempo global.
  - Ambos anillos se orientan usando la rotación (`angle_radians`) del objeto, de forma que los parámetros “siguen” la orientación física del tangible sobre la mesa.
- Conexiones y flujo de señal:
  - Las conexiones entre módulos (`Scene::connections`) se dibujan como curvas de Bézier suaves.
  - Se añade un pequeño pulso luminoso que recorre cada conexión con un desfase por índice, simulando el flujo de audio entre módulos además de las líneas centro→objeto que ya existían.
- Widgets especiales:
  - El widget de secuenciador (grid de puntos) se posiciona ahora utilizando la rotación del objeto cuya `logical_id` empieza por `"seq"`, proyectando la cuadrícula hacia la dirección del cubo físico.
  - Se mantiene el menú radial de parámetros alrededor del objeto seleccionado, alineado con la estética de menús radiales flotantes descrita en `ui-interface.md`.

### Flujo de señal por sectores y mute por instrumento
- Conexiones espaciales entre instrumentos por sectores:
  - La heurística `isConnectionGeometricallyActive` ahora divide el área musical en cuatro sectores angulares alrededor del centro (90º cada uno en coordenadas normalizadas de la mesa).
  - Dos instrumentos se consideran conectados (p.ej. `osc1 → filter1`) solo si ambos caen en el mismo sector; en ese caso se dibuja la línea curvada entre ellos con su pulso animado.
- Rutas hacia Master y líneas individuales:
  - Cada instrumento mantiene siempre su línea directa `instrumento → Master`, independientemente de si está conectado a otro. Esto permite que cada fiducial tenga un control de mute propio, visible y clickable en todo momento.
- Mute independiente pero con efecto en la cadena de audio:
  - Cada instrumento gestiona su propio estado de mute (click sobre su línea al centro), de forma independiente de las conexiones activas.
  - En el caso `osc1`/`filter1`, cuando hay conexión activa en el mismo sector, el audio que se oye sigue siendo la cadena oscilador→filtro→Master, pero si cualquiera de los dos instrumentos está en estado mute, la salida conjunta se silencia.
  - Cuando no hay conexión activa por sector, solo el mute del oscilador afecta al audio generado (el filtro no forma parte de la ruta audible en ese caso, aunque su estado de mute se conserve para cuando vuelva a entrar en cadena).

### Ajuste de conexiones según área de música
- Las conexiones visuales `instrumento → instrumento` (curvas con pulso) solo se consideran activas y se dibujan cuando **ambos** instrumentos están dentro del círculo de música y el destino cae dentro de un cono desde el centro en dirección al origen (inicialmente 90º, ampliado posteriormente a 120º).
- Si cualquiera de los dos objetos sale fuera del área de música, la conexión desaparece visualmente y deja de participar en el routing lógico:
  - En el caso `osc1 → filter1`, si el filtro queda fuera del círculo, la cadena osc→filtro se considera no válida y el audio se silencia para evitar una ruta incoherente hacia el Master.
- El hit-test para mutear conexiones entre instrumentos también respeta esta regla: solo se puede mutear una conexión clicando sobre ella si ambos instrumentos están dentro del área de música.

### Ajuste del ángulo del cono de conexión
- Se ha reajustado el cono geométrico de conexión entre instrumentos para que `isConnectionGeometricallyActive` utilice ahora un ángulo total de 120º alrededor del origen (60º de semicono). Esto mantiene la idea de sectores angulares alrededor del centro y ofrece una tolerancia algo más amplia, de modo que cuando dos módulos están razonablemente alineados dentro de ese cono se considera que la conexión dinámica está activa.

### Forma de las conexiones dinámicas en la UI
- Las conexiones entre módulos (`Scene::connections`) que no son hardlink (conexiones dinámicas) se renderizan ahora como segmentos rectos en lugar de curvas de Bézier. El pulso animado que recorre la conexión se mueve linealmente desde el módulo de origen al de destino, y la visualización de waveform también se dibuja sobre la línea recta (`drawWaveformOnLine`), lo que hace que la geometría de las conexiones dinámicas coincida mejor con la expectativa visual de "línea directa" entre módulos cercanos.

### Creación automática de conexiones dinámicas por disposición espacial
- En `MainComponent::timerCallback` se ha añadido una pasada de mantenimiento que recorre los pares de objetos dentro del área musical y, para cada par de módulos compatibles según `AudioModule::CanConnectTo`, crea automáticamente una conexión dinámica (`Connection` con `is_hardlink = false`) desde el módulo origen al destino cuando el objeto destino cae dentro del cono geométrico de 105º definido por `isConnectionGeometricallyActive`.
- Estas conexiones automáticas utilizan siempre los puertos estándar `out → in` y solo se crean cuando no existe ya ninguna conexión entre ese par de módulos, de modo que no interfieren con hardlinks existentes ni con conexiones explícitas que se puedan definir en el futuro.

### Alineación del área de música con la UI
- La función de utilidad `isInsideMusicArea` se ha movido a `MainComponent` y ahora calcula el área musical en coordenadas de píxel usando exactamente el mismo centro y radio que el círculo de la mesa renderizado en `paint`.
- Esto garantiza que un instrumento se desactive justo cuando su nodo sale visualmente del círculo azul (zona con fondo negro), independientemente de la relación de aspecto de la ventana.

### Próximos pasos sugeridos (UI)
- Introducir un efecto de glow/bloom real mediante un pipeline de renderizado con OpenGL o similar, en lugar de aproximarlo solo con halos y transparencias.
- Experimentar con blending aditivo global para que las intersecciones de líneas y halos incrementen el brillo de forma más marcada.
- Hacer que algunos parámetros visuales (arcos, intensidad de auras, velocidad de pulsos) respondan a métricas de audio reales en `AudioEngine` (niveles RMS, envolventes, etc.).
