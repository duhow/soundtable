## 2025-12-12
 - Ajustado el runtime del Sequencer para avanzar un paso por beat global y no por subdivisión continua, de modo que la demo de escala suene claramente a tiempo.
 - Introducido flag `sequencerControlsVolume_` en `MainComponent` para permitir experimentalmente que el Sequencer module el volumen (velocidad/gain) de módulos destino; valor por defecto `false` para no interferir con volumen que pueda venir por MIDI u otras fuentes.
 - Alineada la lógica de hit-testing de líneas a Master en `MainComponent_Input` con el pintado en `MainComponent_Paint`: solo módulos que producen/consumen audio tienen línea (y click) hacia Master, evitando que `Sequencer` (solo MIDI) tenga una línea invisible que pueda silenciarse por accidente.
 - Extendida la lógica de gesto de corte en `mouseDrag` para que también sólo considere líneas objeto->centro de módulos de audio, de nuevo excluyendo `Sequencer` y otros módulos sólo MIDI/control de los cortes que mutearían por accidente.
  - Primero pide a `SampleplaySynth::render` que escriba el audio de todos los Sampleplay activos en los buffers izquierdo/derecho.
  - Luego genera como antes las voces procedurales (osciladores/ruido) y suma su mezcla mono (`oscMixed`) sobre el contenido de FluidSynth, aplicando limitación suave por canal y escribiendo una salida estéreo (`leftOut`, `rightOut`) a los canales de dispositivo, manteniendo el buffer de historia `waveformBuffer_` basado en el canal izquierdo mezclado.
  - Se han añadido métodos públicos `setSampleplaySoundfont(const std::string&)` (para cargar el `.sf2` en el motor) y `triggerSampleplayNote(int bank, int program, int midiKey, float velocity01)` (para lanzar notas desde la capa de UI/escena).
- En `MainComponent.cpp`, el lambda `loadSampleplaySoundfonts` vuelve a recorrer los `SampleplayModule` de la escena y, tras validar el SF2 con `SampleplayModule::LoadSoundfont` y reconstruir la lista de instrumentos desde `EnumerateSoundfontPresets`, informa al `AudioEngine` de la ruta definitiva del primer soundfont válido encontrado llamando a `audioEngine_.setSampleplaySoundfont(sampleModule->soundfont_path())`. De este modo, el motor de audio y el modelo de dominio comparten el mismo archivo SoundFont cargado desde `com.reactable/Soundfonts`.
- En `MainComponent_Audio.cpp` se ha introducido el método privado `MainComponent::triggerSampleplayNotesOnBeat(bool strongBeat)`, invocado desde `timerCallback` cada vez que `beatPhase_` cruza el límite de un nuevo beat. Este método:
  - Calcula de nuevo el volumen global (mapeo dB desde el parámetro `volume` del `VolumeModule`).
  - Recorre todos los objetos `Sampleplay` dentro del área musical que no estén muteados.
  - Para cada módulo toma el instrumento activo (`SampleInstrument` con `bank` y `program` desde el SF2), deriva una nota MIDI desde el parámetro `midifreq` (redondeando a entero) y calcula una `velocity` normalizada en función de `amp`, `base_level`, `level_range` y el volumen global, con un ligero refuerzo en los beats fuertes (`strongBeat`).
  - Llama a `audioEngine_.triggerSampleplayNote(bank, program, midiKey, velocity01)` para disparar la nota correspondiente en FluidSynth, y marca el id del módulo en `modulesWithActiveAudio_` para que la capa de pintura pueda seguir resaltando sus conexiones como “activas”.

### Ajuste de mute master y rendimiento de audio
- Se ha desacoplado el estado visual de mute del master (`masterMuted_`, derivado del tangible `Output` con atributo `muted`) de la ruta real de audio en `MainComponent_Audio.cpp`. Antes, si el patch `.rtp` marcaba el Output como muteado, tanto los osciladores como el audio de Sampleplay quedaban silenciados completamente, lo que hacía que escenas que venían con el master en `muted=1` no reprodujeran nada aunque el resto de módulos estuvieran activos.
- La ganancia global de Sampleplay (`sampleplayOutputGain`) ahora solo depende del volumen global y de la presencia de al menos un `SampleplayModule` no muteado dentro del área musical; el flag `masterMuted_` ya no fuerza `sampleplayOutputGain = 0`. El mute del master sigue afectando únicamente a la representación visual del nodo central (alpha de color y pulsos), manteniendo compatibilidad con patches antiguos sin introducir silencios inesperados.
- De forma análoga, el cálculo del nivel por voz para generadores (`OscillatorModule` y similares) ya no incluye `masterMuted_` en la condición que fuerza `outputLevel = 0.0F`; solo se considera el estado de mute de la cadena (módulo fuente, módulo destino y conexión) y el “hold” temporal introducido por los gestos de click-and-hold sobre líneas. Esto garantiza que el audio de los generadores no desaparezca simplemente porque el Output tangible venga marcado como muteado en el patch.
- Se han eliminado los logs de depuración de filtros en `MainComponent_Audio.cpp` que se emitían en builds de depuración (`!NDEBUG`) para cada cadena `Oscillator → Filter` en cada tick del `timerCallback`. Estos logs resultaban útiles para diagnosticar el cutoff/Q del filtro, pero generaban un volumen de salida elevado que degradaba notablemente el rendimiento en builds de desarrollo; al retirarlos, el bucle de audio vuelve a ejecutarse sin coste extra de logging.
- La lógica provisional anterior de Sampleplay en `MainComponent_Audio.cpp` que generaba un tono senoidal simple sincronizado al tempo (gate de `beatPhase_ < 0.25` y uso de voces del `AudioEngine`) se ha eliminado: ahora el audio de Sampleplay proviene exclusivamente del motor de SoundFont (FluidSynth) y ya no ocupa voces procedurales del oscilador. La UI de Sampleplay (título de instrumento, click derecho para ciclar instrumentos) se mantiene sin cambios.

### Módulo Sampleplay: instrumentos, SoundFont y tono básico al tempo
- `SampleplayModule` en `core/src/core/AudioModules.{h,cpp}` ahora mantiene una lista de instrumentos (`SampleInstrument`) con un índice de instrumento activo (`active_instrument_index_`), incluyendo helpers para obtener el instrumento actual (`active_instrument()`), fijar el índice y ciclarlo (`CycleInstrument()`), de forma que la UI pueda mostrar y cambiar el instrumento seleccionado.
- El loader de patches Reactable `.rtp` en `core/src/core/ReactableRtpLoader.cpp` captura el atributo `filename` de los tangibles `Sampleplay`, lo almacena en el módulo mediante `set_raw_soundfont_name`, omite este atributo de la conversión numérica genérica y selecciona por defecto el primer `<instrument>` como instrumento activo cuando exista.
- En `MainComponent.cpp` se añade una pasada posterior a la carga de la escena (`loadSampleplaySoundfonts`) que recorre todos los `SampleplayModule` y resuelve su SoundFont2 usando `rectai::ui::loadFile("Soundfonts/<filename>")`. Para cada módulo encontrado intenta cargar el archivo con `SampleplayModule::LoadSoundfont`, validando el encabezado SF2 y dejando trazas de log en caso de error o ausencia de fichero.
- `MainComponent_Paint.cpp` dibuja ahora, a la derecha de cada nodo `Sampleplay`, el nombre del instrumento activo (texto alineado a la izquierda) respetando la rotación del módulo dentro del área musical, de modo que el título acompaña visualmente al cubo y refleja siempre el instrumento seleccionado.
- `MainComponent_Input.cpp` extiende el manejo de click derecho sobre módulos: además de ciclar la forma de onda de `OscillatorModule` y el modo de `FilterModule`, un click derecho sobre un `SampleplayModule` llama a `CycleInstrument()`, alternando entre los instrumentos declarados en el patch y provocando que el título mostrado junto al módulo se actualice inmediatamente.
- En `MainComponent_Audio.cpp` se integra un comportamiento provisional de audio para `Sampleplay`: cada Sampleplay presente en el área musical genera un tono senoidal simple sincronizado con el tempo global (una nota por beat). La altura se deriva del parámetro `midifreq` (conversión MIDI→Hz) y el nivel del parámetro `amp`, escalado por la curva de volumen global. El tono sólo suena durante el primer cuarto de cada beat (ventana de `beatPhase_ < 0.25`), de modo que, por defecto, el módulo Sampleplay produce ya un patrón rítmico básico ligado al BPM sin requerir un motor de reproducción de SoundFont completo.

### Mejora de visibilidad de la base circular de los módulos
- En `MainComponent_Paint.cpp` se ha añadido un contorno explícito de alto contraste alrededor del cuerpo circular de cada módulo, tanto en la mesa como en el dock, de forma que la “redonda” bajo cada módulo sea claramente visible incluso cuando el color de relleno está muy próximo al fondo.
- El color del contorno se elige dinámicamente en función del brillo del módulo (blanco sobre módulos oscuros, negro sobre módulos claros), manteniendo la legibilidad de la silueta sin interferir con la paleta de colores cargada desde los patches `.rtp`.
 - Además, el color de relleno del nodo se fuerza a ser completamente opaco (`alpha = 1.0`) en la función `getBodyColourForObject`, de modo que aunque algún color ARGB procedente del `.rtp` lleve un canal alpha bajo, la base circular siempre se renderiza como un disco sólido y coloreado.

### Color por defecto unificado y simplificación de nodos
- En `ReactableRtpLoader.cpp`, cuando un `<tangible>` no declara explícitamente un atributo `color`, el loader ya no conserva el color por defecto definido en el constructor del módulo, sino que sobrescribe el color visual con un valor unificado oscuro `#111111` (`0xFF111111`). Esto garantiza que todos los módulos sin color definido en el `.rtp` comparten una base visual coherente y claramente diferenciable de los módulos coloreados (loops, sampleplays, oscillators, etc.).
- En `MainComponent_Paint.cpp` se han eliminado los dos círculos adicionales de “aura” bajo cada módulo, tanto en la mesa como en el dock; ahora solo se dibuja el círculo principal del módulo (más su contorno), simplificando la lectura visual y acercando el diseño a la representación más plana que estamos buscando para depurar la paleta de colores.

### Corrección de conversión ARGB → `juce::Colour`
- Corregida la función `colourFromArgb` en `MainComponentHelpers.cpp`: antes construía `juce::Colour` pasando los cuatro componentes como si el constructor fuera `(alpha, red, green, blue)`, cuando en realidad el constructor de 4 parámetros espera `(red, green, blue, alpha)`. Esto provocaba un corrimiento de canales y que muchos colores se vieran rojizos/blanquecinos.
- La función ahora extrae los componentes ARGB y usa explícitamente `juce::Colour::fromARGB(alpha, red, green, blue)`, de forma que los colores procedentes de `colour_argb()` (incluidos los `color="..."` del `.rtp`) se respetan exactamente en la UI.
### Opacidad diferenciada para pulsos de tempo
- Ajustado el render de los anillos de pulso en `MainComponent_Paint.cpp` para que los pulsos secundarios de tempo (beats intermedios) se dibujen con menor opacidad que el pulso que marca el beat principal del compás.
- La estructura `Pulse` sigue marcando los beats fuertes con `strong = true` cada 4 golpes (`beatIndex_`), pero ahora el cálculo de alpha distingue entre ambos: el pulso principal mantiene la opacidad base dependiente de la edad del pulso y del estado de mute del master, mientras que los pulsos secundarios escalan esa opacidad por un factor adicional (≈40%).
- Este cambio hace que el ritmo siga siendo claramente visible, pero refuerza visualmente el beat fuerte del compás como referencia rítmica principal, alineando la jerarquía de brillo con el diseño descrito para la UI rítmica de la mesa.

### Fondo de mesa sólido y borde difuminado
- Actualizado el fondo de la mesa en `MainComponent_Paint.cpp` para que el disco principal se pinte con un color sólido `#001a80` (sin gradiente interno), alineado con la paleta azul oscura descrita para la superficie de la mesa.
- Introducido un anillo exterior alrededor de la mesa que se renderiza como una elipse con gradiente radial desde `#001a80` en el borde de la mesa hasta negro en el radio exterior, creando un difuminado suave entre la superficie y el fondo negro general.
- Eliminada la viñeta anterior basada en un simple trazo negro grueso alrededor del círculo y sustituida por este borde degradado, que integra mejor la mesa con el lienzo negro sin añadir contornos duros.

### Indicador visual de fallo de audio en la inicialización
- Se ha extendido `AudioEngine` en `core/src/AudioEngine.{h,cpp}` para detectar de forma genérica cualquier error que devuelva JUCE al inicializar el dispositivo de audio por defecto mediante `initialiseWithDefaultDevices(0, 2)`. Si la cadena de error no está vacía, se marca un flag interno `initError_` que indica que la inicialización de audio no ha sido satisfactoria (falta de backend, dispositivo inválido, ausencia de canales, etc.).
- Para mantener información más detallada cuando está disponible, se conserva también el flag específico `noOutputChannels_`, que se activa si el mensaje de error contiene la cadena `"no channels"`, de forma que futuras capas puedan distinguir este caso concreto si lo necesitan.
- Se han añadido dos getters ligeros en `AudioEngine`: `hasInitialisationError()` (estado genérico de fallo en la inicialización) y `hasNoOutputChannels()` (caso particular de ausencia de canales). La UI solo depende del primero para decidir el color de la mesa.
- En `MainComponent_Paint.cpp`, el color de la mesa ya no es fijo: si `audioEngine_.hasInitialisationError()` devuelve `true`, el disco principal de la mesa se pinta en rojo oscuro `#801a1a`; en caso contrario, mantiene el azul `#001a80` definido previamente. El anillo degradado exterior sigue utilizando como color interior el color actual de la mesa, de modo que el borde se adapta automáticamente al estado de audio.
- El mensaje de log existente `[rectai-core] Failed to initialise audio: ...` se conserva tal cual, pero ahora **cualquier** error de inicialización se refleja también visualmente en la UI a través del cambio de color de la mesa, facilitando detectar de un vistazo que la aplicación está corriendo sin un dispositivo de audio operativo o en un estado de audio degradado.

### Separación de gestos: sliders de módulo vs corte de líneas
- Introducido un flag explícito `isCutModeActive_` en `MainComponent` que distingue entre el modo de **interacción** (cursor blanco) y el modo de **corte de sonido** (cursor rojo con trail).
- `MainComponent::mouseDown` ahora solo activa `isCutModeActive_ = true` cuando el click comienza en espacio vacío del área musical (dentro del círculo de música, fuera del dock y sin haber capturado ni un módulo, ni un slider lateral, ni una línea para mute hold); en cualquier otra interacción el gesto permanece en modo blanco.
- `MainComponent::mouseDrag` condiciona la detección de cortes de líneas (`touchCutObjects_` y `touchCutConnections_`) a que `isCutModeActive_` sea verdadero y, además, a que no se esté arrastrando un módulo (`draggedObjectId_ == 0`), ajustando sliders (`sideControlKind_ == kNone`) ni manteniendo una línea en mute temporal (`!activeConnectionHold_`).
- `MainComponent::paint` usa ahora este flag para dibujar el cursor en blanco en todos los gestos de interacción (ajuste de frecuencia/ganancia, click-and-hold sobre líneas) y en rojo solo en gestos de corte iniciados en espacio vacío. Al arrastrar módulos sobre la mesa el cursor se oculta; en el caso de módulos sacados desde el dock, el cursor solo es visible mientras el puntero permanece dentro del propio dock.
- El hit-test de las barras laterales de frecuencia/ganancia se ha ampliado: ahora un click en **cualquier punto de la barra** mueve inmediatamente el valor del parámetro hasta esa posición y comienza un gesto de drag desde ahí, en lugar de requerir que el usuario acierte específicamente sobre el handle.

### Drop seguro con CONTROL para Loop/Oscillator/Sampleplay
- En `MainComponent_Input.cpp` se ha añadido la función auxiliar privada `applyControlDropMuteIfNeeded`, ahora invocada desde `mouseDrag` justo después de actualizar la posición del objeto arrastrado.
- Cuando, durante un drag con la tecla CONTROL pulsada, el objeto está sobre la mesa (posición actual en el área musical) y el módulo asociado es de tipo `OscillatorModule`, `LoopModule` o `SampleplayModule`, la función fuerza el parámetro de nivel correspondiente a 0: `gain = 0.0` para osciladores y `amp = 0.0` para loops y sampleplays.
- De este modo, el silencio se aplica en cuanto el módulo entra o se mueve dentro del área musical mientras se mantiene CONTROL, sin esperar al `mouseUp`, proporcionando una forma rápida de “colocar en silencio” estos módulos al situarlos en la mesa y permitiendo luego subir el nivel desde los controles laterales de ganancia.

### Mapeo de ganancia con verdadero 0% de volumen
- En `MainComponent_Audio.cpp` se ha ajustado el cálculo de `calculatedLevel` para que un parámetro de ganancia normalizado igual a `0.0` produzca un nivel efectivo de `0.0` (silencio real), en lugar de mantener siempre un mínimo basado en `base_level_`.
- El mapeo pasa de `calculatedLevel = base_level + level_range * gainParam` a una versión que devuelve 0 cuando `gainParam <= 0.0` y solo aplica el offset `base_level` para valores de ganancia mayores que 0, de forma que poner el slider de ganancia al mínimo realmente apaga el oscilador en audio (aunque se siga generando la forma de onda interna para visualización).
