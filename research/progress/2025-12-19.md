## 2025-12-19

### Envío de bundles OSC por frame en soundtable-tracker
- Se ha refactorizado el emisor OSC ligero del tracker en [tracker/src/OscSender.{h,cpp}](tracker/src/OscSender.h) para separar la construcción de mensajes OSC de su envío efectivo. La clase `OscSender` expone ahora un alias `Message` (basado en `std::string`) y una serie de helpers `build*` que devuelven el buffer OSC ya codificado para cada tipo de mensaje que utiliza el tracker: `/soundtable/object`, `/soundtable/remove`, los tres mensajes TUIO 2Dobj (`set`, `alive`, `fseq`) y el anuncio `/tuio/hello`. Estos constructores reutilizan los helpers internos `appendPaddedString`, `appendInt32` y `appendFloat32` para garantizar que el empaquetado sigue siendo conforme a la especificación OSC y compatible con el receptor de JUCE.
- Sobre estos helpers se han añadido dos primitivas de envío genéricas en `OscSender`: `bool send(const Message& message)` y `bool sendBundle(const std::vector<Message>& messages)`. La primera envía un único buffer OSC plano sobre el socket UDP ya conectado, mientras que la segunda codifica un bundle estándar: escribe la cabecera `"#bundle"` con padding a 8 bytes, un timetag de 8 bytes (se fija a 0, que los receptores interpretan como "inmediato"), y a continuación, para cada mensaje, un entero de 32 bits en orden de red con el tamaño seguido del contenido del mensaje tal cual. Cuando el vector de mensajes contiene exactamente un elemento, `sendBundle` cae deliberadamente en `send()` para cumplir el requisito de no encapsular en bundle los casos de un único mensaje por frame.
- En el flujo de ejecución principal de `soundtable-tracker` ([tracker/src/main.cpp](tracker/src/main.cpp#L1-L260)), tanto en modo sintético como en modo en vivo se ha cambiado la forma en que se emiten los mensajes OSC por frame. En el caso TUIO 1.1 (`TuioOutputMode::Tuio11`), en lugar de llamar secuencialmente a `sendTuio2DobjAlive`, `sendTuio2DobjSet` (uno por cada objeto estable) y `sendTuio2DobjFseq`, el código construye ahora un vector de `OscSender::Message` que contiene, en ese orden, un mensaje `alive` con todos los `sessionId` activos, un mensaje `set` por cada objeto estable (incluyendo sus velocidades lineales y angulares calculadas a partir del último estado estable y el `dtSec` medido), y un último mensaje `fseq` con el contador de frame TUIO. Al finalizar el procesamiento de cada frame estable, se envía el grupo completo mediante `oscSender.sendBundle(messages)`, de modo que todos los mensajes TUIO viajan en un único datagrama UDP.
- Para el modo legado OSC propietario (`TuioOutputMode::LegacyOsc`), se ha aplicado el mismo patrón: por cada frame se construye un vector de mensajes que contiene un `/soundtable/object` por cada fiducial estable (incluyendo sus coordenadas normalizadas y ángulo en grados) y, a continuación, un `/soundtable/remove` por cada id que `trackerState.collectRemovals(15)` considere desaparecido desde hace suficientes frames. Si en un frame dado sólo hay un mensaje (por ejemplo, un único objeto o una única retirada), `sendBundle` detecta el tamaño 1 y envía el paquete como mensaje OSC plano; cuando hay varios objetos y/o removals, todos viajan agrupados en un único bundle. En modo sintético se ha introducido la misma lógica: el triplete TUIO (`alive`, `set`, `fseq`) se encapsula en un solo bundle y, en modo OSC propietario, el único `/soundtable/object` se envía a través de `sendBundle` que lo trata como mensaje único.
- Tras estos cambios se han ejecutado de nuevo los tests del proyecto con `ctest` desde el directorio de build, confirmando que tanto los binarios principales (`soundtable-core`, `soundtable-tracker`) como los ejecutables de pruebas (`soundtable-core-tests`, `soundtable-tracker-tests`) siguen pasando sin errores. El receptor OSC/TUIO de `soundtable-core`, que ya soporta bundles anidados, puede ahora recibir en un solo datagrama todas las actualizaciones de un frame del tracker, reduciendo el overhead de red y de procesamiento de cabeceras OSC en escenarios con múltiples fiducials simultáneos.

### Importador de sesiones RTZ (.rtz) con soporte ZIP y extracción de Samples
- Se ha añadido un nuevo módulo de dominio `ReactableRtzLoader` en [core/src/core/ReactableRtzLoader.{h,cpp}](core/src/core/ReactableRtzLoader.h) que permite importar archivos `.rtz` (sesiones empaquetadas de Reactable) directamente en el modelo `Scene`. Los archivos `.rtz` se tratan como archivos ZIP que deben contener en la raíz exactamente un archivo `.rtp` (sesión XML) y, opcionalmente, una carpeta cuyo nombre coincide con el basename de ese `.rtp` (por ejemplo, `Loopdemo/` para `Loopdemo.rtp`) con Samples de audio.
- `ReactableRtzLoader` valida primero que la ruta recibida apunta a un archivo ZIP (comprueba la cabecera `PK` leyendo los primeros bytes y delega después en `libzip` para la apertura y el listado de entradas). A continuación recorre las entradas de la raíz del ZIP y exige que exista un único archivo con extensión `.rtp`; si encuentra más de uno, o ninguno, el importador devuelve error con un mensaje descriptivo.
- Durante la importación, el `.rtp` localizado en la raíz del ZIP se extrae siempre a la carpeta de sesiones canónica `com.reactable/Sessions/`, respetando el nombre de archivo original (`<com_reactable_root>/Sessions/<rtp_filename>`). La ruta base `com_reactable_root` se recibe como argumento y, en ausencia de valor, se asume `./com.reactable` como raíz relativa; el importador se asegura de crear los directorios necesarios mediante `std::filesystem::create_directories`.
- Si el ZIP contiene una carpeta cuyo nombre coincide con el basename del `.rtp` (por ejemplo, `Loopdemo/` dentro del archivo `Loopdemo.rtz`), todas las entradas bajo ese prefijo se extraen a `com.reactable/Samples/<basename>/...`, preservando la estructura relativa interna. Los archivos cuyo último componente de ruta empieza por punto (`.DS_Store`, archivos temporales ocultos, etc.) se descartan explícitamente y no se copian, de acuerdo con el esquema original de contenidos de Reactable.
- Al escribir cualquier archivo extraído (tanto el `.rtp` como los WAV de Samples), el importador compara primero el contenido con un posible archivo ya existente en disco: si el fichero de destino existe y es byte a byte idéntico al contenido del ZIP (mismo tamaño y comparación completa en bloques), no se sobrescribe. Si existe pero difiere, se sobrescribe con la versión del `.rtz`. Esta política cumple el requisito de “no sobrescribir si son idénticos” y sigue permitiendo actualizar sesiones o Samples cuando el contenido realmente cambia.
- Una vez completada la extracción, `ReactableRtzLoader` delega la validación de la sesión en el loader existente de `.rtp`: llama a `LoadReactablePatchFromFile` sobre la ruta final del archivo `.rtp` guardado en `com.reactable/Sessions/`, de forma que el modelo `Scene`, las conexiones y el `ReactablePatchMetadata` se rellenan reutilizando toda la lógica de parseo XML ya probada. Si el `.rtp` interno es inválido o no puede parsearse, el importador de `.rtz` devuelve error agregando el mensaje generado por el loader de `.rtp`.
- En CMake se ha integrado `libzip` como dependencia opcional de `soundtable-core-lib` en entornos UNIX a través de `pkg-config` (`pkg_check_modules(LIBZIP REQUIRED libzip)` en [core/CMakeLists.txt](core/CMakeLists.txt)), añadiendo sus includes y librerías a `soundtable-core-lib` y definiendo la macro de compilación `RECTAI_HAVE_LIBZIP` cuando está disponible. El propio `ReactableRtzLoader` compila la ruta principal de importación sólo cuando esta macro está definida; en caso contrario, expone un stub que informa de que el soporte RTZ no está disponible.
- Se han actualizado las dependencias de sistema en [DEPENDENCIES.md](DEPENDENCIES.md), el `Dockerfile` raíz y el `Earthfile` para instalar `libzip-dev` en las imágenes de build basadas en Ubuntu 22.04, garantizando que el loader `.rtz` está operativo tanto en el host como dentro de los contenedores usados por el proyecto.
- En la app principal JUCE (`MainComponent`), el lambda interno `loadPatchFromFile` ahora detecta la extensión del archivo de sesión: si es `.rtz` delega en `LoadReactableSessionFromRtz`, pasando como raíz de `com.reactable` el directorio derivado de `Resources/default.rtp` (si existe) o, en su defecto, `./com.reactable`. Para el resto de extensiones (incluida `.rtp`) se mantiene el camino previo vía `LoadReactablePatchFromFile`. El resto de lógica de inicialización tras la carga (color y mute del master, flags de mute por conexión, BPM global, carga de SoundFonts y loops, etc.) permanece idéntica y se aplica tanto a sesiones cargadas desde `.rtp` como importadas desde `.rtz`.

### Limpieza de metadatos específicos de macOS en RTZ
- El importador de sesiones RTZ en [core/src/core/ReactableRtzLoader.cpp](core/src/core/ReactableRtzLoader.cpp) ahora ignora explícitamente las entradas de carpeta `__MACOSX/` y los archivos de metadatos típicos de macOS (`.DS_Store` y `._.DS_Store`) tanto al escanear el contenido del ZIP en busca del `.rtp` principal como al extraer la carpeta de Samples asociada al basename del `.rtp`. Esto evita que los ficheros auxiliares generados por Finder se consideren candidatos a sesión o se copien a `com.reactable/Samples`, alineando el comportamiento del loader con la estructura real de contenidos de las sesiones Reactable.

### Metadata de autores y título en sesiones cargadas
- Se ha extendido el loader de patches RTP en [core/src/core/ReactableRtpLoader.cpp](core/src/core/ReactableRtpLoader.cpp) para que, además del esquema antiguo basado en atributos (`<author name="..." />`, `<patch name="..." />`), sea capaz de extraer la metadata de autor/es y título del esquema `reactablepatch` 0.2 que utiliza un bloque `<details>` anidado con `<authors><author>...</author></authors>` y `<title>...</title>`. El código recorre el contenido interno de `<authors>` y construye una cadena `author_name` uniendo todos los `<author>` no vacíos con `", "`, aplicando `Trim` a cada uno para eliminar espacios sobrantes; de forma análoga, extrae el texto de `<title>` y lo normaliza con `Trim` antes de asignarlo a `patch_name`.
- Tras esta ampliación, la estructura `ReactablePatchMetadata` sigue exponiendo los mismos campos (`author_name`, `patch_name`, color y mute del master), pero ahora se rellena correctamente tanto para sesiones antiguas como para patches 0.2 como `LoadedCubes.rtp`, donde el autor se declara como texto dentro de `<author>` y no como atributo. Si el esquema antiguo ya ha proporcionado un valor no vacío, la ruta de `<details>` actúa sólo como fallback y no lo sobreescribe.
- En el lambda `loadPatchFromFile` de `MainComponent` ([core/src/MainComponent.cpp](core/src/MainComponent.cpp)), justo después de aplicar el color y el estado de mute del master y antes de inicializar BPM y estados de mute por conexión, se registra ahora un log informativo con `juce::Logger::writeToLog`. El mensaje tiene el formato `"Loaded project: "` seguido, si existen, del autor/es y el título obtenidos de `ReactablePatchMetadata`, combinados como `"<autor1, autor2, ...> - <título>"` o utilizando sólo la parte disponible cuando uno de los dos campos está vacío. Tanto autores como título se recortan con `trim()` para evitar espacios sobrantes y soportar correctamente casos en los que los nodos `<author>` o `<title>` contenían únicamente espacios.
