## 2025-12-20

### Actualización de guía para agentes de IA
- Se ha revisado y condensado el documento `.github/copilot-instructions.md` para alinear las instrucciones de trabajo de agentes de IA con la arquitectura actual del proyecto: aplicación principal JUCE (`rectai-core`) en `core/`, servicio de tracking `rectai-tracker` en `tracker/`, y comunicación entre ambos vía OSC/TUIO (`tracker/src/OscSender.*` y `core/src/TrackingOscReceiver.*`).
- La nueva guía enfatiza los flujos de build y test reales (CMake + CTest, uso opcional de Earthly/Docker descritos en `README.md`), los patrones de dominio/escena (`core/src/core/Scene.{h,cpp}` y `MainComponent`) y las convenciones de C++20 sin extensiones (`rectai` como espacio de nombres principal).
- También se han documentado expectativas específicas para agentes de IA: leer primero la documentación de `research/`, seguir las decisiones tecnológicas fijadas en `research/tech_stack.md`, mantener sincronizados core y tracker al modificar el protocolo OSC/TUIO, y registrar futuros cambios significativos en este mismo archivo de progreso.

### Auto-detección de beats en LoopModule al cambiar de sample (iteración 2)
- Se ha refinado la implementación de **detección automática de beats** para los módulos `Loop` al cambiar de sample desde la pestaña **LoopFiles**, de forma que los loops compartidos entre varios módulos conserven un número de beats canónico por fichero y la barra de reproducción visual se mantenga siempre sincronizada con la longitud real usada por el motor de audio.
- En el motor de audio, `AudioEngine::loadLoopSampleFromFile` ([core/src/AudioEngine.cpp](core/src/AudioEngine.cpp#L1520-L1880)) mantiene la semántica anterior de que cualquier valor `beats <= 0` representa una petición de auto-detección, pero ahora sigue una **prioridad explícita** para decidir el número de beats efectivo (`effectiveBeats`) de un sample:
  1. Si el llamador pasa `beats > 0` (típicamente metadatos provenientes de un `.rtp`), el engine confía en ese valor, lo clampa a entero y lo almacena en una caché interna `loopSampleBeatsCache_` indexada por path absoluto. Esa caché permite reutilizar el mismo número de beats cuando el mismo fichero de audio se vuelve a cargar más adelante desde otro módulo o slot.
  2. Si `beats <= 0` pero `loopSampleBeatsCache_` ya contiene un valor positivo para ese path, el engine reutiliza directamente ese valor cacheado en lugar de recalcular nada. Esto cubre el caso típico en el que un loop declarado como 8 beats en un patch (p.ej. `pl_padloop1.wav`) se reutiliza desde otro módulo cuyo slot original tenía 4 beats: al haber cargado primero el patch, el fichero queda marcado canónicamente como “8 beats” y cualquier selección posterior del mismo sample desde LoopFiles hereda automáticamente ese valor.
  3. Si `beats <= 0` y no hay entrada en la caché, el engine estima los beats a partir de la duración del archivo y del BPM global de loops (`loopGlobalBpm_`), pero con una heurística mejorada que **favorece potencias de 2**:
     - Calcula `durationSeconds = numFrames / sourceSampleRate` y `rawBeats = durationSeconds * (bpm / 60.0)`.
     - Busca primero entre los candidatos `{1, 2, 4, 8, 16, 32, 64}` el que esté más cerca de `rawBeats` siempre que el error relativo `|candidate - rawBeats| / candidate` sea `<= 0.30`. Si encuentra un candidato válido, lo toma como estimación.
     - Si ninguno de esos candidatos pasa el filtro, hace `round(rawBeats)` y lo clampa al rango `[1, 64]` como fallback.
     - Cuando obtiene un valor válido, lo almacena también en `loopSampleBeatsCache_` para que futuras cargas del mismo fichero no dependan de pequeños cambios en BPM o en la duración estimada.
- El resultado de esta lógica se escribe siempre en `LoopSample::beats`, que es el campo utilizado por el callback de audio para: (a) alinear la posición de lectura (`readPositions`) con el contador global de beats al cambiar de slot, y (b) ajustar la velocidad de reproducción relativa al BPM (`step` escalado por la razón entre duración real del audio y duración deseada en beats). De este modo, tanto la sincronización de loops entre sí como el grado de pitch-shift quedan anclados al número de beats canónico por fichero.
- Para exponer este número de beats efectivo a la capa de UI, se ha añadido en `AudioEngine` la función `int getLoopSampleBeats(const std::string& moduleId, int slotIndex) const` ([core/src/AudioEngine.h](core/src/AudioEngine.h#L200-L230), [core/src/AudioEngine.cpp](core/src/AudioEngine.cpp#L1785-L1815)), que devuelve el valor actual de `LoopSample::beats` para un módulo y slot dados (o 0 si no existe módulo, slot o metadato válido). Esta API se utiliza exclusivamente desde el hilo de UI, igual que el resto de setters/getters de Loop, por lo que no introduce contención adicional en el callback de audio.

- En la capa de UI, `LoopFileBrowser` se ha extendido para recuperar y propagar este valor efectivo de beats al modelo de dominio:
  - Su constructor ([core/src/MainComponent_LoopFileBrowser.h](core/src/MainComponent_LoopFileBrowser.h#L30-L80), [core/src/MainComponent_LoopFileBrowser.cpp](core/src/MainComponent_LoopFileBrowser.cpp#L1-L40)) ahora recibe un callback extra `queryBeatsFn` de tipo `std::function<int(const std::string& moduleId, int slotIndex)>`, que en `MainComponent` se enlaza a `audioEngine_.getLoopSampleBeats`.
  - En `handleSelectionChanged`, al seleccionar una entrada de tipo fichero (`EntryKind::kFile`), el flujo es ahora:
    1. Actualizar `LoopDefinition::filename` con la ruta relativa al directorio `Samples/` y ajustar `state.selectedFile`.
    2. Llamar a `loadSampleFn_` con un valor centinela de beats `-1.0f` (`kAutoDetectBeats`) para forzar la ruta de auto-detección en el engine, exactamente como en la primera iteración.
    3. Si la carga tiene éxito (`ok == true`) y `queryBeatsFn_` está definido, invocar `queryBeatsFn_(moduleId, slotIndex)` y, si devuelve un valor positivo, escribirlo en `def.beats` para ese slot.
    4. Marcar el label de loop como activo (`markLabelActive_`) y solicitar un repintado.
  - De esta forma, el campo `LoopDefinition::beats` del módulo `Loop` se actualiza inmediatamente después de que el engine haya decidido el número de beats efectivo. Cualquier consumidor del modelo (incluida la barra de reproducción) pasa a ver el nuevo valor, en lugar de quedarse con el metadato original del `.rtp`.
- La barra de reproducción y su trail blanco, que se dibujan en `MainComponent::paint` ([core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L2740-L2920)), ya estaban basadas en `LoopDefinition::beats` del slot activo para calcular `beatsPerLoop` y la fase normalizada `phase01` a partir de `transportBeats_ + beatPhase_`. Gracias a la actualización anterior de `LoopDefinition::beats` desde `LoopFileBrowser`, la barra roja y su estela blanca pasan a reflejar **el mismo número de beats** que el motor de audio está usando internamente para temporizar el loop, incluso cuando el usuario sustituye el sample de un slot por otro con tempo o longitud distintos.
- Con este ajuste, se resuelven los casos en los que un mismo fichero de audio (por ejemplo, un padloop de 8 beats) se reutilizaba en varios módulos o slots con metadatos de beats distintos: el primero que lo carga desde un `.rtp` fija el número canónico (8), y cualquier cambio posterior de sample desde LoopFiles reutiliza ese mismo valor tanto en el audio (via `LoopSample::beats`) como en la UI (via `LoopDefinition::beats` actualizado), garantizando que la barra de reproducción y el audio se mueven en perfecta sincronía.

### Auto-detección de beats en LoopModule al cambiar de sample (iteración 1)
- Se ha añadido una primera implementación de **detección automática de beats** para los módulos `Loop` cuando el usuario cambia el sample desde la pestaña **LoopFiles** del panel de módulo, evitando que el audio se reproduzca demasiado rápido o demasiado lento al seleccionar archivos distintos a los descritos originalmente en la sesión `.rtp`.
- En el motor de audio, `AudioEngine::loadLoopSampleFromFile` ([core/src/AudioEngine.cpp](core/src/AudioEngine.cpp#L1485-L1585)) ahora interpreta cualquier valor de `beats <= 0` como una petición explícita de auto-detección. Tras decodificar el archivo de audio al formato interno (`LoopSharedBuffer` con `numFrames` y `sourceSampleRate`), calcula la **duración en segundos** del loop (`durationSeconds = numFrames / sourceSampleRate`) y lee el BPM global actual de loops desde el atómico `loopGlobalBpm_` configurado por `setLoopGlobalTempo`.
- A partir de estos datos, el engine estima un número entero de beats mediante la fórmula:
  - `rawBeats = durationSeconds * (bpm / 60.0)`
  - `estimated = round(rawBeats)`
  - El valor resultante se clampa al rango `[1, 64]` para evitar factores de tempo extremos en casos patológicos (archivos muy largos o BPMs mal configurados). Si la estimación cae fuera de ese rango o el BPM no es válido (`<= 0`), el engine conserva `beats` tal y como llega (típicamente 0) y la reproducción se comporta como antes (sin tempo-sync para ese loop).
- Esta estimación se asigna al campo `LoopSample::beats` usado por el callback de audio para sincronizar la reproducción de los loops con el transporte global. El código de mezcla de loops en [core/src/AudioEngine.cpp](core/src/AudioEngine.cpp#L780-L910 y core/src/AudioEngine.cpp#L1130-L1265) ya utilizaba `slot.beats` tanto para alinear la fase del playhead (en torno al contador de beats global `transportBeatsInternal_`) como para ajustar la velocidad de lectura (`step`) cuando hay BPM válido; con la nueva lógica, los samples sustituidos desde el browser de ficheros se comportan como si su metadato de beats hubiese sido recalculado para el BPM actual, minimizando el pitch-shift.
- En la capa de UI, `LoopFileBrowser::handleSelectionChanged` ([core/src/MainComponent_LoopFileBrowser.cpp](core/src/MainComponent_LoopFileBrowser.cpp#L260-L410)) deja de reenviar ciegamente `LoopDefinition::beats` al motor cuando el usuario elige un nuevo archivo para un slot activo. En su lugar, al seleccionar una entrada de tipo fichero (`EntryKind::kFile`) se actualiza `LoopDefinition::filename` y se invoca el callback `loadSampleFn_` con un **valor centinela** de beats `-1.0f`:
  - `constexpr float kAutoDetectBeats = -1.0F;`
  - `loadSampleFn_(moduleId, slotIndex, fullPath.toStdString(), kAutoDetectBeats, &error);`
  De este modo, el engine detecta automáticamente que debe ignorar el metadato anterior de beats de la sesión `.rtp` y recalcularlo a partir de la duración real del nuevo sample.
- El flujo de carga inicial de sesiones `.rtp` no se ve afectado: el lambda `loadLoopSamples` en [core/src/MainComponent.cpp](core/src/MainComponent.cpp#L633-L705) sigue pasando `loopDef.beats` tal y como viene del archivo de sesión cuando se cargan los loops declarados originalmente, de forma que las sesiones importadas mantienen exactamente el comportamiento de tempo/sección descrito por Reactable. La auto-detección sólo entra en juego para samples seleccionados manualmente desde el Loop File Browser (pestaña `LoopFiles`).
- Próximos pasos posibles relacionados con esta funcionalidad (no implementados aún):
  - Propagar el valor de beats estimado de vuelta al modelo de dominio (`LoopDefinition::beats`) para que la barra de reproducción roja de Loop en la UI utilice también el número de beats recalculado al pintar la órbita y su trail.
  - Exponer un pequeño overlay o tooltip en la pestaña LoopFiles que muestre el número de beats detectado y el BPM actual, facilitando al usuario entender por qué un loop concreto se sincroniza con una determinada duración.

### Bugfix: interacción de Loop File Browser sin bloquear gestos de mesa
- Se ha corregido un bug en la integración del navegador de ficheros de Loop (`LoopFileBrowser` + `TextScrollList`) dentro de `MainComponent` que hacía que, cuando había al menos un panel de módulo con la pestaña **LoopFiles** abierta, **cualquier** gesto de arrastre sobre la mesa se interpretara como scroll de la lista, bloqueando así otras interacciones (por ejemplo, cortar líneas de audio o arrastrar módulos) incluso aunque el ratón/touch no hubiese empezado dentro de la ventana de Loop.
- La causa era que el manejador genérico de drag en [core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp) recorría siempre los paneles visibles y, si encontraba uno con `activeTab == kLoopFiles`, calculaba sus `contentBounds` y llamaba a `TextScrollList::dragPointerTo(localY)` **sin comprobar si el gesto de drag se había iniciado dentro de ese panel** ni asociarlo a ningún estado de drag activo. El bloque terminaba con un `return`, de modo que, en la práctica, la mera presencia de un panel LoopFiles visible “secuestraba” todos los drags de la mesa.
- Para alinear el comportamiento con la pestaña **Envelope** (que sólo captura el drag mientras existe un `activeEnvelopeDrag_` iniciado en sus barras), se ha introducido un nuevo estado de drag específico de Loop en [core/src/MainComponent.h](core/src/MainComponent.h):
  - `struct ActiveLoopFilesDrag { std::string moduleId; };`
  - `std::optional<ActiveLoopFilesDrag> activeLoopFilesDrag_;`
  Este estado indica, de forma explícita, si hay un gesto de drag en curso sobre la lista de ficheros de un módulo Loop concreto.
- En `handlePointerDown` ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L640-L720)), cuando el hit-test del panel detecta que el click cae dentro del área de contenido de la pestaña LoopFiles, se sigue inicializando la interacción sobre la lista con `list->beginPointerAt(localY)`, pero ahora además se marca `activeLoopFilesDrag_ = ActiveLoopFilesDrag{panelState.moduleId}`. De este modo, sólo los gestos que realmente comienzan dentro del área LoopFiles quedan registrados como drags activos de la lista.
- En `handlePointerDrag` ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L1480-L1685)), el bloque que antes decía “Before line cutting, allow scrolling inside an open LoopFiles panel by dragging over its TextScrollList” se ha protegido con una comprobación explícita de estado:
  - Si `activeLoopFilesDrag_` **no** tiene valor, el código de scroll de LoopFiles se salta por completo y el drag pasa al resto de lógica (gestos de corte, arrastre de módulos, etc.), de forma que tener simplemente una ventana de LoopFiles abierta ya no captura el ratón.
  - Si `activeLoopFilesDrag_` tiene valor, se localiza exclusivamente el panel cuyo `moduleId` coincide con `activeLoopFilesDrag_->moduleId`, se recalculan `contentBounds` y se llama a `list->dragPointerTo(localY)` usando la misma transformación de rotación que en el hit-test de `handlePointerDown`. El bloque sigue haciendo `return` tras actualizar el scroll, pero sólo para ese módulo concreto y únicamente mientras dure el gesto iniciado dentro de la ventana LoopFiles.
- En `handlePointerUp` ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L2500-L2620)), la propagación del pointer-up hacia las listas de LoopFiles también se ha restringido al drag activo: en lugar de iterar incondicionalmente sobre todos los paneles visibles con `activeTab == kLoopFiles`, ahora se comprueba primero si `activeLoopFilesDrag_` tiene valor y, en caso afirmativo, se busca sólo el panel cuyo `moduleId` coincide con el almacenado. Si la última posición del puntero cae dentro de los `contentBounds` del panel tras aplicar la rotación, se llama a `list->endPointerAt(localY)` para que `TextScrollList` decida si debe tratar el gesto como click-to-select (mismo índice que en `beginPointerAt`). Tras este paso se hace `activeLoopFilesDrag_.reset()` para liberar el estado de drag y permitir que futuros gestos sobre la mesa no sean capturados por LoopFiles.
- Con estos cambios, el comportamiento deseado queda restaurado: **cuando la ventana de Loop File Browser está abierta**, el ratón y los gestos TUIO pueden seguir interactuando normalmente con el resto de la mesa (cortar líneas de sonido, arrastrar módulos, ajustar controles laterales, etc.), y sólo los drags que se inician explícitamente dentro del área LoopFiles se usan para desplazar la lista y seleccionar samples.

### Panel de módulo: clase genérica de lista con scroll de texto y nuevo tab de ficheros para Loop
- Se ha añadido una nueva clase de UI genérica `rectai::ui::TextScrollList` en [core/src/MainComponent_TextScroll.h](core/src/MainComponent_TextScroll.h) y [core/src/MainComponent_TextScroll.cpp](core/src/MainComponent_TextScroll.cpp), pensada como base para vistas tipo “lista vertical de texto con scroll” dentro de ventanas de detalle de módulo (por ejemplo, un selector de samples para el módulo Loop). La clase hereda de `juce::Component` y mantiene internamente un vector de elementos `Item` donde cada uno contiene un texto (`juce::String`) y un estilo asociado (`ItemStyle` con flags de negrita y color opcional). Por defecto, los textos se dibujan en blanco semiopaco y fuente de 13 pt sin negrita, pero los llamadores pueden proporcionar estilos por elemento para cambiar color y peso tipográfico.
- `TextScrollList` limita la vista a un número máximo configurable de filas visibles (por defecto 6), cumpliendo el requisito de mostrar hasta 6 elementos simultáneos en la ventana. Cada fila tiene una altura fija (`rowHeight_`, inicializada a 18 px) y el componente calcula un offset vertical de scroll `scrollOffset_` que se actualiza al recibir eventos de rueda del ratón (`mouseWheelMove`), con un paso de desplazamiento de 3 filas por tick de rueda. A partir de ese offset, el método `paint` dibuja únicamente las filas visibles, calculando el índice de primer elemento (`firstIndex`) y la fracción parcial (`firstOffset`) para posicionar correctamente las filas dentro del rectángulo del componente.
- `TextScrollList` limita la vista a un número máximo configurable de filas visibles (por defecto 6), cumpliendo el requisito de mostrar hasta 6 elementos simultáneos en la ventana. Cada fila tiene una altura fija (`rowHeight_`, inicializada a 18 px) y el componente calcula un offset vertical de scroll `scrollOffset_` que se actualiza al recibir eventos de rueda del ratón (`mouseWheelMove`), ahora siempre en pasos discretos de **dos filas por tick** (independientemente de la magnitud exacta de `deltaY`). A partir de ese offset, el método `paint` dibuja únicamente las filas visibles, calculando el índice de primer elemento (`firstIndex`) y la fracción parcial (`firstOffset`) para posicionar correctamente las filas dentro del rectángulo del componente.
- La selección de elementos se ha refinado para imitar un "click" completo en lugar de seleccionarse en `mouseDown`. En `mouseDown` se registra únicamente qué fila hay bajo el puntero (`pressedIndex_`) y se inicializa un gesto de drag de scroll almacenando la posición inicial del ratón y el `scrollOffset_`. Mientras el botón está pulsado, `mouseDrag` desplaza la ventana de la lista **en dirección inversa al movimiento vertical del puntero** (arrastrar hacia abajo desplaza el contenido hacia arriba, revelando filas anteriores; arrastrar hacia arriba desplaza el contenido hacia abajo, mostrando filas posteriores), y se permite continuar el gesto incluso sacando el ratón fuera del área visible del componente. En `mouseUp`, sólo si el puntero se libera sobre la misma fila que estaba bajo él en `mouseDown` se aplica la selección llamando a `setSelectedIndex` y disparando el callback `onSelectionChanged_`. Esto evita selecciones accidentales durante gestos de desplazamiento prolongado y respeta la semántica pedida de "seleccionar al soltar sobre el mismo elemento".
- La clase expone, además, métodos de conveniencia para gestión de datos (`setItems` con copia o move, `clearItems`, `getNumItems`, `getItem`), selección (`setSelectedIndex`, `getSelectedIndex`, `setOnSelectionChanged`) y comportamiento (`setMaxVisibleItems`, `getMaxVisibleItems`, `setRowHeight`, `getRowHeight`, `scrollToTop`, `scrollToBottom`). Con esto queda preparada para reutilizarse tanto en un futuro “file browser” de samples del módulo Loop como en otras vistas de configuración basadas en listas de texto, sin acoplarse a ningún tipo concreto de módulo.
- En [core/CMakeLists.txt](core/CMakeLists.txt) se han añadido los nuevos archivos `src/MainComponent_TextScroll.cpp` y `src/MainComponent_TextScroll.h` al `target_sources` de la aplicación JUCE principal `rectai-core`, de modo que la clase queda disponible para `MainComponent` y otros componentes de UI. La librería de dominio `rectai-core-lib` no se ve afectada, ya que `TextScrollList` es puramente de presentación y no forma parte del modelo de escena.
- Se ha extendido la estructura `MainComponent::ModulePanelState::Tab` en [core/src/MainComponent.h](core/src/MainComponent.h#L390-L410) para incluir un nuevo valor `kLoopFiles`, pensado específicamente para una futura pestaña de selección de ficheros/samples del módulo Loop. Hasta ahora solo existían dos pestañas (`kEnvelope` y `kSettings`); con este cambio el estado del panel puede distinguir explícitamente cuándo el usuario está en la vista de ficheros de Loop frente a las vistas de envolvente o ajustes generales.
- En el pintado del panel de detalle por módulo ([core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L2950-L3135)) se ha añadido un nuevo tab con icono `tab_file` para los módulos de tipo `LoopModule`. La lógica que calcula los tabs ahora distingue entre tres flags: `hasLoopFilesTab` (verdadero sólo para `LoopModule`), `hasEnvelopeTab` (módulos que heredan de `AudioModuleWithEnvelope`) y las pestañas comunes de Settings y Close. Cuando el módulo es un Loop, la tira inferior de pestañas muestra, en este orden, `tab_file` (Loop Files), `tab_envelope` (Envelope, si procede), `tab_settings` (Settings) y `close_button`; para otros módulos se mantiene el orden anterior (Envelope opcional, Settings, Close). El nuevo tab usa el mismo estilo visual que el resto (cuadrado del alto de la franja, icono ocupando todo el cuadro, fondo ligeramente más claro cuando está activo).
- El contenido del panel se ha preparado para este nuevo tab pero, de momento, se mantiene como placeholder tal y como se ha planificado: cuando `panelState.activeTab == kLoopFiles`, el área de contenido interna del panel muestra el texto centrado "Loop files coming soon". La rama de `kEnvelope` sigue delegando en `paintModuleEnvelopeView` y la de `kSettings` en el placeholder "Module settings coming soon". En una iteración posterior, esta rama `kLoopFiles` será donde se instancie y utilice la clase `TextScrollList` para mostrar una lista desplazable de samples disponibles para el módulo Loop.
- En el manejador de entrada del panel de módulo ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L300-L420)) se ha actualizado el hit-test de pestañas para que utilice exactamente la misma geometría que el pintado: el número de tabs (`tabCount`) ahora toma en cuenta tanto `hasLoopFilesTab` como `hasEnvelopeTab`, y se asignan índices consecutivos a `tab_file`, `tab_envelope`, `tab_settings` y `close_button` según corresponda para cada módulo. Cuando el usuario hace click sobre el primer tab de un módulo Loop, `handlePointerDown` detecta que el índice de hit coincide con `filesIndex` y actualiza `panelState.activeTab` a `ModulePanelState::Tab::kLoopFiles`, de modo que la UI cambia visualmente a la nueva pestaña de ficheros aunque el contenido siga siendo, por ahora, un placeholder textual.

### Panel de módulo: pestañas definidas por cada AudioModule
- Se ha introducido en el modelo de dominio ([core/src/core/Scene.h](core/src/core/Scene.h) y [core/src/core/Scene.cpp](core/src/core/Scene.cpp)) una nueva API para describir las pestañas de ajustes que soporta cada módulo:
  - `AudioModule::SettingsTabKind` enum (`kSettings`, `kEnvelope`, `kLoopFiles`).
  - `AudioModule::SettingsTabDescriptor` con `kind` e `icon_id`.
  - `AudioModule::SettingsTabs` como `std::vector<SettingsTabDescriptor>`.
  - Método virtual `AudioModule::supported_settings_tabs()` que por defecto devuelve sólo la pestaña genérica de `Settings` con icono `tab_settings`.
- Los módulos con envolvente (`AudioModuleWithEnvelope`) ahora sobrescriben `supported_settings_tabs()` para exponer, en este orden, las pestañas:
  - `Envelope` (`SettingsTabKind::kEnvelope`, icono `tab_envelope`).
  - `Settings` (`SettingsTabKind::kSettings`, icono `tab_settings`).
- El módulo `LoopModule` sobrescribe `supported_settings_tabs()` para declarar sus pestañas específicas en este orden visual:
  - `LoopFiles` (`SettingsTabKind::kLoopFiles`, icono `tab_file`).
  - `Envelope` (`SettingsTabKind::kEnvelope`, icono `tab_envelope`).
  - `Settings` (`SettingsTabKind::kSettings`, icono `tab_settings`).
- La UI del panel de módulo en [core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp) ha sido refactorizada para:
  - Consultar `moduleForObject->supported_settings_tabs()` y dibujar un tab cuadrado por cada descriptor, seguido de un pseudo-tab de cierre (`close_button`) siempre al final.
  - Determinar el estado activo de cada tab mapeando `SettingsTabKind` a `ModulePanelState::Tab` (`kSettings`, `kEnvelope`, `kLoopFiles`).
- La lógica de input en [core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp) ahora:
  - Usa también `supported_settings_tabs()` para el hit-test de tabs, manteniendo la misma geometría que el pintado.
  - Cambia `panelState.activeTab` en función del `SettingsTabKind` asociado al índice pulsado.
  - Cierra el panel cuando se pulsa el pseudo-tab de cierre (siempre en el índice `settingsTabCount`).
- Al abrir un panel con doble clic sobre un módulo, la pestaña inicial se elige ahora como la primera entrada de `supported_settings_tabs()` del módulo (por ejemplo: `LoopFiles` para Loop, `Envelope` para módulos con envolvente estándar, `Settings` para módulos que sólo exponen ajustes genéricos).

### Nueva vista XYControl para módulos Filter y LFO
- Se ha añadido una clase de UI genérica `rectai::ui::XYControl` en [core/src/MainComponent_XYControl.h](core/src/MainComponent_XYControl.h) y [core/src/MainComponent_XYControl.cpp](core/src/MainComponent_XYControl.cpp), pensada como pad 2D normalizado `[0,1]x[0,1]` reutilizable dentro de las ventanas de detalle de módulo. La clase dibuja un fondo rectangular suave, una pequeña rejilla cruzada y un único “handle” circular blanco que puede arrastrarse libremente por el área del componente. Exponde un API para fijar la posición lógica normalizada (`setNormalisedPosition` / `normalisedX` / `normalisedY`), definir mínimos visuales por eje (`setVisualMinimums`) de forma que la bola nunca llegue al borde izquierdo/superior pero siga mapeando todo el rango lógico, y registrar un callback `setOnValueChanged` que recibe los valores X/Y en dominio normalizado cada vez que el usuario mueve el handle.
- En el modelo de dominio se ha extendido `AudioModule::SettingsTabKind` con un nuevo valor `kXYControl` en [core/src/core/Scene.h](core/src/core/Scene.h#L203-L214), destinado a representar pestañas de tipo pad XY en el panel de módulo. Los módulos `FilterModule` y `LfoModule` sobrescriben ahora `supported_settings_tabs()` en [core/src/core/AudioModules.h](core/src/core/AudioModules.h#L220-L260) y [core/src/core/AudioModules.cpp](core/src/core/AudioModules.cpp#L80-L120 y core/src/core/AudioModules.cpp#L220-L260) para declarar una pestaña inicial `XY` con icono `tab_2d`, seguida de las pestañas ya existentes: en Filter el orden es `XY` → `Envelope` → `Settings`, y en LFO `XY` → `Settings`.
- La estructura `MainComponent::ModulePanelState::Tab` en [core/src/MainComponent.h](core/src/MainComponent.h#L390-L420) se ha ampliado con un nuevo valor `kXYControl`, y se ha añadido un mapa `xyControls_` junto con el helper `getOrCreateXYControl` en [core/src/MainComponent.h](core/src/MainComponent.h#L470-L510) y [core/src/MainComponent.cpp](core/src/MainComponent.cpp#L900-L980) para mantener una instancia ligera de `XYControl` por módulo. El pintado del panel en [core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L3045-L3125) mapea ahora `SettingsTabKind::kXYControl` a `ModulePanelState::Tab::kXYControl` y, cuando esta pestaña está activa, embebe el pad XY dentro del rectángulo de contenido del panel aplicando la misma geometría rotada que el resto de vistas.
- Para el módulo `Filter`, la vista XY usa el eje X como control de `freq` (cutoff normalizado) y el eje Y como control de `q` (resonancia normalizada): en cada frame de pintado se sincroniza la posición del pad con los parámetros actuales (`GetParameterOrDefault("freq"/"q")`) y el callback `setOnValueChanged` escribe de vuelta los nuevos valores en `Scene::SetModuleParameter(moduleId, "freq"/"q", value01)`. Para el módulo `Lfo`, el eje X controla `freq` y el eje Y controla `mult` (profundidad de modulación); en ambos casos se garantiza explícitamente que el eje Y **no** mapea nunca a parámetros de volumen/amp del módulo (por ejemplo, `volume` o `amp`), cumpliendo la restricción de que la vista XY no altere el volumen real de lo que pase por el módulo.
- La lógica de interacción del panel en [core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L1-L120, core/src/MainComponent_Input.cpp#L480-L720, core/src/MainComponent_Input.cpp#L1810-L1885 y core/src/MainComponent_Input.cpp#L2565-L2765) se ha actualizado para soportar la nueva pestaña `kXYControl`: al abrir un panel con doble clic, la pestaña inicial puede ser ahora también `XY` cuando es la primera en `supported_settings_tabs()`. El hit-test de tabs mapea `SettingsTabKind::kXYControl` a `ModulePanelState::Tab::kXYControl`, y se ha introducido un nuevo `PanelDragKind::kXYControl` para capturar gestos de arrastre dentro del pad. Cuando el usuario pulsa y arrastra dentro del área de contenido de la pestaña XY, `handlePointerDown` genera un `ActivePanelDrag` de tipo `kXYControl` y llama a `XYControl::beginPointerAt`, mientras que `handlePointerDrag` y `handlePointerUp` retransforman la posición del puntero al espacio local del panel (respetando la rotación del módulo) y delegan en `dragPointerTo` / `endPointerAt`. El callback de `XYControl` se encarga de actualizar los parámetros de módulo y solicitar repintados con el rate-limit existente, de forma similar a cómo ya ocurría con la vista de Envelope y el navegador LoopFiles.

### Extensión de la vista XYControl a módulos Delay, Modulator y WaveShaper
- Se han añadido pestañas `XY` adicionales para los módulos `DelayModule`, `ModulatorModule` y `WaveShaperModule` sobrescribiendo `supported_settings_tabs()` en [core/src/core/AudioModules.h](core/src/core/AudioModules.h#L260-L320) y [core/src/core/AudioModules.cpp](core/src/core/AudioModules.cpp#L380-L460). Estos módulos, que ya heredaban de `AudioModuleWithEnvelope`, pasan a declarar el mismo patrón de pestañas que `Filter`: `XY` (`tab_2d`) → `Envelope` (`tab_envelope`) → `Settings` (`tab_settings`).
- En el modelo de dominio se ha introducido un descriptor genérico `AudioModule::XYControlMapping` junto con el método virtual `xy_control_mapping()` en [core/src/core/Scene.h](core/src/core/Scene.h#L180-L260) y su implementación por defecto en [core/src/core/Scene.cpp](core/src/core/Scene.cpp#L80-L140). Cada módulo que participa en la UI de XY (por ahora `FilterModule`, `LfoModule`, `DelayModule`, `ModulatorModule` y `WaveShaperModule`) sobrescribe `xy_control_mapping()` en [core/src/core/AudioModules.h](core/src/core/AudioModules.h#L180-L320) y [core/src/core/AudioModules.cpp](core/src/core/AudioModules.cpp#L100-L200, core/src/core/AudioModules.cpp#L360-L460) para declarar explícitamente qué parámetros normalizados se mapean a los ejes X e Y del pad (`freq`/`q` en Filter, `freq`/`mult` en LFO, `delay`/`fb` en Delay, `effect`/`depth` en Modulator y `effect`/`drywet` en WaveShaper), asegurando a la vez que el eje Y nunca apunte a parámetros de volumen maestro como `amp` o `volume`.
- La rama de contenido `kXYControl` del panel de módulo en [core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L3155-L3265) se ha simplificado para depender únicamente de este descriptor: en lugar de hacer `dynamic_cast` por tipo concreto, ahora consulta `baseModule->xy_control_mapping()`, lee los valores actuales mediante `GetParameterOrDefault(mapping.x_parameter, default_parameter_value(...))` y posiciona el pad en consecuencia. El callback `setOnValueChanged` captura el `XYControlMapping` por valor y reenvía las nuevas coordenadas normalizadas a `Scene::SetModuleParameter` usando los nombres de parámetro declarados por el módulo. Con este refactor, toda la política de qué controla cada eje del pad vive en `AudioModules`/`Scene` y la capa de UI se limita a renderizar y propagar valores, facilitando añadir nuevos módulos con pestaña XY sin tocar `MainComponent_Paint`.

### Refactor: helper dedicado LoopFileBrowser para el navegador de samples de Loop
- Se ha extraído la lógica específica del navegador de ficheros del módulo Loop desde `MainComponent` a un helper dedicado `LoopFileBrowser`, definido en [core/src/MainComponent_LoopFileBrowser.h](core/src/MainComponent_LoopFileBrowser.h) y [core/src/MainComponent_LoopFileBrowser.cpp](core/src/MainComponent_LoopFileBrowser.cpp). Esta clase encapsula tanto el estado de exploración por módulo (directorio raíz `Samples/`, directorio actual, fichero seleccionado y vector de entradas) como la integración con la vista genérica `rectai::ui::TextScrollList` usada en la pestaña `LoopFiles` del panel de módulo.
- El helper introduce un pequeño modelo propio:
  - `LoopFileBrowser::EntryKind` (`kClearSample`, `kParentFolder`, `kDirectory`, `kFile`).
  - `LoopFileBrowser::Entry { EntryKind kind; juce::File file; }`.
  - `LoopFileBrowser::State { juce::File rootDir, currentDir, selectedFile; std::vector<Entry> entries; bool initialised; }`.
  - `using StateMap = std::unordered_map<std::string, State>` y `using ListMap = std::unordered_map<std::string, std::unique_ptr<TextScrollList>>` para agrupar toda la información per-módulo.
- El constructor de `LoopFileBrowser` recibe referencias a estos mapas mantenidos por `MainComponent` (`loopFileBrowsers_` y `loopFileLists_`), el directorio raíz resuelto `samplesRootDir_`, y un conjunto de callbacks que permiten mantener el helper desacoplado de detalles concretos del core:
  - `std::function<void()> repaintCallback` para solicitar repintados con el rate-limit de `MainComponent`.
  - `std::function<void(const std::string&)> markLabelActive` para actualizar la visibilidad del label de loop activo (`markLoopSampleLabelActive`).
  - `std::function<rectai::LoopModule*(const std::string&)> findLoopModule` para localizar el `LoopModule` correspondiente a un `moduleId` usando `scene_.FindModule` + `dynamic_cast`.
  - `std::function<bool(const std::string&, int, const std::string&, float, std::string*)> loadSampleFn` que delega en `AudioEngine::loadLoopSampleFromFile`.
- La API pública de `LoopFileBrowser` replica la funcionalidad que antes vivía como helpers privados en `MainComponent`:
  - `ensureInitialised(moduleId, loopModule)` inicializa perezosamente el estado de navegación de un módulo Loop tomando como referencia el slot activo actual (`"sample"` → índice 0–3) y, si existe, la carpeta padre del fichero asociado en `LoopDefinition::filename`. Esta inicialización respeta el límite superior `com.reactable/Samples` (no permite subir por encima de `rootDir`).
  - `rebuildEntries(moduleId, loopModule)` reconstruye el vector de `Entry` para el módulo dado, añadiendo siempre la fila especial `[ CLEAR SAMPLE ]` (azul) en primer lugar, la entrada opcional `< Parent Folder` (verde) cuando el directorio actual no es la raíz, listando directorios en amarillo y ficheros de audio soportados (`.wav`, `.flac`, `.ogg`, `.opus`) en blanco. A partir de este vector construye la lista de `TextScrollList::Item` con estilos de texto apropiados y selecciona la fila que corresponde al fichero actualmente activo, si existe.
  - `getOrCreateList(moduleId)` crea perezosamente un `TextScrollList` por módulo Loop, fija `maxVisibleItems = 6` y `rowHeight = 18`, y conecta su callback de selección a `handleSelectionChanged(moduleId, index)`.
  - `handleSelectionChanged(moduleId, rowIndex)` implementa la semántica del navegador cuando el usuario selecciona una entrada de la lista:
    - `kClearSample`: limpia `LoopDefinition::filename` del slot activo, borra `selectedFile` y simplemente marca el label de loop como activo; el engine ve un slot vacío y no reproduce audio.
    - `kParentFolder`: mueve `currentDir` al padre del directorio actual, siempre clampado a `rootDir`, y vuelve a llamar a `rebuildEntries` para refrescar la lista.
    - `kDirectory`: entra en el subdirectorio clicado (siempre bajo `rootDir`) y reconstruye la lista.
    - `kFile`: calcula una ruta relativa a `rootDir` para guardar en `LoopDefinition::filename`, actualiza `selectedFile` y delega en `loadSampleFn` para cargar el audio en `AudioEngine`. En caso de éxito llama a `markLabelActive` y solicita un repintado; si falla, registra un log `[rectai-core] Loop: failed to load sample from browser: ...`.
- En `MainComponent` ([core/src/MainComponent.h](core/src/MainComponent.h) y [core/src/MainComponent.cpp](core/src/MainComponent.cpp)) se ha reducido la responsabilidad relacionada con el browser de Loop a:
  - Mantener los contenedores brutos `loopFileBrowsers_` (ahora tipados como `std::unordered_map<std::string, LoopFileBrowser::State>`) y `loopFileLists_` (mapa de `std::unique_ptr<TextScrollList>`), más el `samplesRootDir_` resuelto en el constructor a partir de `com.reactable/`.
  - Instanciar una vez `loopFileBrowser_` tras resolver `samplesRootDir_`, pasándole referencias a estos mapas y a los callbacks mencionados.
  - Delegar en el helper desde los métodos privados preexistentes:
    - `ensureLoopFileBrowserInitialised(moduleId, loopModule)` → `loopFileBrowser_->ensureInitialised(...)`.
    - `rebuildLoopFileBrowserEntries(moduleId, loopModule)` → `loopFileBrowser_->rebuildEntries(...)`.
    - `getOrCreateLoopFileList(moduleId)` → `loopFileBrowser_->getOrCreateList(...)`.
    - `onLoopFileSelectionChanged(moduleId, rowIndex)` → `loopFileBrowser_->handleSelectionChanged(...)`.
- Con este refactor, todo el comportamiento concreto del navegador de samples (paths, construcción de filas, reglas de navegación y carga en `AudioEngine`) queda concentrado en `LoopFileBrowser`, mientras que `MainComponent` se limita a orquestar estado global, wiring de callbacks y a consumir el `TextScrollList` resultante desde el contenido de la pestaña `LoopFiles`. El comportamiento observable desde la UI y desde el motor de audio se mantiene idéntico al de la implementación previa integrada en `MainComponent`.

### Icono de aplicación para rectai-core (ventana y ejecutable)
- Se ha configurado el binario principal JUCE `rectai-core` para utilizar el logo de la mesa como icono oficial de la aplicación. En [core/CMakeLists.txt](core/CMakeLists.txt) se ha pasado el recurso [resources/reactable-logo.png](resources/reactable-logo.png) a la función `juce_add_gui_app` mediante los parámetros `ICON_BIG` e `ICON_SMALL`. Esto permite que la herramienta `juceaide` genere automáticamente los formatos nativos de icono en cada plataforma (por ejemplo, `.ico` en Windows y `.icns` en macOS) sin necesidad de convertir manualmente el PNG a otros formatos con comandos externos, de modo que el ejecutable resultante muestra el logo correcto en el sistema operativo.
- Además, se ha creado un target de datos binarios `rectai-core-assets` con `juce_add_binary_data` que empaqueta el propio `reactable-logo.png` dentro del binario de la app. Este target se enlaza ahora con `rectai-core` y expone el logo vía el espacio de nombres `BinaryData`, permitiendo cargar la imagen directamente desde memoria sin depender de rutas relativas en disco en tiempo de ejecución.
- En la clase `MainWindow` de la aplicación principal ([core/src/Main.cpp](core/src/Main.cpp)), el constructor carga el logo embebido usando `juce::ImageFileFormat::loadFrom(BinaryData::reactablelogo_png, BinaryData::reactablelogo_pngSize)` y, si el `Image` resultante es válido, llama a `setIcon(iconImage)` antes de mostrar la ventana principal. Con este cambio, la ventana de `RectaiTable` utiliza el mismo logo reactable tanto en su barra de título como en el icono asociado al ejecutable cuando la plataforma lo soporta, manteniendo una identidad visual coherente entre UI y sistema operativo.

### Vista de Envelope ADSR en ventana de módulo
- Se ha implementado la primera versión funcional de la pestaña **Envelope** dentro del panel de detalle por módulo en `MainComponent` ([core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L3025-L3115) y [core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L320-L440)). Cuando la pestaña activa del panel es `kEnvelope` y el módulo lógico hereda de `AudioModuleWithEnvelope`, el contenido de la ventana deja de mostrar el placeholder de texto y pasa a renderizar una vista ADSR compacta formada por cuatro barras verticales (Attack, Decay, Sustain/Duration y Release) más una barra inferior con dos botones cuadrados de preset.
- Visualmente, el área de contenido del panel se divide en dos zonas: la parte superior muestra las cuatro barras, distribuidas horizontalmente con un pequeño espaciado, y la parte inferior contiene una franja (`kBottomBarHeight ≈ 22 px`) con dos botones cuadrados alineados a izquierda y derecha. Cada barra se pinta como un rectángulo de fondo tenue y un relleno proporcional a su valor normalizado en `[0,1]`, calculado a partir de los tiempos en milisegundos del `Envelope` del módulo (`attack`, `decay`, `duration`, `release`) respecto a los máximos definidos en código (`kEnvelopeMaxAttackMs = kEnvelopeMaxDecayMs = kEnvelopeMaxReleaseMs = 2000 ms`, `kEnvelopeMaxDurationMs = 7500 ms`). En la parte baja de cada barra se dibuja la letra correspondiente (`A`, `D`, `S`, `R`) centrada.
- La franja inferior de la vista Envelope contiene dos botones cuadrados sin borde, rellenos con un fondo ligeramente más claro que el panel y con iconos provenientes del atlas `atlas_2048.xml`: a la izquierda `tab_erase` y a la derecha `tab_envelope`. Ambos se dibujan usando la misma infraestructura de caché de iconos que el resto de la UI (`getCachedAtlasIcon`), ocupando todo el cuadrado del botón. Estos botones representan dos presets de ADSR: el izquierdo “borra” el envelope a un perfil muy corto de tipo one-shot, y el derecho aplica un envelope ADSR estándar con ataque y release más largos y un plateau de sustain visible.
- En la capa de interacción, `mouseDoubleClick` y el gesto de arrastre desde el botón de modo siguen abriendo el panel de detalle por módulo como antes, pero ahora `handlePointerDown` detecta también clics dentro del área de contenido de la pestaña Envelope una vez transformada la posición del puntero al espacio local pre-rotación del módulo. Si el clic cae en uno de los dos botones inferiores, se aplica inmediatamente el preset correspondiente sobre el `AudioModuleWithEnvelope` asociado: el preset “erase” fija `attack = 0`, `decay = 0`, `duration = 25`, `release = 20` y `points_x = {0,0,0,0.2,1}`, `points_y = {0,1,1,1,0}`, mientras que el preset “envelope” establece `attack = 125`, `decay = 125`, `duration = 468.75`, `release = 125` y `points_x = {0,0.266667,0.533333,0.733333,1}`, `points_y = {0,1,0.75,0.75,0}`.
- Si el clic cae dentro del área de barras superior, `handlePointerDown` calcula qué barra se ha pulsado y mapea la coordenada vertical del puntero a un valor normalizado en `[0,1]` (parte inferior de la barra = 0, parte superior = 1). Ese valor se escala luego al rango máximo correspondiente (2000 ms para Attack/Decay/Release, 7500 ms para Duration), se clampa mediante una pequeña utilidad local que replica la lógica de `ReactableRtpLoader` y se escribe en el módulo usando los métodos `set_envelope_attack/decay/duration/release` de `AudioModuleWithEnvelope`. De este modo, al “tocar” una barra se actualiza inmediatamente el tiempo ADSR asociado respetando los límites máximos definidos en el modelo de dominio y actualizando a la vez el parámetro homónimo del módulo (`attack`, `decay`, `duration`, `release`), lo que mantiene en sincronía el `Envelope` interno, el estado de `Scene` y la configuración del `AudioEngine`.

### Reducción de frecuencia de eventos TUIO sin tangibles en rectai-tracker
- Se ha ajustado el bucle principal de `rectai-tracker` en [tracker/src/main.cpp](tracker/src/main.cpp#L120-L260 y tracker/src/main.cpp#L300-L430) para reducir la frecuencia de envío de mensajes TUIO cuando el servicio está en modo de procesado lento y no se detecta ningún fiducial ni dato tangible. El tracker ya disponía de un mecanismo de "low processing rate" que, tras 100 frames procesados sin detecciones (`framesWithoutDetections >= 100`), activa un modo `lowProcessingRate` en el que sólo se ejecuta el pipeline de tracking aproximadamente a 15 FPS; con este cambio, además de procesar menos frames, el emisor TUIO atenúa la cadencia de mensajes hacia el core en situaciones de inactividad prolongada.
- Para ello se ha introducido un contador entero `tuioQuietFrameModuloCounter` junto al contador de secuencia TUIO `tuioFrameSeq` en `main`. En el bloque de envío de mensajes OSC, justo antes de construir el bundle TUIO 1.1 (`TuioOutputMode::Tuio11`), se calcula una bandera `shouldSendTuioThisFrame` que, en condiciones normales, es verdadera. Cuando el modo de salida es TUIO y el tracker está tanto en `lowProcessingRate` como sin objetos estables (`stableObjects.empty()`), el contador se incrementa y sólo se permite el envío en uno de cada tres frames procesados (`tuioQuietFrameModuloCounter % 3 == 0`); en los otros dos, se omite la construcción y envío del bundle TUIO. Si en algún frame vuelven a aparecer objetos estables o se desactiva el modo lento, el contador se resetea a 0 y el tracker recupera la cadencia completa de mensajes.
- Este gating de frecuencia se aplica exclusivamente al modo TUIO 1.1: el bloque que construye y envía mensajes propietarios `/rectai/object` y `/rectai/remove` (modo `TuioOutputMode::LegacyOsc`) permanece intacto y sigue ejecutándose en todos los frames procesados. De esta forma, cuando el tracker entra en modo lento (~15 FPS) por ausencia prolongada de marcadores, el tráfico TUIO efectivo que ve `rectai-core` se reduce adicionalmente a aproximadamente 5 eventos por segundo, tal y como se hace en reacTIVision (1 de cada 3 frames), mientras que la ruta OSC heredada conserva su comportamiento original.
- Tras introducir estos cambios se ha recompilado el proyecto y se ha ejecutado la batería de tests con `ctest --output-on-failure` desde el directorio `build/`, verificando que tanto `rectai-core-tests` como `rectai-tracker-tests` siguen pasando sin errores. Dado que los tests actuales de tracker ejercitan únicamente `TrackerEngine` de forma aislada y no el bucle principal ni el emisor OSC, el cambio de cadencia de TUIO no altera ningún caso de prueba existente.

### Panel de detalle por módulo (envelope/settings), nuevos gestos desde el botón de modo y refinado visual
- Se ha completado la primera versión de un panel de detalle asociado a cada módulo de la mesa en `MainComponent` ([core/src/MainComponent.h](core/src/MainComponent.h), [core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp), [core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp)). El panel mantiene ahora un estado por módulo `ModulePanelState` en `MainComponent` (id lógico del módulo, pestaña activa y visibilidad) dentro de un mapa `modulePanels_`, permitiendo que múltiples módulos tengan su ventana abierta simultáneamente. La posición en pantalla se calcula mediante un helper `getModulePanelBounds` que trabaja en el mismo sistema de coordenadas normalizadas que el resto de la UI (`objectTableToScreen`) y coloca la ventana en el lado “derecho local” del módulo, ligeramente por encima de la barra de volumen.
- El panel se abre actualmente por dos gestos: doble click sobre un módulo dentro del área musical y arrastre hacia la derecha desde el botón de cambio de modo situado debajo del módulo. El doble click se maneja en `mouseDoubleClick` reutilizando la lógica de hitbox circular de los módulos (radio 26 px) y el método `scene_.modules()` para decidir si el módulo soporta envolvente (`AudioModuleWithEnvelope`); si es así, la pestaña por defecto del panel es la de Envelope, en caso contrario se abre en Settings. El gesto de arrastre hacia la derecha se integra en el bloque de drag del botón de modo en `handlePointerDrag`: al superar aproximadamente un radio de nodo en dirección “derecha local” se crea/actualiza una entrada en `modulePanels_` para ese módulo y se cancela cualquier menú radial de modos pendiente. Dado que el panel existe por módulo lógico, estos gestos permiten abrir varias ventanas de detalle en paralelo sin interferencias.
- Visualmente, el panel se dibuja ahora dentro del bucle que pinta cada módulo, aprovechando la misma `AffineTransform::rotation` que se aplica al cuerpo del nodo y a las barras laterales. Para cada `ObjectInstance` dentro del área musical se consulta `modulePanels_` por su `logical_id()` y, si existe una entrada visible, se calcula su rectángulo mediante `getModulePanelBounds`. Sobre este rectángulo se pinta un fondo azul oscuro con esquinas redondeadas (radio ≈10 px) y un borde blanco suave, de forma que la ventana rota y orbita exactamente igual que el módulo. El área de ventana es cuadrada (`kModulePanelWidth == kModulePanelHeight`) y los tabs viven en una franja aparte justo debajo de este cuadrado, de modo que la forma principal del panel no se ve recortada por las pestañas.
- La interacción con las pestañas se resuelve en la parte alta de `handlePointerDown` en `MainComponent_Input.cpp`: antes de procesar otros gestos, se recorre `modulePanels_` y, para cada ventana visible, se transforma la posición del puntero al espacio local pre-rotación usando el mismo ángulo que el pintado del módulo. A continuación se reconstruyen los mismos cuadrados de tab que en el pintado (tres o dos, contiguos, con lado igual a la altura de la franja inferior y alineados a la izquierda justo debajo del panel) y se comprueba si el click ha caído dentro de alguno de ellos, incluso aunque esté fuera del rectángulo principal de ventana. A partir del índice se deriva qué pestaña corresponde (Envelope opcional, Settings, Close) y se actualiza `panelState.activeTab` o se marca `panelState.visible = false` en el caso de la pestaña de cierre. Esta lógica mantiene alineados geometría de pintado e hit-test y permite que cada módulo mantenga su pestaña activa de forma independiente.
- Por ahora, el contenido del panel es un placeholder: en función de la pestaña activa se dibuja un texto centrado (“Envelope controls coming soon” o “Module settings coming soon”) directamente sobre el fondo azul de la ventana cuadrada, reduciendo ligeramente el rectángulo sólo con un margen interior fijo. Dado que los tabs viven en una franja separada, el área de contenido aprovecha todo el cuadrado de ventana y ya no necesita reservar altura adicional para la barra de pestañas.

- A nivel de geometría, se han ajustado las constantes de tamaño del panel en `MainComponent` para que la ventana tenga proporción exactamente cuadrada (`kModulePanelWidth == kModulePanelHeight ≈ 110 px`) en lugar del rectángulo ancho original. Además, el offset horizontal respecto al anillo de barras laterales se ha reducido aún más (offset ≈10 px más allá del radio de barras) para que la ventana aparezca visualmente “pegada” al módulo, a una distancia muy corta de la barra de volumen. Todos estos cálculos se hacen en el espacio local pre-rotación y se benefician de la misma transformada que el nodo, manteniendo relativa constante la distancia aparente entre módulo y panel al moverlo por la mesa.
- El gesto de arrastre desde el botón de modo se ha hecho explícitamente bidireccional en espacio local del módulo: arrastrar hacia la izquierda sigue controlando la apertura del menú radial de modos (`modeSelection_.menuVisible` y `modeDragProgress_`), mientras que arrastrar hacia la derecha abre el nuevo panel de detalle y cancela cualquier menú radial pendiente. Este comportamiento mantiene la UX previa del selector de modos y añade una nueva affordance simétrica para entrar en el panel de detalle sin interferir con los gestos existentes.
 - A nivel de geometría, se han ajustado las constantes de tamaño del panel en `MainComponent` para que la ventana tenga proporción exactamente cuadrada (`kModulePanelWidth == kModulePanelHeight ≈ 110 px`) en lugar del rectángulo ancho original. Además, el offset horizontal respecto al anillo de barras laterales se ha reducido aún más (offset ≈10 px más allá del radio de barras) para que la ventana aparezca visualmente “pegada” al módulo, a una distancia muy corta de la barra de volumen. Todos estos cálculos se hacen en el espacio local pre-rotación y se benefician de la misma transformada que el nodo, manteniendo relativa constante la distancia aparente entre módulo y panel al moverlo por la mesa. El borde exterior de la ventana se ha afinado a 2 px y el color de relleno del triángulo lateral que une visualmente panel y módulo se ha igualado al del propio borde, de forma que la flecha parece una prolongación natural del contorno del panel.
 - Se han retocado también los detalles de layout de la franja de tabs inferior: las pestañas siguen siendo cuadrados contiguos alineados a la izquierda bajo la ventana, pero ahora sus iconos ocupan todo el cuadrado (sin padding interior) para que el gráfico toque directamente el borde de cada tab. Esto refuerza el aspecto de “botones de modo” compactos bajo el panel. La pequeña flecha lateral izquierda se ha reposicionado para que quede verticalmente alineada con el centro del módulo (no con el centro del panel), manteniendo la ilusión de que la ventana está anclada al nodo incluso cuando la posición vertical del panel se separa ligeramente del centro geométrico.
 - El gesto de arrastre desde el botón de modo se ha hecho explícitamente bidireccional en espacio local del módulo: arrastrar hacia la izquierda sigue controlando la apertura del menú radial de modos (`modeSelection_.menuVisible` y `modeDragProgress_`), mientras que arrastrar hacia la derecha abre el nuevo panel de detalle y cancela cualquier menú radial pendiente. Este comportamiento mantiene la UX previa del selector de modos y añade una nueva affordance simétrica para entrar en el panel de detalle sin interferir con los gestos existentes.
