Rediseño barra Delay feedback (UI)
----------------------------------

- Ajustada la barra de Delay en modo feedback para que la parte inferior solo se coloree mientras el valor está en la mitad baja; al entrar en segmentos pequeños se mantiene solo el trazo de fondo.
- Incrementado el gap visual entre los 8 segmentos superiores a 2 px para que la separación sea claramente perceptible.
- Recalculada la geometría de los 8 segmentos pequeños en el semicírculo superior usando el mismo esquema angular que Loop/Oscillator, de modo que todos tienen la misma longitud de arco aunque exista el margen de 3 px del semicirculo.

Integración de rotación TUIO con Delay
--------------------------------------

- Añadido un manejo específico de rotación en MainComponent_Audio para DelayModule.
- Ahora el giro físico de la ficha controla el valor de la barra de Delay: 720º de giro producen un cambio completo de 0–1 en el parámetro.
- En modo feedback el giro actualiza `delay` (tiempo); en modo reverb actualiza `fb` (cantidad), manteniendo el resto de módulos con el comportamiento previo (Loop, Oscillator, etc.).

Ajuste marcador de Delay
------------------------

- El triángulo marcador de la barra de Delay pasa a seguir el valor continuo 0–1 a lo largo de todo el semicírculo, en lugar de encajarse en el centro del segmento activo.

# Progreso 2025-12-23

- Ajustada la barra lateral de Delay en `MainComponent_Paint` para que la parte inferior sea una barra continua y la parte superior muestre los 8 segmentos discretos, con un pequeño hueco entre ellos para que se perciban como divisiones separadas. La orientación se ha corregido de forma que los clics en la parte alta de la barra activan el segmento superior correspondiente y el triángulo indicador se alinea con ese segmento.
- Actualizado el mapeo de duraciones en el motor de audio (`AudioEngine`) para el modo de feedback del Delay: los 8 segmentos ahora representan las divisiones 8/4, 4/4, 2/4, 3/8, 1/4, 1/8, 1/16 y 1/32 de compás (ordenadas de más lenta a más rápida de arriba abajo), usando el BPM global para convertir beats a segundos antes de calcular el número de muestras del delay; el resto de valores por debajo de 1/32 siguen produciendo retardos aún más rápidos.

Overlay de nota para segmentos de Delay
--------------------------------------

- Añadido estado por módulo en `MainComponent` para recordar el último segmento pequeño activo del Delay en modo feedback y el instante en que se seleccionó.
- La interacción de la barra lateral de Delay (click/drag y rotación TUIO) ahora marca el segmento discreto correspondiente cuando el valor entra en la mitad superior de la barra, sin romper el control continuo 0–1.
- Implementado un overlay gráfico que dibuja, usando el atlas `atlas_2048`, el icono de figura rítmica correspondiente al segmento activo en la esquina superior izquierda del nodo de Delay; este icono se mantiene visible unos segundos y luego desaparece con un fundido similar al del overlay de BPM.

Carga de sesión inicial desde ruta relativa
------------------------------------------

- Modificado el constructor de `MainComponent` para que la ruta de sesión inicial (`initialSessionPath`) se resuelva siempre respecto al directorio de trabajo actual mediante `File::getCurrentWorkingDirectory().getChildFile`, evitando el assert de depuración de JUCE cuando se pasa un path relativo (por ejemplo `Reactive 2.rtz`) desde la línea de comandos.

Estabilidad de apagado del motor de audio
-----------------------------------------

- Añadido un método explícito `AudioEngine::shutdown` que retira el callback de `AudioDeviceManager` de forma idempotente.
- Llamada a `audioEngine_.shutdown()` desde `RectaiApplication::shutdown` tras destruir la ventana principal, para garantizar que no queden callbacks activos sobre `AudioEngine` mientras JUCE cierra el dispositivo ALSA en el destructor de `AudioDeviceManager`.
- El destructor de `AudioEngine` delega ahora en `shutdown()` para unificar la ruta de apagado; el cierre efectivo del dispositivo y del hilo ALSA se deja en manos del ciclo de vida estándar de JUCE.
- Al detectar que el hilo ALSA sigue bloqueado en `snd_pcm_writei`, `ALSAThread::close` invoca ahora `snd_pcm_abort` (con `snd_pcm_drop` como respaldo) antes de forzar `snd_pcm_close`, liberando el `writei` bloqueado y evitando `SIGSEGV` dentro de libasound.
- Ajustado el log `[rectai-core][filter-routing]` en `MainComponent_AudioRouting` para que solo se emita cuando cambian los parámetros efectivos del filtro global de Sampleplay/Loop; se guarda el último estado publicado y se compara con tolerancias pequeñas antes de escribir en consola, eliminando el spam continuo cuando los módulos están docked o no hay cambios en la escena.

Supresión de warnings de FluidSynth al salir
-------------------------------------------

- `SampleplaySynth` invoca ahora `fluid_synth_sfunload(..., /*reset_presets=*/0)` tanto al limpiar como al recargar un SoundFont, evitando que FluidSynth intente asignar el preset por defecto (bank 0 prog 0) durante el apagado, lo que generaba los avisos repetidos al cerrar con Escape cuando el SF2 no contiene ese preset.
- `SoundfontUtils::EnumerateSoundfontPresets` y la utilidad `tools/list_sf2_presets` aplican el mismo cambio para que la enumeración o herramientas auxiliares no emitan warnings en consola al liberar el SF2 tras la lectura.

Delay dirigido por conexiones
-----------------------------

- `MainComponent_AudioRouting` deja de aplicar el Delay como efecto global: ahora detecta qué módulo alimenta al `DelayModule` activo (Loop, Sampleplay, Oscillator o incluso Filter/hardlink) y transmite tanto los parámetros como la identidad de la fuente al `AudioEngine` una vez resueltas las voces.
- `AudioEngine` amplía el estado de Delay con un destino explícito (`voice`, `sampleplay` o `loop`); el procesado sólo se aplica a la señal asociada (voces asignadas, bus Sampleplay o loop concreto), manteniendo las demás rutas completamente secas. Si no existe una fuente válida se vuelve automáticamente al modo global.
- El mezclador de loops y Sampleplay se ha actualizado para derivar la señal objetivo al delay buss sin emplear buffers adicionales, reutilizando los `Voices` y acumuladores existentes.
- Además, cuando el Delay no recibe ninguna conexión entrante (o sólo queda enlazado al master) la ruta se desactiva por completo para evitar que el efecto se aplique al master sin fuente; si el módulo alimentado pierde su voz/loop asignado, el Delay se pone en bypass hasta que haya una fuente válida.

Bloqueo del Delay cuando no hay fuente activa
--------------------------------------------

- Añadido un guard en `MainComponent_AudioRouting` para que, incluso si hay un módulo Delay con ruta al master, los parámetros sólo se envíen al `AudioEngine` cuando existe al menos una conexión entrante válida (sin mute ni restricciones geométricas). Si no se encuentra fuente, el modo se fuerza a 0 antes de llegar al motor.
- En la fase final de sincronización con el motor, si por cualquier motivo el Delay quedase apuntando al destino "global", el modo vuelve a bypass automáticamente; esto evita que el FX se active de forma residual cuando todas las conexiones hacia el Delay están muteadas o desconectadas.

Delay multi-fuente y colas persistentes
---------------------------------------

- `MainComponent_AudioRouting` ya no se queda con el primer módulo conectado al Delay: ahora detecta y agrupa todas las fuentes válidas (múltiples Loops, generadores/Filters que comparten voz, Sampleplay) y construye una máscara de voces + lista de loops antes de enviar la configuración al motor.
- `AudioEngine` amplía el estado del Delay para aceptar máscaras de voz, bandera de Sampleplay y hasta 12 loops simultáneos, aplicando el mismo efecto a todas las entradas conectadas.
- Cuando se rompen las conexiones, el Delay continúa drenando la cola interna durante varios segundos alimentándose con entradas nulas, de modo que las repeticiones y reverbs se escuchan completas aunque ya no haya fuentes nuevas.
