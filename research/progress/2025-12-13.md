## 2025-12-13

### Activación inmediata del filtro al crear conexiones
- Se ha ajustado la lógica de ruteo de audio en `MainComponent_Audio.cpp` para que los módulos aguas abajo (incluidos `FilterModule`) empiecen a afectar al sonido en cuanto exista una `Connection` en la `Scene`, tanto si se ha creado dinámicamente por disposición espacial como si es un hardlink explícito.
- En el bucle de asignación de voces dentro de `timerCallback`, la selección del módulo destino (`downstreamModule`) ya no vuelve a comprobar el cono geométrico `isConnectionGeometricallyActive` para decidir si una conexión está activa a nivel de audio; este chequeo sigue aplicándose únicamente en la fase de creación de conexiones dinámicas.
- Diseño de evolución hacia buffers por conexión: documentado en `research/audio_graph_connection_buffers.md` un plan por fases para pasar de buffers por voz a buffers por conexión, alineado con un grafo de audio explícito (`AudioGraph`). Incluye Fase 1 (abstracción de fuente visual por conexión en la UI), Fase 2 (grafos lógicos de audio), Fase 3 (taps físicos por conexión en el motor) y Fase 4 (limpieza).
- Implementada Fase 1 (parcial) en la UI: se añade `MainComponent::ConnectionVisualSource` y un mapa `connectionVisualSources_` que, en `updateConnectionVisualSources()`, asigna a cada `Scene::Connection` de audio una fuente visual concreta (pre-voz, post-voz o Sampleplay) en función del tipo de módulo y del mapeo módulo→voice actual.
- Refactor del pintado de conexiones: `MainComponent_Paint.cpp` deja de decidir ad-hoc si una conexión debe usar `voiceWaveformsPre` o `voiceWaveformsPost` según `FilterModule`; ahora consulta `connectionVisualSources_` tanto para conexiones dinámicas como hardlinks y para el estado de “hold” de una conexión. Esto mantiene el comportamiento existente (Osc→Filter muestra la onda pre-filtro; Filter→Output muestra post-filtro) pero hace que cada conexión tenga una fuente bien definida y extensible a nuevos módulos.
- A partir de este cambio, la ruta de audio considera una conexión válida siempre que su módulo destino esté dentro del área musical y la `Connection` exista en la escena, evitando casos en los que la UI muestra una línea entre un Oscillator y un Filter pero el filtro solo empezaba a sonar tras ajustar manualmente el parámetro `freq`.

### Visualización de loops en radiales
- Se ha ajustado la lógica de radiales en `MainComponent_Paint.cpp` para que `isGeneratorLike` sólo sea cierto para módulos de tipo `ModuleType::kGenerator` (actualmente los osciladores). Esto evita que módulos de tipo `LoopModule` o efectos de audio pierdan su línea radial al master cuando tienen conexiones salientes hacia otros módulos: únicamente los generadores "puros" (Oscillator) esconden su línea directa cuando alimentan una cadena aguas abajo.
- Se ha añadido una ruta específica de visualización para los módulos `LoopModule` en los radiales: como los loops no ocupan voces de oscilador ni disponen de taps por conexión, la UI toma ahora el histórico global de waveform del mezclador (`AudioEngine::getWaveformSnapshot`) para dibujar una forma de onda aproximada sobre la línea radial siempre que el loop tenga ganancia efectiva > 0 y la conexión implícita Loop→Output(-1) no esté muteada. Esto hace que los loops muestren actividad visual en su radial (onda animada) de forma coherente con el resto de módulos que producen audio, incluso en escenas formadas sólo por loops.

- Para que el LoopModule exponga una barra de volumen explícita en el arco derecho, se ha activado `enable_gain_control(true)` en su constructor (`AudioModules.cpp`) con un `set_level_mapping(0.0F, 1.0F)`. La UI ya mapeaba los clics y drags de esa barra al parámetro `"amp"` para módulos Loop/Sampleplay, de modo que ahora la barra se muestra activa y controla directamente el nivel del loop, reutilizando la misma semántica que el control de volumen de Sampleplay.
- En `AudioEngine::audioDeviceIOCallbackWithContext`, rama sin voces de oscilador activas, se ha movido la escritura de `waveformBuffer_[bufIndex]` para que suceda **después** de mezclar los loops. Antes el histórico global de waveform sólo reflejaba el path de Sampleplay en esa rama, dejando a los loops fuera del buffer visual cuando no había osciladores; con el cambio, tanto Sampleplay como Loop (e incluso escenas formadas sólo por loops) quedan representados en el buffer usado por `getWaveformSnapshot`, alineando el sonido real con la forma de onda mostrada.
 - Se ha corregido el mapeo de clics sobre la barra izquierda de los módulos Loop en `MainComponent_Input.cpp`: antes, el índice de segmento se calculaba como `(1.0F - value) * 4.0F`, lo que invertía verticalmente la selección (un clic en la parte alta de la barra activaba el slot 0 y uno en la parte baja el slot 3). Ahora el índice se deriva directamente como `value * 4.0F`, de forma que el segmento inferior corresponde al slot 0 y el superior al slot 3, coherente con el orden en el que se dibujan los segmentos en `MainComponent_Paint.cpp` y con la posición del triángulo selector.

### Normalización del parámetro freq al colocar módulos en la mesa
- En `MainComponent_Input.cpp`, dentro de la rama de `mouseDrag` que actualiza la posición de un objeto arrastrado, se ha añadido una normalización explícita del parámetro `"freq"` cuando un módulo entra por primera vez en el área musical (por ejemplo, al sacar un Filter u Oscillator desde el dock a la mesa).
- Cuando `wasInsideMusic` es falso e `isNowInsideMusic` pasa a verdadero, se localiza el `AudioModule` asociado al `logical_id` del objeto y, si `uses_frequency_control()` está activo, se lee su valor actual de frecuencia mediante `GetParameterOrDefault("freq", default_parameter_value("freq"))` y se vuelve a escribir en la escena con `scene_.SetModuleParameter(module->id(), "freq", currentFreq)`.
- Este ajuste replica el efecto que tenía un primer click sobre el slider lateral de frecuencia (que ya llamaba a `SetModuleParameter`), asegurando que módulos como `FilterModule` tengan su cutoff inicial aplicado de forma consistente al entrar en la mesa, incluso antes de que el usuario interactúe manualmente con el control de `freq`.

### Logs de depuración para cadenas Oscillator → Filter
- En `MainComponent_Audio.cpp` se han añadido logs de depuración justo antes de la llamada a `audioEngine_.setVoiceFilter` cuando la cadena de audio de un generador termina en un `FilterModule`.
- Por cada voz activa cuyo módulo aguas abajo es un filtro, se emite una línea de log con prefijo `[soundtable-core][debug][filter]` que incluye el id del módulo generador, el id del filtro, el cutoff calculado en Hz (`cutoffHz`), el valor efectivo de resonancia (`q`) y el modo de filtro seleccionado (`mode`).
- Estos logs permiten comparar fácilmente el estado del filtro en la primera colocación de un módulo Filter (antes de tocar el control de `freq`) con el estado tras interactuar con el slider, ayudando a diagnosticar por qué el filtro sólo parece actuar después de modificar explícitamente ese parámetro.

### Clamping de freq en Filter para evitar cutoffs desorbitados
- Se ha corregido el cálculo de la frecuencia de corte del `FilterModule` en `MainComponent_Audio.cpp` añadiendo un clamping explícito del parámetro normalizado `freq` al rango `[0,1]` antes de traducirlo a Hz mediante `base_frequency_hz` y `frequency_range_hz`.
- Algunos patches `.rtp` pueden cargar valores heredados para `freq` fuera de ese rango (por ejemplo, ≈124), que al aplicarse directamente en la fórmula `fb + fr * freqParam` daban lugar a cutoffs desorbitados en torno a 186 kHz. En esa situación el filtro se vuelve prácticamente transparente aunque la UI muestre sliders en posición “media”, y sólo empezaba a actuar después de que el usuario tocara el control de `freq` (lo que sobrescribía el valor con un normalizado correcto).
- Con el nuevo clamping, cualquier valor de `freq` que exceda `[0,1]` se reduce a ese intervalo antes de calcular `cutoffHz`, garantizando que el filtro opere siempre en el rango previsto (≈200–1700 Hz para el Filter actual) desde la primera vez que se coloca el módulo en la mesa, sin requerir una interacción manual previa con el slider de frecuencia.

### Ajuste de tests CTest para TrackerEngine
- Se ha corregido el fallo de `ctest` asociado al ejecutable `soundtable-tracker-tests`, que abortaba al no encontrar fiduciales en las imágenes de prueba `fiducial_30.jpg` y `fiducial_55.jpg`.
- En `tracker/src/TrackerEngine.cpp` se ha reforzado la etapa de binarización previa a `libfidtrack`: en lugar de un único umbral adaptativo, el engine prueba ahora varias estrategias (Otsu global normal e invertido, y umbral adaptativo normal e invertido) hasta encontrar la que produce una detección de fiduciales válida. Esto mejora la robustez frente a distintos niveles de contraste y condiciones de iluminación en las imágenes de entrada, respetando el requisito de `libfidtrack` de trabajar sobre imágenes binarias 0/255.
- El test en `tests/tracker_tests.cpp` se ha endurecido de nuevo, ahora que la detección funciona correctamente con las imágenes de ejemplo: para cada fichero (`fiducial_30.jpg` y `fiducial_55.jpg`) se exige que `TrackerEngine::processFrame` devuelva al menos un objeto (`assert(!objects.empty())`) y se mantiene la comprobación de que entre los IDs detectados aparezca exactamente el ID esperado derivado del nombre del archivo (30 y 55 respectivamente). De este modo, la suite de CTest valida explícitamente que la integración con `libfidtrack` es capaz de reconocer los amoeba markers de ejemplo con los IDs correctos.

### Atajos de teclado para pantalla completa y salida rápida
- Se han añadido hotkeys globales a la ventana principal JUCE en `core/src/Main.cpp` para mejorar el flujo de uso en escritorio sin ratón.
- La clase `MainWindow` ahora sobrescribe `keyPressed(const juce::KeyPress& key)` y captura `Escape` para cerrar inmediatamente la aplicación llamando a `juce::JUCEApplicationBase::quit()`, replicando el comportamiento del botón de cierre nativo.
- Se ha implementado un toggle de pantalla completa asociado tanto a `Alt+Enter` como a `F11`: cuando se detecta cualquiera de estas combinaciones, `MainWindow` invoca `setFullScreen(!isFullScreen())` sobre sí misma, alternando entre modo ventana y modo fullscreen usando la API estándar de `juce::DocumentWindow`.
- El resto de teclas se delegan a la implementación por defecto de `juce::DocumentWindow::keyPressed` para no interferir con futuros componentes que deseen manejar atajos propios.

### Altura de waveform en función del volumen del módulo
- Se ha ajustado la lógica de pintado en `MainComponent_Paint.cpp` para que la altura de las formas de onda sobre las líneas de audio dependa del volumen o nivel del módulo correspondiente, en lugar de usar una amplitud fija. Esto afecta tanto a las líneas radiales módulo→Master como a las conexiones módulo→módulo (dinámicas y hardlink).
- Dentro de `paint`, se ha introducido un helper local `getModuleVisualLevel(const soundtable::AudioModule*)` que devuelve un factor normalizado en `[0,1]` a partir de los parámetros del módulo:
  - Para `VolumeModule`, se usa el parámetro `"volume"` (0..1).
  - Para `SampleplayModule`, `LoopModule` e `InputModule`, se usa el parámetro `"amp"` (0..1).
  - Para `OscillatorModule`, se usa el parámetro `"gain"` (0..1).
  - Para `FilterModule`, se usa el parámetro `"q"` como proxy del énfasis del filtro.
  - Para otros módulos con `uses_gain_control()` activo, se intenta leer `"gain"` y, en caso contrario, se devuelve 1.0.
- En las líneas radiales, la amplitud base de la waveform (que ya se había incrementado para hacerla aproximadamente 3 veces más alta) se multiplica ahora por el `visualLevel` del módulo asociado al objeto. De este modo, al bajar el gain/amp de un oscilador o Sampleplay, el “soundwave” sobre su línea a Master se hace más pequeño hasta casi desaparecer cuando el volumen está a 0, manteniendo visible la línea estructural sin waveform.
- En las conexiones entre módulos, tras localizar `fromModulePtr` y `toModulePtr` se calcula un `connectionLevel = max(fromLevel, toLevel)` usando el helper anterior. Todas las ramas que dibujan waveform sobre conexiones (segmento de hold con split, hardlinks con waveform, y conexiones dinámicas con `useWaveformPath=true`) escalan ahora su `waveformAmplitude` por este `connectionLevel`, de forma que las rutas de señal que atraviesan módulos con niveles bajos muestran ondas más planas y las cadenas con módulos a alto volumen mantienen la waveform alta.
- Este cambio mantiene la independencia entre la generación de audio (el motor sigue generando waveform interna incluso a volumen 0 para estabilizar la visualización) y la percepción visual de loudness: la forma de onda representada sigue siendo la misma (gracias al estimador de periodo corregido), pero su altura en pantalla comunica el nivel relativo del módulo o de la conexión según sus parámetros de volumen.

### Estabilización de la forma de onda para notas graves con Sequencer
- Se ha ajustado el estimador de periodo usado por la capa de pintado para repetir una sola onda a lo largo de las líneas de audio. En `MainComponent_Paint.cpp`, la lambda `estimateWaveformPeriod` ahora ignora retardos (lags) demasiado pequeños al calcular la autocorrelación sobre el snapshot de cada voz, imponiendo un `minLag` de 4 muestras y descartando periodos estimados menores que ese umbral.
- Antes del cambio, para ciertas notas graves disparadas desde el `SequencerModule`, la autocorrelación tendía a elegir un periodo degenerado de 1–2 muestras en ventanas donde el contenido variaba lentamente. Al usar ese valor como longitud de periodo, la función `drawWaveformOnLine` terminaba leyendo siempre la misma muestra al recorrer la línea, produciendo una línea prácticamente recta cuyo desplazamiento vertical cambiaba cuadro a cuadro en lugar de mostrar una senoide estable.
- Con el nuevo umbral mínimo, el estimador de periodo sigue detectando correctamente periodos en el rango de frecuencias típico de los osciladores del proyecto, pero evita colapsar a un periodo de una sola muestra. En la práctica, las conexiones de osciladores de tipo seno controlados por el Sequencer muestran ahora una forma de onda sinusoidal coherente tanto en notas agudas como en notas graves, eliminando el efecto visual de “línea que solo vibra arriba y abajo” que se observaba previamente.

### Diseño del módulo Sequencer y capa MIDI interna
- Se ha creado el documento `research/sequencer.md` que define el diseño detallado del módulo `Sequencer` y de una capa de señal MIDI interna para el proyecto. El documento describe una estructura de evento de nota (`MidiNoteEvent` con canal, nota, velocidad normalizada, tiempo en beats y tipo NoteOn/NoteOff) independiente de JUCE pero mapeable a `juce::MidiMessage` o al motor de audio.
- El plan introduce un enum `PortSignalKind` (`kAudio`, `kMidi`, `kControl`) y evoluciona `PortDescriptor` para distinguir explícitamente entre puertos de audio, MIDI y control, además de proponer flags `produces_midi_` y `consumes_midi_` en `AudioModule` y la extensión de `CanConnectTo` para soportar conexiones MIDI→MIDI manteniendo a los controladores globales (`Volume`, `Tempo`, `Tonalizer`) fuera del grafo de conexiones.
- Se define el rol MIDI de los módulos clave: `SequencerModule` como productor de eventos de nota, `SampleplayModule` y `OscillatorModule` como consumidores de MIDI (mapeando notas a presets de SoundFont o a frecuencia/ganancia por voz), y `TonalizerModule` como controlador global que transforma las notas antes de materializarlas en audio.
- Para el `SequencerModule` se plantea una estructura de 6 presets con 16 pasos cada uno (`SequencerPreset` y `SequencerStep`), soportando tres modos (`SequencerMode::kMonophonic`, `kPolyphonic`, `kRandom`), donde el Monophonic se implementará primero pero la representación de datos queda preparada para extensiones polifónicas (varios pitches por step) y lógicas aleatorias sin cambios de API.
- El runtime monofónico se sincroniza con el `TempoModule` usando una fase global en beats y una resolución de 16 pasos por compás; en cada transición de step se generan eventos `NoteOff`/`NoteOn` según los flags `enabled` y `velocity01` del step, almacenados en presets seleccionados mediante la rotación del tangible (6 presets según la posición del marcador/`point` en el `.rtp`).
- El roadmap técnico asociado incluye: 1) introducir la infraestructura MIDI (tipos de puerto, flags y `MidiNoteEvent`), 2) completar el estado y API de `SequencerModule` para presets y pasos, 3) implementar un runtime monofónico sincronizado con tempo en el `AudioEngine`, 4) enrutar los eventos hacia `Sampleplay`/`Oscillator` usando `Scene::connections()` y 5) extender posteriormente a modos Polyphonic y Random con runtimes específicos que compartan el mismo modelo de datos.

### Infraestructura MIDI en `Scene` y presets iniciales del Sequencer
- Se ha extendido el modelo de puertos en `core/src/core/Scene.{h,cpp}` introduciendo el enum `PortSignalKind` (`kAudio`, `kMidi`, `kControl`) y haciendo que `PortDescriptor` almacene explícitamente el tipo de señal. `AudioModule` incorpora ahora flags `produces_midi_` y `consumes_midi_` junto con sus getters, y `CanConnectTo` permite conexiones cuando hay compatibilidad audio→audio o MIDI→MIDI, manteniendo la prohibición de conexiones para módulos marcados como controladores globales.
- Todos los módulos concretos de `core/src/core/AudioModules.cpp` se han actualizado para declarar sus puertos con el tipo correcto: los módulos de audio usan `PortSignalKind::kAudio` en `in`/`out`, el `LfoModule` expone un puerto `out` de tipo `kControl` y el `SequencerModule` declara un puerto `out` de tipo `kMidi`, marcándose además como productor de MIDI (`produces_midi=true`). La lógica de pintado en `MainComponent_Paint.cpp` se ha ajustado para detectar conexiones de audio consultando `PortSignalKind::kAudio` en los puertos en lugar del antiguo flag booleano `is_audio`.
 - Todos los módulos concretos de `core/src/core/AudioModules.cpp` se han actualizado para declarar sus puertos con el tipo correcto: los módulos de audio usan `PortSignalKind::kAudio` en `in`/`out`, el `LfoModule` expone un puerto `out` de tipo `kControl` y el `SequencerModule` declara un puerto `out` de tipo `kMidi`, marcándose además como productor de MIDI (`produces_midi=true`). Los módulos `OscillatorModule` y `SampleplayModule` se han marcado como consumidores de MIDI (`consumes_midi=true`) y ahora exponen un puerto de entrada `in` de tipo `kMidi` además de su salida de audio `out`, permitiendo que el sistema de conexiones espaciales (dinámicas y hardlinks) establezca enlaces `Sequencer → Oscillator` o `Sequencer → Sampleplay` de forma completamente genérica usando `AudioModule::CanConnectTo` y `Scene::AddConnection`, sin código específico para pares de módulos concretos. La lógica de pintado en `MainComponent_Paint.cpp` se ha ajustado para detectar conexiones de audio consultando `PortSignalKind::kAudio` en los puertos en lugar del antiguo flag booleano `is_audio`.
- Se ha añadido `core/src/core/MidiTypes.h` con la estructura `MidiNoteEvent` (canal, nota, velocidad normalizada, tiempo en beats y flag NoteOn/NoteOff), pensada como representación interna de eventos MIDI que el runtime del Sequencer utilizará para disparar notas en `Sampleplay`/`Oscillator` y que podrá mapearse a estructuras de JUCE o directamente al motor de audio.
- `SequencerModule` en `core/src/core/AudioModules.{h,cpp}` incorpora ahora un banco fijo de presets monofónicos (`SequencerPreset`) con 6 presets de 16 pasos cada uno (`SequencerStep` con `enabled`, `velocity01`, `pitch`) y un enum `Mode` (`kMonophonic`, `kPolyphonic`, `kRandom`) preparado para futuras extensiones. Se expone una API mínima para consultar y modificar el modo, el preset actual y el contenido de cada preset.
- El loader de patches Reactable (`ReactableRtpLoader.cpp`) sigue rellenando la estructura de bajo nivel `SequenceTrack` a partir de los elementos `<sequence>` del `.rtp` (filas, `speed`, `speed_type`, `step_frequencies`, `steps`, capas `tenori0..tenori12` y `volumes`), pero ahora, tras cargar todos los tracks en cada `SequencerModule`, llama a `SequencerModule::SyncPresetsFromTracks()`. Este helper recorre como máximo los primeros 6 `SequenceTrack` y, para cada uno, proyecta los datos sobre los 16 pasos del preset correspondiente: `steps` se mapea a `enabled` (0/1 por paso), `volumes` se clampa a `[0,1]` y se usa como `velocity01`, y `step_frequencies` se convierte a nota MIDI aproximada (`pitch`) mediante la fórmula estándar `midi = 69 + 12 * log2(freq/440)` con clamp a `[0,127]`. Cuando no hay datos suficientes, se desactivan los pasos o se mantiene `pitch=60` (C4) como valor por defecto.
- Con este mapeo, cualquier patch `.rtp` que defina secuencias para el módulo `Sequencer` queda traducido automáticamente a un banco interno 6x16 listo para ser consumido por el runtime monofónico: las estructuras de presets/steps ya contienen una representación compacta (enabled/velocity/pitch) independiente de los detalles de `SequenceTrack`, lo que permitirá implementar la lógica de avance por pasos sincronizada con el tempo sin depender directamente del esquema XML original.
 - Se ha implementado un primer runtime monofónico del Sequencer en `MainComponent_Audio.cpp`, sincronizado con el BPM global. `MainComponent` mantiene ahora un estado de fase/step específico para audio (`sequencerAudioPhase_`, `sequencerAudioStep_`) con 16 pasos por compás; en cada tick del `timerCallback` se avanza esta fase según `bps = bpm_ / 60` y, cuando cambia el step, se recorre cada `SequencerModule` presente en la escena (no muteado y dentro del área musical), se lee el preset activo y el `SequencerStep` correspondiente, y si `enabled` y `velocity01 > 0` se disparan acciones sobre los módulos aguas abajo.
 - Para módulos `Sampleplay` conectados al Sequencer (respetando área musical, hardlinks y cono geométrico, así como mute por objeto/conexión), se dispara una nota corta vía `audioEngine_.triggerSampleplayNote(bank, program, midiKey, velocity01)`, usando el `pitch` del step como nota MIDI (clampada a `[0,127]`) y calculando la velocidad combinando `velocity01` con el `amp` del Sampleplay, su `base_level`/`level_range` y el volumen global ya mapeado a dB. Esto permite que cualquier patch con `Sequencer` → `Sampleplay` empiece a producir patrones rítmicos reales desde las secuencias cargadas del `.rtp`.
 - Para módulos `Oscillator` conectados al Sequencer, el runtime traduce `pitch` a frecuencia en Hz (`440 * 2^((pitch-69)/12)`) y la normaliza al rango propio del oscilador (`base_frequency_hz` + `frequency_range_hz`), actualizando el parámetro `freq` de ese módulo mediante `Scene::SetModuleParameter`. El parámetro `gain` del oscilador se alimenta directamente desde `velocity01` (clampado a `[0,1]`). De este modo, los osciladores conectados a un Sequencer siguen el patrón de notas/velocidades definido en los presets, y el motor de audio recoge estos cambios en el siguiente tick sin requerir todavía una cola de `MidiNoteEvent` explícita.
 - El runtime respeta siempre la topología y el estado de la escena: solo se consideran conexiones en las que el Sequencer es `from_module_id`, el objeto destino está dentro del área musical y, si la conexión no es hardlink, el cono geométrico la considera activa (`isConnectionGeometricallyActive`). Además, se ignoran módulos destino muteados o conexiones marcadas como mute en `mutedConnections_`. El secuenciador visual existente (8 pasos por compás para widgets de UI) se mantiene separado usando `sequencerPhase_` / `sequencerStep_`, de manera que la nueva lógica de audio no altera la representación gráfica previa.
 