```markdown
# 2025-12-21

- Se ha extraído la lógica de routing de audio desde `MainComponent::timerCallback` a un helper dedicado `updateAudioRoutingAndVoices`, reutilizando GeometryCache para mapear módulos a objetos y mantener `modulesWithActiveAudio_`, `moduleVoiceIndex_` y `connectionVisualSources_` de forma coherente.
- Se ha creado un helper `rotationTrackingUpdate` que centraliza el cálculo de deltas de rotación por objeto y limpia entradas obsoletas, usado desde el timer.
- Se ha extraído la lógica de control por rotación (pitch/freq de módulos, selección de muestras de Loop, BPM global y volumen maestro) a `updateRotationDrivenControllers`, manteniendo el mismo comportamiento pero dejando `timerCallback` como un orquestador de alto nivel.
- Tras los cambios, el proyecto compila en Debug y los tests `rectai-core-tests` y `rectai-tracker-tests` pasan con éxito (`ctest --output-on-failure`).

- Implementada una vista de ajustes basada en TextScroll para el módulo Tempo, utilizando el icono `tab_bars` en la tira de pestañas del panel de módulo.
- La vista muestra una lista fija de presets de BPM (Grave 40, Lento 50, Larghetto 63, Adagio 73, Moderato 95, House 125, Allegro 139, Presto 184, Prestissimo 250) y selecciona automáticamente el preset más cercano al BPM global actual al abrirse.
- Al hacer clic en un preset, se actualiza el BPM global de la sesión y el parámetro `tempo` del TempoModule, manteniendo sincronizada la lógica de audio y la visualización (etiqueta transitoria de BPM y sincronía con el motor de loops).
- Refactorizada la definición de presets de BPM del módulo Tempo para que vivan en los ajustes del propio `TempoModule` (API estática en AudioModules), consumidos desde MainComponent en la vista de TextScroll.
- Ajustado el dibujado de la barra de frecuencia en los módulos con `uses_frequency_control` (principalmente Oscillator y Filter) para que el relleno blanco siga la curva del arco en lugar de depender de un recorte rectangular, corrigiendo el artefacto visual de "barra recta".
- Sin cambios funcionales en el motor de audio; solo se ha tocado el código de pintado en `core/src/MainComponent_Paint.cpp`.

- Introducido un nuevo control visual de pitch para los módulos Oscillator y Sampleplay basado en dos anillos radiales en el lateral izquierdo: un anillo interior de 8 segmentos pequeños que indican la octava y un anillo exterior de 12 segmentos con triángulo posicionador que indican la nota dentro de una ventana fija de pitch (mapeada desde el parámetro `midifreq`).
- Añadida la flag `uses_pitch_control` en `AudioModule` y activada en `OscillatorModule` y `SampleplayModule`, de modo que la rotación del objeto tangible ajusta ahora el parámetro `midifreq` (360º = ±1 octava); en el caso de Oscillator, se mantiene sincronizado también el parámetro normalizado `freq` para que el motor de audio siga derivando la frecuencia en Hz a partir del pitch actual.
- Adaptada la interacción de la barra lateral izquierda para que, cuando un módulo usa pitch control, los clicks y arrastres sobre esa zona actualicen la nota/octava (escribiendo `midifreq` y, para Oscillator, recalculando `freq`), mientras que el comportamiento existente para Loop (4 segmentos + triángulo) y para los módulos que siguen usando `uses_frequency_control` permanece sin cambios.

 - Ajustado el rango de frecuencia del Oscillator a 20–3918 Hz para que cubra un rango musical práctico (aprox. de C2 a entorno de C8), actualizando el comentario del módulo para reflejar que los valores fuera de ese rango se saturan mediante el parámetro normalizado `freq`.
 - Unificada la escala MIDI usada por la UI de pitch, la rotación y las interacciones de click/drag en el lateral izquierdo para que trabajen en una ventana [24, 108] (C2–C8 aprox.), manteniendo 8 segmentos de octava en el anillo interior pero haciendo que el último represente la parte alta de esa ventana. Esto deja alineado el comportamiento visual y gestual con el rango 20–3918 Hz del Oscillator.
 - Cambiada la heurística de retrigger del Envelope en Oscillator para que cualquier cambio efectivo de pitch/frecuencia (click, drag o rotación del módulo que altere realmente el valor) dispare explícitamente una nueva nota en el motor de audio mediante `triggerVoiceEnvelope`; si el parámetro ya está en el valor mínimo/máximo o el mapeo no cambia de nota, no se re‑dispara. Esto hace que los ajustes de ataque/decay/sustain/release se apliquen de forma consistente en cada cambio de pitch, emulando el comportamiento de notas MIDI sin generar retriggers espurios.

- Ajustada de nuevo la heurística de retrigger del Envelope en Oscillator para que solo se vuelva a disparar explícitamente en envelopes de tipo one‑shot (sin meseta de sustain clara); en envelopes con plateau de sustain, los cambios de pitch/frecuencia se tratan como legato (sin retrigger) para evitar clicks audibles al cambiar de nota, manteniendo el min‑attack interno para evitar transitorios duros.
- Añadido un flag específico en `OscillatorModule` (`play_midi_note_from_rotation`, por defecto `false`) que permite conmutar entre dos modos de rotación: mapeo continuo a Hz (comportamiento por defecto) o cuantización a notas MIDI discretas (la rotación se alinea con los segmentos de nota/octava de la UI de pitch, usando un redondeo a semitonos antes de recalcular `midifreq` y `freq`).

- Ajustado el comportamiento del retrigger en modo "nota MIDI desde rotación" para que siga utilizando la misma heurística de envelopes one‑shot vs. sustain (plateau) que en el modo continuo, evitando retriggers forzados en envelopes de tipo sustain que generaban clicks audibles al cambiar de nota aunque no hubiese un pulso claramente separado.
- Modificado el cálculo del ángulo del triángulo de pitch en la UI lateral para que se derive del centro del segmento de nota activo en el anillo exterior (pitch class) en lugar de mapear toda la ventana de `midifreq` de forma lineal, de manera que el triángulo y el segmento coloreado del anillo externo señalen siempre exactamente la misma nota.

- Inicio del refactor de la capa visual en `MainComponent::paint`: ahora se reutiliza `GeometryCache` para mapear módulos a objetos (en lugar de reconstruir un mapa local) y se ha extraído la lógica que calcula qué objetos tienen conexiones salientes activas a un helper privado (`computeObjectsWithOutgoingActiveConnection`). Esto deja la función de pintado algo más legible sin cambiar el comportamiento.

- Continúa el refactor visual de `MainComponent::paint`: se ha extraído el bloque completo de pintado de objetos y paneles (`Objects: aura + parameter arcs + icon + label + panels`) a un helper dedicado `paintObjectsAndPanels`, que ahora encapsula también los paneles de módulo (Envelope, LoopFiles, XY y Settings) y el overlay de BPM para Tempo. También se han extraído los overlays de secuenciador a `paintSequencerOverlays` y el dibujo del dock + HUD OSC/TUIO a `paintDockAndHud`, manteniendo el orden y comportamiento originales. Tras estos cambios el proyecto vuelve a compilar en Debug y los tests `rectai-core-tests` y `rectai-tracker-tests` siguen pasando.

```
