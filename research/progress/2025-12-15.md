## 2025-12-15

### Centralizar la forma de onda de Oscillator en AudioModules
- La selección de la forma de onda de `OscillatorModule` se expone ahora exclusivamente a través del sistema genérico de modos (`supported_modes()` + `current_mode_index()`/`set_mode(int)`), manteniendo internamente un enum `Waveform` para el runtime de audio.
- En `MainComponent_Audio.cpp`, dentro de `timerCallback`, el índice de forma de onda que se pasa al motor (`AudioEngine::setVoiceWaveform`) se obtiene directamente de `AudioModule::current_mode_index()`, con `0` como fallback cuando el módulo no expone modos. Esto evita tener helpers específicos como `waveform_index()` y mantiene toda la información pública (id, tipo, icono, índice) centralizada en `AudioModuleMode`.

### Sincronía de transporte basada en el motor de audio

- Se introdujo un reloj global de transporte en beats dentro de `AudioEngine` (`transportBeatsInternal_` + `transportBeatsAudio_`) que se actualiza en el callback de audio a partir del BPM (`loopGlobalBpm_`) y de la `sampleRate_`. Este valor se expone al UI mediante `AudioEngine::transportBeats()`.
- `MainComponent::timerCallback` dejó de integrar los beats a partir de `dt` del `juce::Timer` y ahora deriva `transportBeats_` (parte entera) y `beatPhase_` (fracción) a partir de `audioEngine_.transportBeats()`. Los pulsos centrales (estructura `pulses_`), el índice de beat en el compás (`beatIndex_`) y el disparo de notas de Sampleplay en cada beat (`triggerSampleplayNotesOnBeat`) se basan ahora en este reloj de audio, evitando drift entre audio y visuales/sequencer.
- El runtime del Sequencer sigue calculando el índice de step de audio como `floor((transportBeats_ + beatPhase_) / (1.0/4.0)) % 16`, pero como `transportBeats_ + beatPhase_` proviene ahora del reloj del motor de audio, los steps se mantienen alineados a largo plazo con loops y pulsos.
- Los módulos de Loop pasan a usar también el transporte del motor como fuente para el cálculo de `loopBeats` (usado al realinear la posición de reproducción al cambiar de slot), manteniendo la fase de los loops acoplada al mismo reloj que el Sequencer.

### Mejora de la cola de decay en Oscillators

- El `AudioEngine` utilizaba una envolvente simple AR por voz donde, hasta ahora, el nivel de salida era `targetLevel * envAmp` y el `targetLevel` se leía directamente de `voices_[v].level` (lo que se mapea desde los parámetros `gain`/`amp` de los módulos). Cuando el Sequencer desactivaba un step y ponía `gain=0`, `targetLevel` pasaba a 0 inmediatamente, provocando que incluso en fase de release el producto fuera 0 y la cola de decay no se oyera.
- Se añadió un buffer de nivel base por voz (`voiceEnvBaseLevel_`) que captura el nivel objetivo en el momento del note-on (inicio de ataque). La envolvente avanza en base a este nivel fijo y el output se calcula ahora como `baseLevel * envAmp`. Cuando la envolvente entra en estado `Idle`, el `baseLevel` se resetea a 0.
- Con este cambio, cuando un step del Sequencer se apaga (el Oscillator pasa a `gain=0`), el motor detecta el note-off, entra en fase de release y la cola de decay se reproduce sobre el nivel capturado en el note-on, en lugar de cortarse de forma brusca.

#### Ajuste posterior: respetar el volumen en tiempo real

- El uso directo de `baseLevel * envAmp` para todas las fases de la envolvente provocaba que los cambios de volumen realizados por el usuario en la barra de volumen del Oscillator dejaran de afectar al nivel audible una vez disparada la nota (el `baseLevel` se fijaba en el note-on y no seguía a `voices_[v].level`). Visualmente las líneas de conexión seguían reflejando el volumen correcto, pero el audio permanecía a un nivel casi constante o "congelado" tras haber bajado y subido el volumen.
- En `AudioEngine::audioDeviceIOCallbackWithContext`, en la sección donde se mezcla cada voz de Oscillator, se ha cambiado el cálculo final de ganancia para combinar el nivel actual y el nivel base: ahora se lee `voices_[v].level` en cada muestra y se usa como `targetLevelNow` para la mezcla en fases de ataque/decay/sustain, de modo que el sonido sigue a la barra de volumen del usuario en tiempo real.
- Solo cuando la envolvente está en fase de `Release` y el nivel objetivo ha caído prácticamente a cero (caso típico cuando el Sequencer fuerza silencio en un step) se usa `voiceEnvBaseLevel_` como `levelForMix`. Así, las colas de decay siguen siendo audibles aunque el Sequencer haya llevado el nivel instantáneo a 0, pero el control de volumen del usuario vuelve a funcionar con normalidad durante el resto del ciclo.

### Waveforms de conexiones alineadas con el audio real

- Hasta ahora, los buffers de waveform por voz (`voicePreFilterWaveformBuffer_` y `voicePostFilterWaveformBuffer_`) y los taps de conexión (`connectionWaveformBuffers_` con `ConnectionTapSourceKind::kVoicePre/kVoicePost`) almacenaban la forma de onda cruda del oscilador (pre y post filtro) sin aplicar ni la envolvente ni el nivel de salida. Esto hacía que, visualmente, las líneas de audio (Oscillator, conexiones hacia Filter, etc.) mostrasen una señal con amplitud constante incluso cuando, en términos de audio, la envolvente había entrado en decay/release o el sustain era cero, es decir, cuando ya no debería haber sonido.
- En `AudioEngine::audioDeviceIOCallbackWithContext`, tras evaluar la envolvente y calcular el `levelForMix` efectivo (combinando el valor actual de volumen y, en caso necesario, el `voiceEnvBaseLevel_` durante la fase de release), se calculan ahora muestras por voz ya escaladas: `voiceSamplePre` (antes del filtro) y `voiceSamplePost` (después del filtro), ambos como `levelForMix * envAmp * raw`/`s`.
- Los buffers `voicePreFilterWaveformBuffer_` y `voicePostFilterWaveformBuffer_` pasan a almacenar estas señales ya moldeadas, y los taps de conexión de tipo `kVoicePre`/`kVoicePost` escriben en `connectionWaveformBuffers_` usando igualmente `voiceSamplePre`/`voiceSamplePost`. De este modo, las waveforms que se dibujan en las líneas de conexión y en los radiales de módulos reflejan la señal de audio real (incluyendo envolvente y volumen) que circula por cada conexión.
- Como consecuencia, cuando un Oscillator deja de emitir sonido (por ejemplo, tras el decay con sustain cero o cuando el Sequencer fuerza silencio y la envolvente entra en `Idle`), las waveforms asociadas a sus conexiones se aplanan y los módulos aguas abajo (p.ej. Filter) sólo muestran/suman el audio que realmente les llega, respetando también la suma de entradas múltiples.

### Radiales de módulos consumidores con suma de entradas

- Hasta este punto, los radiales de módulos consumidores de audio sin barra de volumen propia (como `FilterModule`) se basaban en un único índice de voz (`moduleVoiceIndex_`) y en los buffers `voiceWaveformsPost`, de modo que, si un módulo recibía varias entradas de audio (por ejemplo varios Oscillators y/o Sampleplay), su radial sólo reflejaba una de ellas.
- En `MainComponent_Paint.cpp`, dentro del pintado de radiales, se ha introducido un helper local `computeAggregatedIncomingWaveform` que recorre todas las `Scene::Connection` de tipo audio cuyo `to_module_id` coincide con el módulo actual, aplicando los mismos filtros que el ruteo visual (mutes, área musical y geometría activa) y usando `audioEngine_.getConnectionWaveformSnapshot` para obtener la waveform de cada conexión con tap configurado.
- Para módulos de audio sin barra de volumen explícita (p.ej. filtros y futuros FX), tanto en el modo de “hold-mute” como en el radial normal, se intenta primero dibujar la waveform agregada sumando todas las entradas activas y calculando su normalización y RMS a partir de esa suma. Sólo si no hay entradas activas o la suma resulta prácticamente silenciosa se cae de nuevo al comportamiento anterior basado en una única voz.
- De esta manera, el radial de un módulo consumidor representa ahora la **suma real** de todas las señales de audio que le llegan (Oscillator, Sampleplay, Loop, etc.), y cuando una fuente deja de emitir sonido su contribución desaparece automáticamente de la curva agregada, manteniendo la coherencia entre la propagación visual y el audio que efectivamente circula por el grafo.
 - Para que la envolvente sea realmente la que gobierna el final de la nota (y no el gating de voces en `MainComponent`), se eliminó la condición que sólo asignaba voces de generador cuando `calculatedLevel > 0`. Ahora cada cadena de generador mantiene una voz activa (dentro del presupuesto de `kMaxVoices`) incluso cuando su nivel instantáneo o el `gain` controlado por el Sequencer son 0; la voz genera señal y la envolvente AR aplica el fade-out hasta llegar a `Idle`.

### Desacoplar la resonancia (Q) del Filter de la altura visual de la waveform
- Se ha ajustado la lógica de pintado en `core/src/MainComponent_Paint.cpp` para que el parámetro de resonancia `q` del `FilterModule` deje de influir en la altura de las formas de onda que se dibujan sobre las líneas de audio. Hasta ahora, el helper local `getModuleVisualLevel` usaba `q` como factor de escala visual, de modo que al aumentar la resonancia la waveform se hacía más alta o baja independientemente del volumen real percibido, dando la sensación de que la barra de Q actuaba como un control de volumen.
- En `getModuleVisualLevel` se ha eliminado el caso específico `FilterModule` que devolvía `q` normalizado como nivel visual. A partir de este cambio, los filtros se tratan como módulos sin control de volumen dedicado a efectos de visualización: la altura de la waveform en sus líneas radiales y conexiones se determina únicamente por la señal de audio normalizada procedente del motor (`voiceWaveformBuffer_` y `sampleplayWaveformBuffer_`), sin ningún escalado extra ligado a la resonancia.
- El resto de módulos mantienen su comportamiento anterior: `VolumeModule` sigue usando el parámetro `volume`, los módulos `Sampleplay`, `Loop` e `Input` usan `amp` como nivel principal, los osciladores (`OscillatorModule`) usan `gain`, y el fallback genérico para módulos con `uses_gain_control()` verdadero continúa leyendo `gain` cuando existe. Con ello, solo las barras laterales que representan realmente un volumen (volume/amp/gain) afectan a la altura de la waveform; las barras reutilizadas para otros parámetros (como Q en filtros) ya no alteran la percepción visual de loudness en las líneas de audio.

### Altura de waveform basada en RMS para módulos sin barra de volumen
- Se ha incorporado un cálculo de RMS real sobre los snapshots de audio que ya se obtenían del `AudioEngine` en `core/src/MainComponent_Paint.cpp`. Para cada voz procedimental (`getVoiceWaveformSnapshot`) se calcula ahora la media cuadrática de los últimos `kWaveformPoints` samples (`voiceRms[]`), y de forma análoga se calcula un `sampleplayRms` a partir del buffer dedicado a Sampleplay (`getSampleplayWaveformSnapshot`). Ambos valores se derivan directamente de la señal de audio renderizada, sin depender de parámetros de módulo.
- En la sección de pintado de líneas radiales módulo→centro, se distingue entre módulos con barra de volumen explícita (Volume, Oscillator, Sampleplay, Loop, Input) y el resto. Para los primeros, la altura de la waveform sigue escalándose únicamente con su parámetro de nivel (`volume`, `gain`, `amp`), manteniendo la semántica de que la barra derecha controla visualmente el “volumen” del módulo.
- Para módulos que no tienen una barra de volumen real (por ejemplo, Filter, Delay, Modulator, WaveShaper, Output), la altura de la waveform radial se deriva ahora de la RMS del audio asociado a su voz (`voiceRms[voiceIndex]`). El valor RMS se normaliza frente a una senoide a nivel máximo (~0.707) y se clampa a `[0,1]`, de modo que cuando el módulo atenúa o realza la señal, la línea de sonido se hace más baja o más alta en proporción a la energía real que está saliendo por esa voz.
- Con esta combinación, los módulos con control de volumen dedicado siguen comunicando su nivel principalmente a través de la barra lateral y de la escala de waveform basada en parámetros, mientras que los módulos “sin barra de volumen” ajustan la altura de su waveform automáticamente según el nivel RMS del audio que procesan, cumpliendo el requisito de que la altura refleje el sonido correspondiente cuando no hay un control de volumen explícito.

### Límite de una conexión dinámica por módulo y priorización de filtros cercanos
- Se ha extendido el modelo de escena en `core/src/core/Scene.{h,cpp}` para imponer que cada módulo solo pueda tener **una conexión saliente dinámica (no-hardlink) hacia otros módulos**, permitiendo a la vez una conexión adicional no-hardlink hacia el master `Output` (-1). La estructura `Connection` ya distinguía conexiones marcadas como `is_hardlink`; ahora, en `Scene::AddConnection`, antes de insertar una nueva conexión no-hardlink **con `to_module_id != "-1"`** se comprueba si ya existe otra conexión saliente no-hardlink desde el mismo `from_module_id` hacia un destino distinto de `-1`. Si la hay, la petición se rechaza. Las conexiones de tipo hardlink no cuentan para este límite, y las rutas implícitas módulo→Output(-1) tampoco consumen ese “slot” dinámico, de modo que un Oscillator puede tener simultáneamente `Osc → FilterMásCercano` y `Osc → Output(-1)`.
- Los módulos de tipo `OutputModule` no se ven afectados en la práctica por esta restricción, ya que el modelo actual solo crea conexiones **hacia** Output (como destino) y nunca lo usa como origen de conexiones salientes dinámicas. En particular, las auto-conexiones `Delay → Output` generadas a partir de `<hardlink to="-1" />` en el loader siguen funcionando ya que son hardlinks y no consumen el único “slot” dinámico.
- En `tests/scene_tests.cpp` se ha añadido un caso de prueba que construye un `Scene` con un `OscillatorModule` y dos `FilterModule` y verifica que:
  - La primera conexión dinámica `osc1/out → filter1/in` se acepta correctamente.
  - Una segunda conexión dinámica `osc1/out → filter2/in` se rechaza por el límite de **una conexión no-hardlink saliente**.
  - Aun así, se pueden añadir dos conexiones adicionales marcadas como hardlink desde `osc1` a ambos filtros, coexistiendo sin problema con la conexión dinámica única.

### Auto-wiring de Oscillator al Filter más cercano y compatibilidad con Output
- Se ha modificado el loader de patches Reactable en `core/src/core/ReactableRtpLoader.cpp` para que, tras crear módulos y objetos y derivar las conexiones de tipo hardlink, recorra la escena buscando parejas `OscillatorModule`–`FilterModule` y auto-conecte cada oscilador al filtro **geométricamente más cercano**.
- Para ello se construye un mapa auxiliar `module_to_object` que asocia `module_id` con su `ObjectInstance` correspondiente (usando `logical_id`), y se recopilan todos los filtros presentes en la escena. Para cada osc se localiza su objeto en la mesa y se calcula la distancia al cuadrado a cada filtro mediante las coordenadas normalizadas `(x, y)` de `ObjectInstance`. Entre todos los filtros que además cumplen `osc->CanConnectTo(*filter)` se escoge el de menor distancia y se intenta crear una conexión `osc/out → filter/in` no-hardlink a través de `Scene::AddConnection`.
- El uso de `Scene::AddConnection` garantiza que se respeten automáticamente tanto el límite de **una conexión dinámica saliente por módulo** como la prohibición de conexiones con controladores globales (`is_global_controller`). Si un Oscillator ya tiene una conexión dinámica (por ejemplo por una futura interacción de UI), el auto-wiring al filtro más cercano se descartará, y viceversa.
- Después de este nuevo paso de auto-wiring Osc→Filter, se ejecuta la lógica existente que conecta automáticamente todos los módulos de audio compatibles con el master `Output` (-1). Gracias al nuevo límite per-módulo, la topología resultante en un patch con `Oscillator + 2 Filter + Output` es:
  - `Oscillator → FilterMásCercano` como única conexión dinámica saliente del oscilador.
  - Cada `FilterModule` se auto-conecta a `Output` con su propia conexión dinámica `Filter → -1`, ya que no tiene conexiones salientes previas.
  - El `Oscillator` ya no se conecta directamente a Output cuando existe al menos un filtro elegible, de forma que su ruta hacia el master pasa siempre por el filtro más cercano.

### Ajuste de tests para topologías más flexibles en default.rtp
- El test de `tests/scene_tests.cpp` que validaba la carga del patch por defecto `default.rtp` asumía que, tras el auto-wiring, existía siempre una conexión directa `Oscillator (46) → Output (-1)` y lo comprobaba de forma explícita. Dado que la nueva lógica puede preferir auto-conectar el Oscillator a un Filter intermedio (cuando estén presentes en el patch) y dejar que sea ese filtro quien se conecte al master, el test se ha relajado.
- Ahora el caso de prueba sigue comprobando la presencia de los módulos esperados (Output, Volume, Tempo, Oscillator) y la normalización correcta del parámetro `volume` del módulo `Volume`, pero en lugar de exigir una conexión **directa** `46 → -1`, simplemente verifica que `Scene::connections()` no esté vacío tras cargar `default.rtp`. Esto permite que el ruteo real se materialice como `Oscillator → Filter → Output` o como `Oscillator → Output` según el contenido del patch, sin romper la suite de tests al introducir nuevas heurísticas de auto-wiring.

### Activación del módulo Output (-1) como Master conectable
- Se ha extendido el loader de patches Reactable en `core/src/core/ReactableRtpLoader.cpp` para que, tras crear módulos y objetos a partir de los `<tangible>`, busque el tangible `Output` con id `-1` (master de la mesa) y lo trate como un módulo de salida real en el modelo de dominio (`OutputModule` con id "-1").
- Después de derivar las conexiones a partir de los `<hardlink>` de los `DelayModule`, el loader recorre todos los módulos de la escena y, para cada módulo de audio que pueda conectar hacia `Output` según `AudioModule::CanConnectTo` (es decir, que produzca audio y no sea un controlador global como `Volume`, `Tempo` o `Tonalizer`), intenta crear una `Connection` estándar `from=module_id/out` → `to="-1"/in` marcada como no-hardlink. `Scene::AddConnection` filtra duplicados, por lo que si ya existía un hardlink explícito hacia `-1` no se añade una segunda conexión redundante.
- De este modo, en cualquier patch `.rtp` que incluya el tangible `Output` con id `-1`, todos los módulos que emiten audio quedan explícitamente conectados al master en `Scene::connections`, preparando el grafo de ruteo para futuras fases del motor de audio sin exigir que el usuario manipule un tangible de Output visible.

### Preservación del comportamiento visual de la línea centro→módulo
- Para evitar que estas nuevas conexiones automáticas hacia `Output` alteren la lógica de las líneas radiales centro→módulo, se han ajustado los recorridos de conexiones en `MainComponent_Paint.cpp` y `MainComponent_Input.cpp` que calculan `objectsWithOutgoingActiveConnection` y detectan si un generador está "alimentando" otro módulo. Ahora se ignoran explícitamente las conexiones cuyo `to_module_id` es "-1" al construir ese conjunto.
- Gracias a este filtro, las líneas radiales desde los generadores al centro de la mesa siguen ocultándose únicamente cuando el generador está enviando señal a otro módulo visible (por ejemplo, `Oscillator → Filter`), pero no cuando solo existe la conexión implícita `Oscillator → Output`. Las auto-conexiones al master quedan, por tanto, invisibles a efectos de esta heurística y la UI conserva exactamente el mismo comportamiento visual que antes en lo referente a qué módulos muestran línea directa hacia el centro.
- La lógica de input que replica estas reglas para hit-testing y gestos de corte sobre las líneas centro→módulo también se ha actualizado para ignorar las conexiones con destino "-1", de forma que las auto-conexiones al master no se puedan seleccionar ni mutear por accidente a través de los gestos de corte pensados para líneas entre módulos visibles.

### Test de auto-conexión a Output en el modelo de escena
- En `tests/scene_tests.cpp` se ha añadido un caso de prueba que carga un patch mínimo con dos tangibles: un `Output` de id `-1` y un `Oscillator` de id `46`. Tras invocar `LoadReactablePatchFromString`, el test comprueba que la escena resultante contiene exactamente dos módulos, dos objetos y **una** conexión no-hardlink de `46/out` hacia `-1/in`.
- Este test complementa el ya existente que valida la creación de conexiones de tipo hardlink desde un `Delay` hacia `Output` a partir de etiquetas `<hardlink to="-1" />`, asegurando que ambos mecanismos coexisten correctamente (el loader no duplica conexiones cuando ya hay un hardlink y la auto-conexión solo añade rutas cuando no existían previamente).

### Redefinición del modelo de mute sólo a nivel de conexión
- Se ha simplificado el modelo de mute eliminando por completo el estado de mute por objeto y por módulo (`mutedObjects_` y `modulesWithPersistentMute_`) de `MainComponent`. A partir de ahora, `mutedConnections_` es la **única** fuente de verdad sobre qué rutas están silenciadas.
- La ruta al master se modela explícitamente como la conexión implícita módulo → Output (-1) que el loader crea para todos los módulos de audio no globales. Mutear la radial centro→módulo en la UI equivale a mutear esa conexión módulo→`-1` concreta dentro de `mutedConnections_`.
- En `MainComponent_Audio.cpp`:
  - El cálculo de `sampleplayOutputGain` ya no consulta `mutedObjects_`; en su lugar, considera silenciado el path global de Sampleplay cuando **todas** las conexiones Sampleplay → `-1` están muteadas en `mutedConnections_`. Si existe al menos un Sampleplay con ruta al master no muteada, el gain sigue al volumen global.
  - Para generadores, `srcMuted` se deriva ahora comprobando si todas las conexiones desde el módulo a Output (-1) están muteadas. Esto hace que mutear la radial sea exactamente lo mismo que cortar la salida de ese generador hacia el master.
  - El flag `connectionMuted` para la cadena generador → módulo aguas abajo se calcula únicamente a partir de `mutedConnections_` (se ha eliminado cualquier dependencia de mute persistente por módulo). El `chainMuted` final combina sólo el mute de origen (`srcMuted`) y el mute de la conexión a ese downstream.
  - `modulesWithActiveAudio_` se actualiza sin consultar estado de mute persistente: si la cadena genera audio (aunque acabe silenciada al master) se sigue usando para poder dibujar waveform, y sólo se omite la marca de “activo” en el módulo destino cuando la conexión está muteada.
- En `MainComponent_Paint.cpp`:
  - Las líneas radiales ya no consultan `mutedObjects_` ni `modulesWithPersistentMute_`. El estado visual de mute (línea continua vs discontinua, presencia de waveform) se deduce sólo de si la conexión implícita módulo → `-1` correspondiente está en `mutedConnections_`.
  - Las conexiones módulo→módulo usan exclusivamente `mutedConnections_` para decidir si se dibujan como activas (con waveform) o muteadas (línea discontinua / sin waveform), tanto en la parte central de la mesa como en gestos de hold/cut.
  - El color del cuerpo de los módulos (en la mesa y en el dock) se calcula ahora comprobando si su conexión módulo → `-1` está muteada: si todas las rutas al master están muteadas, el nodo se pinta con el esquema de “muteado”; si al menos una ruta al master está activa, se usa el esquema normal.
- En `MainComponent_Input.cpp`:
  - Los gestos de click-and-hold en líneas sólo mantienen un estado visual temporal (`activeConnectionHold_`) sin tocar el estado de mute persistente; al soltar el ratón se limpia el hold sin modificar `mutedConnections_`. Para líneas módulo→módulo, el mute efectivo durante el hold se aplica exclusivamente en `timerCallback()` comprobando `activeConnectionHold_`, sin insertar ni borrar claves en `mutedConnections_`.
  - Cortar una radial centro→módulo se interpreta como “toggle” sobre la conexión implícita módulo → `-1`: se localiza dicha conexión en `Scene::connections()` y se añade o elimina su clave en `mutedConnections_`.
  - Cortar una línea módulo→módulo sólo hace toggle del estado de mute de **esa** conexión (`makeConnectionKey(conn)`), sin marcar ni recordar mute a nivel de módulo aunque sea la única conexión saliente.
- Con este cambio, todas las decisiones de audio y UI relacionadas con mute se pueden razonar exclusivamente en términos de conexiones concretas (`Connection { from, to, ... }`), y el comportamiento se mantiene coherente entre cadena de audio (silencio) y representación visual (líneas y cuerpos atenuados / con waveform).

### Sincronización del estado de mute al des-silenciar la radial
- Se ha ajustado el manejo de gestos de corte sobre la radial centro→módulo en `MainComponent_Input.cpp` para cubrir un caso sutil en el que el estado de mute “persistente” de una única conexión módulo→módulo podía reaparecer de forma inesperada al reconectar módulos.
- Cuando el usuario corta una línea módulo→módulo que es la **única** conexión saliente activa de un módulo (ignorando la auto-conexión implícita al master), la lógica ya existente espelaba ese mute sobre la conexión módulo→Output (-1), de forma que, si más tarde se desconectaba el módulo destino (sacándolo del cono/área musical), el módulo seguía efectivamente silenciado al quedar solo la ruta al master.
- El nuevo comportamiento define que, si más tarde el usuario des-silencia explícitamente la radial (toggle sobre módulo→`-1`) en una situación en la que **no queda ninguna conexión módulo→módulo activa** desde ese módulo, entonces se interpreta que el usuario quiere restablecer el estado “no muteado” global del módulo como fuente.
- Para implementarlo, tras des-silenciar la conexión implícita módulo→`-1` se recorren todas las claves actualmente almacenadas en `mutedConnections_` y se eliminan aquellas cuyo prefijo coincide con `moduleId + ":"` (es decir, todas las rutas cuyo `from_module_id` es ese módulo, tanto al master como a otros módulos). Esto garantiza que cualquier estado de mute previo asociado al generador queda completamente borrado, incluso si las conexiones que lo originaron ya no están presentes en `Scene::connections()`.
- Con este ajuste, el flujo
  - Osc→Master,
  - Osc→Filter,
  - mute de Osc→Filter (que también mutea Osc→Master al ser la única conexión activa),
  - desplazamiento de Filter fuera del cono (queda sólo Osc→Master),
  - des-silenciado de Osc→Master,
  - reconexión Osc→Filter,
  vuelve a producir una línea Osc→Filter **no muteada**, ya que el des-silenciado explícito de la radial limpia todo el historial de mute asociado a ese Oscillator.

### Mute aguas abajo: Filter silenciado bloquea todos los generadores conectados
- Se ha corregido el caso en el que varios `OscillatorModule` alimentan un mismo `FilterModule` y el usuario silencia la radial de ese filtro (conexión `Filter -> "-1"`), pero se seguía escuchando el sonido directo de los osciladores.
- En el bucle de ruteo de generadores de `MainComponent_Audio.cpp`, tras seleccionar un `downstreamModule` (por ejemplo, un Filter), se calcula ahora explícitamente si ese módulo aguas abajo está completamente muteado hacia el master (`downstreamMutedToMaster`) comprobando sus conexiones `from=downstream.id()` → `to="-1"` en `mutedConnections_`.
- El flag `chainMuted` pasa a ser la disyunción de tres condiciones: `srcMuted` (mute en la radial del generador), `connectionMuted` (mute explícito en la conexión generador→módulo) y `downstreamMutedToMaster` (mute en la radial del módulo aguas abajo). Si cualquiera de ellas es cierta, el nivel de salida de la voz se fuerza a 0.
- Esto garantiza que en una configuración como `Osc1 → Filter`, `Osc2 → Filter`, `Filter → Master`, al silenciar la radial de Filter toda la cadena queda efectivamente en silencio: no se escucha ningún oscilador aunque sus propias radiales no estén muteadas individualmente, porque todo el audio debe atravesar el Filter para llegar al master.
- Para la capa visual, en cambio, se introduce un flag `visualChainMuted = srcMuted || connectionMuted` y se usa exclusivamente éste para rellenar `modulesWithActiveAudio_` y `moduleVoiceIndex_`. De este modo, un mute sólo en la radial del módulo aguas abajo (Filter→Master) **no** impide que la conexión Osc→Filter se dibuje con waveform: el usuario sigue viendo que los Oscillators envían audio al Filter, aunque el corte de la cadena se produzca en la salida del propio Filter hacia el master.

### Selección dinámica del Filter más cercano en runtime y audio por múltiples rutas (incluyendo hardlinks)
- En `MainComponent_Audio.cpp` se ha especializado la creación de conexiones dinámicas para los módulos de tipo generador (`ModuleType::kGenerator`). El bloque genérico de "Dynamic connection creation" sigue creando conexiones espaciales para el resto de módulos, pero ahora omite explícitamente cualquier par donde intervenga un generador. A continuación, una pasada específica recorre cada generador dentro del área musical, examina todos los módulos vecinos compatibles según `AudioModule::CanConnectTo`, respeta el cono geométrico `isConnectionGeometricallyActive` y selecciona como destino dinámico el módulo más cercano, **priorizando siempre los `FilterModule` frente a otros tipos**. Antes de añadir la nueva conexión `gen/out → dst/in` se eliminan las conexiones dinámicas previas salientes de ese generador (no-hardlink y distintas de `to="-1"`), de forma que se mantiene el invariante de "una sola conexión dinámica saliente" mientras el grafo se reconfigura automáticamente cuando el usuario mueve los tangibles.
- Esta misma lógica de selección dinámica se aplica tanto a las conexiones auto-generadas desde el loader (`ReactableRtpLoader`, que crea inicialmente `Osc → FilterMásCercano`) como a las conexiones creadas en runtime por disposición espacial: cuando un Filter sale del área musical o abandonan el cono del Oscillator, su conexión dinámica deja de ser candidata y en el siguiente tick el generador se reconecta, si es posible, al siguiente módulo compatible más cercano (típicamente otro `FilterModule`). Las conexiones de tipo hardlink (`is_hardlink=true`) nunca se tocan en esta pasada y pueden coexistir libremente con la ruta dinámica única.
- El ruteo de audio por generador en `MainComponent_Audio.cpp` también se ha reestructurado para recorrer **todas** las conexiones salientes desde cada generador (ignorando sólo las implícitas a Output `to="-1"`) y construir un vector de rutas `GeneratorRoute`. Cada ruta representa un módulo aguas abajo concreto (Filter, Sampleplay, Delay, etc.), respeta área musical, cono geométrico para dinámicas y estado de mute por conexión, y se traduce a una voz independiente en el `AudioEngine`. De este modo, si un Oscillator tiene a la vez una conexión dinámica `Osc → Filter1` y un hardlink `Osc → Filter2`, el audio se envía en paralelo por ambas cadenas (dos voces con su propio filtro/Q), cumpliendo el requisito de que "si existe conexión (dinámica o hardlink), el audio se envía por ella". El cálculo de mute por cadena (`srcMuted`, mute de conexión y mute en la radial del módulo destino) y la configuración de filtros por voz se aplican ahora por ruta individual, manteniendo la semántica previa pero extendida a múltiples destinos simultáneos.
 - El ruteo de audio por generador en `MainComponent_Audio.cpp` también se ha reestructurado para recorrer **todas** las conexiones salientes desde cada generador (ignorando sólo las implícitas a Output `to="-1"`) y construir un vector de rutas `GeneratorRoute`. Cada ruta representa un módulo aguas abajo concreto (Filter, Sampleplay, Delay, etc.), respeta área musical, cono geométrico para dinámicas y estado de mute por conexión, y se traduce a una voz independiente en el `AudioEngine`. De este modo, si un Oscillator tiene a la vez una conexión dinámica `Osc → Filter1` y uno o varios hardlinks `Osc → Filter2`, el audio se envía en paralelo por todas las cadenas (una voz por ruta con su propio filtro/Q), cumpliendo el requisito de que "si existe conexión (dinámica o hardlink), el audio se envía por ella". El cálculo de mute por cadena (`srcMuted`, mute de conexión y mute en la radial del módulo destino) y la configuración de filtros por voz se aplican ahora por ruta individual, manteniendo la semántica previa pero extendida a múltiples destinos simultáneos.
 - Para el resto de módulos no generadores, la heurística genérica de "Dynamic connection creation" ya no crea conexiones dinámicas de forma codiciosa para **todas** las parejas posibles. En su lugar, construye una tabla interna de puntuación (`bestByFrom`) donde cada módulo origen acumula sólo su candidato mejor valorado: para cada par de objetos dentro del área musical que cumpla `CanConnectTo` y pase el cono geométrico, se asigna una puntuación inversamente proporcional a la distancia entre ambos tangibles (módulos más cercanos → puntuación más alta). Tras evaluar todas las parejas, únicamente se materializa la conexión con mejor puntuación por módulo origen llamando a `Scene::AddConnection`, dejando que esta última aplique las invariantes globales (máx. una conexión dinámica saliente, no duplicar conexiones, exclusión explícita de rutas hacia el Output `-1`, etc.). Esto hace que, en escenas con varios módulos elegibles alrededor de un mismo origen, la conexión dinámica resultante siempre favorezca al vecino más cercano dentro del cono.

### Fuentes de ruteo dinámico ampliadas (no solo generadores)
- En `MainComponent_Audio.cpp`, la pasada específica de "Generator dynamic connections" que reescritía la única conexión dinámica saliente de cada generador para apuntar siempre al módulo compatible más cercano (priorizando `FilterModule`) se ha generalizado para que pueda actuar sobre **cualquier módulo que no sea de tipo `ModuleType::kSettings`**.
- En lugar de comprobar explícitamente `srcModule->type() == ModuleType::kGenerator` o casos especiales como `SampleplayModule`, la condición de entrada de esta pasada filtra únicamente los módulos de ajustes globales (`kSettings`) y deja que el resto de tipos (generadores, módulos de audio, FX, etc.) puedan participar en el ruteo dinámico siempre que `AudioModule::CanConnectTo` lo permita.
- El bucle sigue calculando, para cada módulo origen con tangible dentro del área musical, el mejor destino aguas abajo (`bestModule`) entre todos los objetos vecinos que cumplan: estar dentro del área musical, no ser el Output `"-1"` ni un controlador global (`is_global_controller()`), respetar `CanConnectTo` y el cono geométrico `isConnectionGeometricallyActive`. Entre varios candidatos, se priorizan primero los de tipo `kFilter` y, a igualdad de tipo, el de menor distancia.
- Una vez elegido `bestModule`, se consultan las conexiones no-hardlink existentes desde ese origen (excluyendo rutas a `"-1"`) a través de `dynamicByFrom`. Si ya existe una conexión dinámica estándar `out → in` hacia `bestModule`, se conserva tal cual; en caso contrario, se eliminan todas las conexiones dinámicas salientes previas de ese módulo origen y se crea una nueva `Connection { from = srcModule->id(), from_port_name = "out", to = bestModuleId, to_port_name = "in", is_hardlink = false }` usando `Scene::AddConnection`.
- Al actuar solo sobre conexiones no-hardlink y dejar intactas las hardlinks, esta ampliación mantiene el invariante de "una sola conexión dinámica saliente" por módulo (más la posible ruta extra hacia Output `-1`) pero permite que módulos como `Sampleplay` o ciertos FX sigan las mismas reglas de ruteo espacial que los generadores clásicos, siempre que sus políticas de conexión las consideren válidas.

### Ocultar la radial de Sampleplay cuando alimenta otros módulos
- En `MainComponent_Paint.cpp` se ha ajustado la heurística que decide cuándo dibujar la línea radial centro→módulo para que `SampleplayModule` se comporte igual que los generadores clásicos (`ModuleType::kGenerator`) a efectos visuales.
- Antes, solo los módulos de tipo generador ocultaban su radial cuando tenían una conexión saliente activa hacia otro módulo (por ejemplo, `Oscillator → Filter`); los módulos de tipo audio como `Sampleplay` seguían mostrando siempre su línea directa al master incluso cuando alimentaban un `Filter`, lo que producía dos líneas de audio visibles desde el mismo módulo: `Sampleplay → Master` y `Sampleplay → Filter`.
- Ahora se introduce un flag `isGeneratorLike` que es verdadero tanto para módulos `ModuleType::kGenerator` como para `SampleplayModule`. Cuando `isGeneratorLike` es cierto y el objeto correspondiente aparece en `objectsWithOutgoingActiveConnection` (es decir, existe al menos una conexión de audio activa hacia otro módulo dentro del área musical), la radial centro→módulo se omite en el pintado.
- El resultado es que, en configuraciones `Sampleplay → Filter → Master`, la UI muestra una única ruta visual desde Sampleplay: la conexión `Sampleplay → Filter` con waveform propio (alimentada desde el buffer global de Sampleplay) y la radial `Filter → Master`. La línea directa `Sampleplay → Master` deja de dibujarse mientras exista la conexión activa al filtro, cumpliendo la regla de "una sola conexión dinámica visible" y evitando la confusión de ver dos soundwaves simultáneos saliendo del mismo Sampleplay.

### Filtro aplicado al path global de Sampleplay y visuales coherentes con Filter
- Se ha extendido `AudioEngine` (`AudioEngine.h/.cpp`) para que el path estéreo de Sampleplay (SoundFont) pueda pasar por un filtro dedicado basado en `juce::dsp::StateVariableTPTFilter`. Se añaden dos instancias mono `sampleplayFilterL_`/`sampleplayFilterR_` y un pequeño estado atómico (`sampleplayFilterMode_`, `sampleplayFilterCutoffHz_`, `sampleplayFilterQ_`) que controlan tipo, frecuencia de corte y resonancia de este filtro global.
- El callback `audioDeviceIOCallbackWithContext` ahora, tras aplicar el `sampleplayOutputGain`, puede procesar los buffers `sampleplayLeft_`/`sampleplayRight_` a través de estos filtros cuando `sampleplayFilterMode_ != 0`, de manera que el audio de Sampleplay se ve afectado por el filtro antes de mezclarse con las voces de oscilador y antes de actualizar los historiales de waveform y los taps por conexión de tipo `kSampleplay`.
- Se ha añadido el método público `AudioEngine::setSampleplayFilter(int mode, double cutoffHz, float q)` que clampa los parámetros, respeta Nyquist (cutoff < fs/2) y configura tipo/cutoff/Q en ambos filtros de Sampleplay. La API refleja la de `setVoiceFilter` para generadores: modo 0 = bypass, 1 = low-pass, 2 = band-pass, 3 = high-pass.
- En `MainComponent_Audio.cpp`, dentro de `timerCallback`, tras calcular `sampleplayOutputGain` y reconstruir el grafo de audio, se escanean los `audio_edges()` en busca de conexiones `Sampleplay → Filter` activas (módulos dentro del área musical, respeta cono geométrico para dinámicas y sin mute de conexión). Entre todas las parejas Sampleplay–Filter elegibles se elige el filtro más cercano en términos de distancia en la mesa y se mapean sus parámetros (`freq`, `q`, `mode`) a una llamada a `audioEngine_.setSampleplayFilter(...)`. Si no hay ningún filtro elegible, el modo se deja en 0 (bypass).
- Con este cambio, siempre que exista una conexión `Sampleplay → Filter` activa, el audio del SoundFont se procesa a través del filtro correspondiente antes de llegar al master, cumpliendo la regla de que "el efecto Filtro debe aplicarse siempre que el módulo esté conectado" incluso en escenas sin osciladores.
- En la capa de pintado (`MainComponent_Paint.cpp`), las conexiones que implican Sampleplay dejan de depender de `modulesWithActiveAudio_` para decidir si llevan audio: `audioConn` se considera verdadero para conexiones Sampleplay siempre que no estén muteadas, lo que garantiza que la línea `Sampleplay → Filter` muestre waveform mientras haya señal en el buffer de Sampleplay.
- Además, para las radiales de módulos `Filter`, se detecta si el filtro está siendo alimentado directamente por un Sampleplay mediante una conexión de audio activa `Sampleplay → Filter` (dentro del área musical, respetando cono y no muteada). En ese caso, y cuando hay energía en `sampleplayWaveform`, la radial `Filter → Master` reutiliza la waveform de Sampleplay para dibujar su soundwave, de modo que en una cadena `Sampleplay → Filter → Master` sin osciladores se ven ondas tanto en la conexión Sampleplay→Filter como en la radial del Filter hacia el master, alineadas con el audio realmente procesado por el filtro.

### Waveform de Sampleplay unificada vía taps por conexión
- Se ha simplificado la gestión de historiales de waveform de Sampleplay en `AudioEngine` eliminando los buffers globales `sampleplayWaveformBuffer_` y `sampleplayFilteredWaveformBuffer_` y sus helpers `getSampleplayWaveformSnapshot(...)` / `getSampleplayFilteredWaveformSnapshot(...)`. A partir de ahora, la única fuente de verdad para las waveforms de Sampleplay son los taps por conexión (`connectionWaveformBuffers_` con `ConnectionTapSourceKind::kSampleplay`), alimentados directamente desde la señal mono pre‑filtro (`rawSampleplayL`).
- El callback de audio sigue escribiendo en los taps de tipo `kSampleplay` para todas las conexiones de audio que involucren a Sampleplay (por ejemplo `Sampleplay → Master` y `Sampleplay → Filter`), pero deja de mantener un segundo historial global duplicado. Esto reduce complejidad en el motor y evita divergencias entre buffers al depurar problemas visuales.
- En `MainComponent_Paint.cpp`, tanto las conexiones que involucran Sampleplay como las radiales afectadas pasan a leer **siempre** desde `audioEngine_.getConnectionWaveformSnapshot(connKey, ...)`. En las ramas de pintado de conexiones se ha eliminado el camino especial que copiaba `sampleplayWaveformRaw` a un buffer temporal: ahora todas las conexiones de audio, incluidas las de Sampleplay, normalizan su waveform a partir del snapshot por conexión y solo cambian el modo `tiled` (no periodo repetido para Sampleplay).
- Para las radiales se ha alineado la lógica con estas taps: las radiales `Sampleplay → Master` buscan la conexión de audio `Sampleplay → "-1"` no muteada y usan su snapshot como waveform; las radiales de `Filter` con Sampleplay aguas arriba reutilizan la misma tap de la conexión `Sampleplay → Filter`. De este modo, en una cadena `Sampleplay → Master` y `Sampleplay → Filter → Master` todas las líneas que representan la señal de Sampleplay comparten la misma waveform subyacente (pre‑filtro), eliminando el efecto anterior de ver dos soundwaves distintas para rutas lógicamente equivalentes.
- Esta unificación deja el filtro global de Sampleplay (`setSampleplayFilter`) actuando solo sobre el audio real mezclado (a través de `sampleplayFilterL_/R_`), sin mantener un historial de waveform separado para la señal ya filtrada. Si en el futuro se necesita visualizar explícitamente la salida filtrada, se hará añadiendo taps específicos a las conexiones relevantes en lugar de introducir buffers globales adicionales.

### Grafo lógico de audio (`AudioGraph`) – Fase 2 (parcial)
- Se ha introducido la clase `rectai::AudioGraph` en `core/src/core/AudioGraph.{h,cpp}` como representación lógica del grafo de audio derivado de `Scene`. El grafo modela cada `AudioModule` como un nodo (`Node` con `id`, `ModuleType` y flags de capacidades `produces_audio`/`consumes_audio`/`produces_midi`/`consumes_midi`/`is_global_controller`) y cada `Connection` como una arista dirigida (`Edge` con ids de módulo y nombres de puerto, flag `is_hardlink` y un `PortSignalKind` efectivo).
- La función `AudioGraph::RebuildFromScene(const Scene&)` recorre `Scene::modules()` para poblar el mapa interno de nodos (`nodes_`) y `Scene::connections()` para poblar el vector de aristas (`edges_`). El tipo de señal (`signal_kind`) se infiere en primer lugar a partir de los puertos del módulo origen (buscando coincidencia de `from_port_name` en `output_ports()`), y en segundo lugar de los puertos del módulo destino (`to_port_name` en `input_ports()`). Si no se encuentra coincidencia pero el módulo origen produce audio (`produces_audio()`), se asume `PortSignalKind::kAudio` como valor por defecto conservador.
- Se ha añadido el helper `std::vector<Edge> AudioGraph::audio_edges() const` que filtra `edges_` devolviendo solo las aristas cuyo `signal_kind == PortSignalKind::kAudio`. Este método servirá como base para futuras fases donde se necesiten recorridos rápidos sólo sobre el subgrafo de audio (por ejemplo, para crear taps o buffers por conexión en el motor de audio).
- `MainComponent` incluye ahora un miembro `rectai::AudioGraph audioGraph_` y llama a `audioGraph_.RebuildFromScene(scene_)` al inicio de `timerCallback()`. Con ello se mantiene un grafo lógico de audio siempre sincronizado con la `Scene`, listo para ser consultado por capas posteriores (motor de audio y/o lógica de visualización) sin necesidad de re-derivar nodos y aristas a partir de los módulos y conexiones crudos.
- Como parte de este cambio se han traducido al inglés todos los comentarios de los nuevos archivos de grafo (`AudioGraph.h/.cpp`) y se han unificado también algunos comentarios existentes en `MainComponent.h` relacionados con mute por conexión y fuentes visuales, manteniendo la convención del proyecto de código y comentarios en inglés mientras la documentación permanece en español.

### Buffers físicos por conexión en el motor de audio – Fase 3 (primer paso)
- Se ha extendido `AudioEngine` (`core/src/AudioEngine.{h,cpp}`) con una infraestructura básica de **taps por conexión**: se introduce la constante `kMaxConnectionTaps` (64 taps simultáneos), una estructura `ConnectionTap` interna y un array `connectionWaveformBuffers_[kMaxConnectionTaps][kWaveformHistorySize]` que mantiene un historial mono de waveform para cada conexión de audio que se desee monitorizar. Todos estos historiales comparten el índice global `waveformWriteIndex_`, de modo que quedan temporalmente alineados con el mix global y los buffers por voz ya existentes.
- La API pública del motor incorpora ahora:
  - `enum class ConnectionTapSourceKind { kNone, kVoicePre, kVoicePost, kSampleplay }`, que modela el tipo de fuente de señal de bajo nivel que se observa en cada tap.
  - `clearAllConnectionWaveformTaps()`, que borra la configuración de taps activos y resetea sus metadatos sin tocar el historial global.
  - `configureConnectionWaveformTap(const std::string& key, ConnectionTapSourceKind kind, int voiceIndex)`, que asocia una clave lógica de conexión (la misma que usa la UI/Scene) a una fuente de señal concreta: pre-filtro de una voz (`VoicePre`), post-filtro (`VoicePost`) o la ruta mono de Sampleplay (`Sampleplay`). Las llamadas repetidas con la misma clave actualizan la configuración del tap; claves nuevas van reservando entradas hasta un máximo de `kMaxConnectionTaps`.
  - `getConnectionWaveformSnapshot(const std::string& key, float* dst, int numPoints, double windowSeconds)`, que devuelve un snapshot downsampleado del historial de waveform para la conexión indicada, reutilizando la misma lógica de ventana y muestreo que `getWaveformSnapshot` y las APIs por voz. Si no hay tap configurado para esa clave o todavía no hay historia suficiente, el buffer de destino se rellena con ceros.
- En el callback de audio (`audioDeviceIOCallbackWithContext`) se actualizan ahora estos taps en tiempo real y sin locks adicionales: al comienzo del callback se captura `tapCount = min(numConnectionTaps_, kMaxConnectionTaps)` y, para cada muestra, se recorre la lista de taps activos. Para taps tipo `VoicePre`/`VoicePost` se escribe en el buffer de conexión correspondiente justo después de calcular, por voz, las señales `raw` (pre-filtro) y `s` (post-filtro); para taps tipo `Sampleplay` se escribe la muestra mono procedente del path de SoundFont (`sampleplayLeft_`) en el mismo índice `bufIndex` en el que se actualiza `sampleplayWaveformBuffer_`. De este modo, cada conexión monitorizada mantiene su propio historial sin que el hilo de audio tenga que consultar estructuras de alto nivel (`Scene`, `AudioGraph` o maps de C++).
- `MainComponent` conecta esta nueva infraestructura con la abstracción ya existente `ConnectionVisualSource` (Fase 1): al final de `timerCallback`, justo después de llamar a `updateConnectionVisualSources()`, se invoca `audioEngine_.clearAllConnectionWaveformTaps()` y se recorre `Scene::connections()`. Para cada conexión de audio con una `ConnectionVisualSource` válida:
  - Si `kind == kSampleplay`, se configura un tap `ConnectionTapSourceKind::kSampleplay` para esa clave, sin necesidad de índice de voz.
  - Si `kind == kVoicePre` o `kVoicePost` y `voiceIndex` está en rango, se configura un tap `kVoicePre`/`kVoicePost` asociado a ese índice de voz.
  - Las conexiones no audio o sin `ConnectionVisualSource` se ignoran, de forma que sólo las rutas de audio reales consumen taps.
- La capa de pintado de conexiones en `MainComponent_Paint.cpp` deja de leer directamente buffers por voz (`voiceWaveformsPre`/`voiceWaveformsPost`) o el buffer global de Sampleplay para decidir qué waveform mostrar en cada línea. En su lugar, para cada conexión de audio (dinámica, hardlink o en estado de “hold”) se llama a `audioEngine_.getConnectionWaveformSnapshot(connKey, ...)` y, si la señal resultante tiene energía (`maxAbs > 1e-4`), se calcula una normalización simple (`1/maxAbs`) y un periodo aproximado usando el mismo estimador de autocorrelación que ya se usaba para las voces. Con estos datos se dibuja la waveform a lo largo de la línea (o del segmento hasta el punto de split en caso de hold), dejando como fallback un simple trazo recto cuando no hay historial válido para esa conexión.
- Este primer paso de la **Fase 3** no cambia aún la estructura DSP interna (se sigue trabajando con voces de oscilador + filtro y una ruta global de Sampleplay), pero consigue que la visualización de cada conexión dependa de un buffer de waveform **propio**, gestionado en el motor, alineando el comportamiento real con el diseño del documento `research/audio_graph_connection_buffers.md` y preparando el terreno para fases posteriores donde el grafo de audio (`AudioGraph`) pueda dirigir taps aún más finos sobre cadenas más complejas.

### Integración inicial de AudioGraph dentro de AudioEngine
- `AudioEngine` ahora posee un grafo lógico de audio interno (`std::unique_ptr<rectai::AudioGraph> audioGraph_`) y expone dos métodos públicos: `rebuildAudioGraphFromScene(const rectai::Scene&)`, que reconstruye el grafo llamando a `AudioGraph::RebuildFromScene(scene)`, y `audioGraph() const`, que devuelve una referencia constante al grafo actual. El grafo sigue el diseño de `core/src/core/AudioGraph.{h,cpp}`: nodos por módulo (`Node`) y aristas (`Edge`) anotadas con `PortSignalKind` y flag `is_hardlink`.
- En `MainComponent_Audio.cpp`, tras actualizar hardlinks y conexiones dinámicas en `timerCallback()`, se llama ahora a `audioEngine_.rebuildAudioGraphFromScene(scene_)` para que en cada tick el motor mantenga un snapshot actualizado del grafo lógico derivado de la `Scene`. Esto permite que la lógica audio-side que necesita razonar sobre el ruteo consulte un grafo ya procesado en lugar de re-iterar manualmente sobre `Scene::modules()` y `Scene::connections()`.
- La configuración de taps por conexión introducida en la Fase 3 se ha adaptado para usar este grafo interno como fuente de verdad sobre qué conexiones llevan audio: en lugar de recorrer directamente `Scene::connections()` para decidir qué claves configurar, `MainComponent_Audio` llama a `audioEngine_.audioGraph().audio_edges()` y recorre exclusivamente las aristas cuyo `signal_kind == PortSignalKind::kAudio`. Para cada `Edge` se construye un `rectai::Connection` temporal con `from_module_id`, `from_port_name`, `to_module_id`, `to_port_name` e `is_hardlink`, se obtiene su clave estable con `makeConnectionKey` y se consulta `connectionVisualSources_` para saber si debe observar `VoicePre`, `VoicePost` o `Sampleplay` y con qué `voiceIndex`.
- Sobre ese mismo conjunto de aristas de audio (`audio_edges()`), `timerCallback()` ha dejado de depender de `Scene::connections()` para varias decisiones clave de ruteo:
  - El cálculo de `sampleplayOutputGain` y el muteo efectivo de Sampleplay hacia el master se basan ahora en las aristas con `from_module_id == Sampleplay` y `to_module_id == "-1"`, cruzadas con `mutedConnections_` a través de `makeConnectionKey`.
  - La detección de si un generador está muteado en origen (`srcMuted`) usa las mismas aristas de audio hacia `"-1"` del propio generador, en vez de inspeccionar directamente las conexiones de la escena.
  - La construcción de rutas aguas abajo por generador (qué módulos recibe cada Oscillator: Filters, FX, etc.) itera sobre `audio_edges()` filtrando por `from_module_id == generatorId` y `to_module_id != "-1"`, aplicando después los mismos predicados espaciales (área musical + cono geométrico para conexiones dinámicas) y de mute que antes, pero sin depender ya de `Scene::connections()`.
  - El chequeo de si un módulo downstream está efectivamente muteado hacia el master (`downstreamMutedToMaster`) también utiliza `audio_edges()` para localizar sus conexiones a `"-1"`, manteniendo la misma semántica que la versión previa basada en `Scene::connections()`.
- Adicionalmente, la lógica del Sequencer en `MainComponent_Audio.cpp` se ha migrado para usar el mismo `AudioGraph` como representación de las rutas "lógicas" de pasos:
  - Dentro de `timerCallback()`, la lambda `runSequencerStep` deja de recorrer `Scene::connections()` y pasa a usar el vector completo de aristas del grafo (`audioEngine_.audioGraph().edges()`) para localizar destinos aguas abajo de cada `SequencerModule` (Oscillator/Sampleplay), aplicando las mismas restricciones espaciales (área musical + cono geométrico para conexiones no-hardlink) y de mute a nivel de conexión (`mutedConnections_` via `makeConnectionKey`).
  - Cuando un paso está desactivado y `sequencerControlsVolume_` es verdadero, el muteo explícito de osciladores conectados también se calcula a partir de `edges()`, identificando módulos destino de tipo `OscillatorModule` en lugar de inspeccionar las conexiones de la `Scene`.
  - El chequeo de si un módulo Sampleplay aguas abajo está efectivamente muteado hacia el master dentro de `runSequencerStep` usa ahora `audio_edges()` para buscar conexiones Sampleplay → Output (`"-1"`), alineándose con la semántica usada en el cálculo de `sampleplayOutputGain` y en `triggerSampleplayNotesOnBeat`.
  - La propia función `triggerSampleplayNotesOnBeat` ha sido actualizada para apoyarse en `audioEngine_.audioGraph().audio_edges()` al decidir si un módulo Sampleplay está "ruteado y no muteado" hacia el master antes de disparar una nota sincronizada con el beat, de forma que toda la lógica de gating de Sampleplay a Output se apoya en el grafo en lugar de en `Scene::connections()`.
- Con este cambio, la lista de conexiones candidatas a tener buffer propio por conexión, el ruteo efectivo de generadores **y** las rutas lógicas usadas por el Sequencer y Sampleplay comparten la misma fuente de verdad (`AudioGraph`): el motor deja de tener lógica paralela sobre `Scene::connections()` y pasa a usar el grafo de audio interno como representación canónica del subgrafo de audio, cumpliendo mejor el objetivo de que "todo pase por AudioGraph" sin alterar todavía la ruta DSP principal.

### Implementación inicial del Loop Module (audio y UI)
- Se ha extendido `AudioEngine` (`core/src/AudioEngine.{h,cpp}`) con una infraestructura específica para módulos de tipo `Loop`, basada en dos estructuras nuevas: `LoopSample` (buffer estéreo intercalado, número de frames, sample rate de origen y metadatos de compás en beats) y `LoopInstance` (vector de hasta 4 `LoopSample` por módulo, posiciones de lectura por slot, índice seleccionado atómico y ganancia atómica por módulo).
- El motor incorpora ahora un `juce::AudioFormatManager` dedicado (`loopFormatManager_`) y los métodos públicos `loadLoopSampleFromFile`, `setLoopModuleParams` y `setLoopGlobalTempo`. El primero decodifica archivos de audio (WAV, FLAC, Ogg, Opus) desde rutas absolutas usando los readers de JUCE, normaliza el audio a un buffer estéreo `float` intercalado y lo almacena en el slot indicado de `LoopInstance`; el segundo actualiza, sin reiniciar la fase, el índice de slot activo (0–3) y el gain lineal del módulo; el tercero fija un BPM global que se usa para ajustar la velocidad de reproducción de los loops.
- En `audioDeviceIOCallbackWithContext` se ha integrado el mezclado de loops junto al path de Sampleplay y las voces de oscilador. En cada tick de audio se toma un snapshot lock‑free de los `LoopInstance` activos y, por cada módulo Loop, se recorre el slot seleccionado interpolando linealmente entre frames contiguos del buffer estéreo. El avance de fase por muestra se calcula a partir de la relación entre sample rate de origen y del dispositivo y, cuando se dispone del número de beats de la muestra y del BPM global, se escala adicionalmente para que la duración temporal del loop se adapte al tempo (`step *= rate`), aceptando los cambios de pitch inherentes al time‑stretching por resampleo.
- El gesto de mute en las conexiones no detiene la reproducción de los loops: las posiciones de lectura de cada `LoopInstance` avanzan continuamente en el hilo de audio independientemente de la ganancia, y `setLoopModuleParams` nunca resetea dichas posiciones. El mute y el volumen global sólo afectan a cuánto se suma el loop al mix final, no a su fase interna, cumpliendo el requisito de que silenciar la línea de audio no pause el loop.
- En `MainComponent` se ha añadido un mapa `loopLabelLastChangeSeconds_` y el helper `markLoopSampleLabelActive` para controlar la visibilidad de la etiqueta de nombre de archivo asociada a cada módulo Loop. En el constructor de `MainComponent` se ha introducido una lambda `loadLoopSamples` que recorre los `LoopModule` definidos en la `Scene`, ordena sus `LoopDefinition` por campo `order` y carga hasta 4 muestras por módulo desde `com.reactable/Samples` (`Samples/<filename>`), invocando `audioEngine_.loadLoopSampleFromFile` con el número de beats de cada loop.
- En `MainComponent_Audio.cpp`, dentro de `timerCallback`, se propaga el BPM global actual al motor mediante `audioEngine_.setLoopGlobalTempo(bpm_)` y, para cada `LoopModule` dentro del área musical, se calcula el índice de slot activo y el gain efectivo. El índice se deriva del parámetro normalizado `"sample"` (mapeado a 0–3), mientras que el gain se obtiene a partir de `"amp"` (0–1) convertido a dB y combinado con el volumen global. El resultado se fuerza a 0 cuando todas las conexiones Loop→Output(-1) están muteadas en `mutedConnections_`, pero la reproducción interna del loop continúa. Los módulos Loop con gain efectivo > 0 se añaden a `modulesWithActiveAudio_` para que sus líneas de audio muestren waveform.
- La UI de los módulos Loop se ha especializado en `MainComponent_Paint.cpp`: el control lateral izquierdo deja de usar el parámetro `"freq"` y pasa a interpretar `"sample"` como valor de control. Visualmente, la barra `Freq` se representa ahora como un arco segmentado en 4 tramos verticales, cada uno asociado a un slot de loop; el segmento activo se dibuja con mayor opacidad y un pequeño triángulo indicador aparece a la izquierda alineado con el centro del segmento seleccionado. A la derecha del nodo, cuando hay un loop seleccionado, se pinta una etiqueta de texto con el nombre de archivo (basename) del sample activo, visible con opacidad completa durante 5 segundos desde el último cambio y desvaneciéndose linealmente en los 0.5 segundos siguientes en función de `loopLabelLastChangeSeconds_`.
- En `MainComponent_Input.cpp` el control lateral izquierdo se ha habilitado también para módulos Loop: al hacer click sobre la barra `Freq` de un Loop se calcula el segmento (0–3) en función de la posición vertical del cursor, se fija el parámetro `"sample"` al centro de ese segmento (`(i + 0.5) / 4.0`) y se llama a `markLoopSampleLabelActive` para reiniciar el temporizador de la etiqueta. El comportamiento de la barra derecha sigue mapeando `"amp"` a la ganancia del módulo Loop, reutilizando la misma interacción que en `Sampleplay`.
- Adicionalmente, en `MainComponent_Input.cpp` se ha consolidado la lógica de la rueda de ratón sobre módulos Tempo y Loop en un único bloque: se reutiliza el mismo radio de detección e inspección de objetos/módulos y, en función del tipo concreto, se aplica la acción correspondiente (Tempo: ajuste fino de BPM en pasos de ±1 o ±5 con SHIFT; Loop: avance/retroceso cíclico por los cuatro slots de sample actualizando el parámetro normalizado `"sample"` y llamando a `markLoopSampleLabelActive`). Este gesto tiene prioridad sobre el scroll del dock siempre que el cursor esté sobre el círculo de uno de estos módulos en la mesa.
- Con este conjunto de cambios, los módulos `Loop` pasan de ser entidades solo de modelo a estar completamente integrados en el motor de audio y en la UI: pueden cargar hasta 4 muestras desde disco, reproducirlas en loop con sincronización opcional al BPM global, controlarse desde los arcos laterales (selección discreta de slot y volumen) y mostrar el nombre del loop activo en pantalla con una animación de aparición y fade out pensada para depuración y feedback al usuario.
