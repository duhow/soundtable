## 2025-12-16

### Suavizado de ataque en la envolvente de Oscillator para evitar clicks
- Tras ajustar la lógica de duración/decay de la envolvente por voz en `AudioEngine` para respetar `duration` (modo one-shot), se detectaron pequeños "clicks" audibles al inicio de cada nota del Oscillator cuando el `attack` del `<envelope>` era 0 ms (caso típico del Oscillator 47 en `Loopdemo.rtp`).
- El origen del artefacto es el salto brusco de amplitud cuando una nueva nota reinicia la envolvente desde 0 a un nivel alto en un solo sample: aunque la fase de la onda del oscilador es continua, la rampa de ataque instantánea genera un escalón en la envolvente que se percibe como un transitorio de banda ancha.
- Para mitigarlo sin cambiar perceptiblemente la sensación de ataque instantáneo, se ha introducido en `AudioEngine` un **ataque mínimo** para las envolventes de voz de Oscillator: al calcular `attackSeconds` a partir de `attackMs`, si el resultado es `<= 0` se sustituye por un pequeño valor fijo `kMinAttackSeconds = 0.0005` (≈0.5 ms). Esto se aplica tanto al modo one-shot (governado por `duration`) como al modo AR clásico.
- Con este ajuste, los patches que declaran `attack="0"` siguen sonando con un ataque prácticamente inmediato desde el punto de vista musical, pero el primer puñado de samples de la envolvente se suaviza lo suficiente como para eliminar los clicks al inicio de cada nota cuando el `Sequencer` dispara pasos densos sobre el Oscillator.

### Reducción de jitter en el disparo de pasos del Sequencer
- Aunque el índice de step de audio del `Sequencer` ya se calculaba a partir del transporte continuo en beats del motor de audio (`audioEngine_.transportBeats()`), los cambios de step se detectaban únicamente en `MainComponent::timerCallback`, que se ejecutaba a 120 Hz. Esto introduce una cuantización temporal de hasta ≈8.3 ms entre el instante ideal del beat y el tick del timer en el que realmente se llama a `runSequencerStep`, produciendo una ligera sensación de notas adelantadas/atrasadas.
- Para reducir este jitter sin mover todavía la lógica del Sequencer al hilo de audio, se ha incrementado la frecuencia del timer de `MainComponent` de 120 Hz a 240 Hz (`startTimerHz(240)`), manteniendo la misma integración de beats (`transportBeats_ + beatPhase_`) pero consultándola con el doble de resolución.
- A 240 Hz, el error máximo entre el instante real del beat en el motor de audio y el tick de `timerCallback` que dispara el siguiente step se reduce a ≈4.2 ms, lo que hace que el patrón de notas de los Oscillators conectados al Sequencer suene más estable en el tiempo y con menor sensación de acelerones/frenazos puntuales.
- Además, el avance de steps dentro de `MainComponent_Audio::timerCallback` dejaba caer pasos cuando el timer se retrasaba más de una semicorchea: el índice de step se derivaba directamente como `newAudioStep = floor(stepPhase) % NumSteps` y sólo se ejecutaba `runSequencerStep` cuando `newAudioStep != sequencerAudioStep_`, de modo que, si el transporte cruzaba dos o más límites de step entre dos ticks del timer, sólo se disparaba el último y los intermedios se perdían, produciendo irregularidades audibles (patrones que a veces suenan más “lentos” o “rápidos” de lo esperado).
- Para corregirlo, se ha introducido en `MainComponent` un contador absoluto de steps de audio (`sequencerAudioStepCounter_`, `int64_t`) que representa cuántas semicorcheas han transcurrido desde el inicio del transporte. En cada `timerCallback` se calcula el nuevo contador ideal como `newStepCounter = floor( (transportBeats_ + beatPhase_) / beatsPerStep )` y, si `newStepCounter > sequencerAudioStepCounter_`, se ejecuta un bucle `for` que llama a `runSequencerStep(stepIndex)` para **cada** step intermedio en el rango `[old+1, new]`, usando `stepIndex = counter % NumSteps`.
- Con este cambio, incluso si el hilo de UI/timer se retrasa puntualmente y deja pasar varios steps ideales entre dos callbacks, todos los pasos se ejecutan en orden (compactados en el tiempo) en lugar de saltarse silenciosamente, estabilizando el groove percibido sin necesidad de mover aún la lógica del Sequencer al hilo de audio.

### Sincronía del Sequencer con el transporte global (beats, Loops y pulsos)
- La lógica de avance del `Sequencer` en `MainComponent_Audio::timerCallback` se ha ajustado para que el índice de step de audio ya no dependa de un acumulador interno específico (`sequencerAudioPhase_`), sino de la **misma posición global en beats** que utilizan el motor de Loops y los pulsos visuales centrales.
- En lugar de incrementar una fase propia por frame (`sequencerAudioPhase_ += beatsThisFrame`) y derivar de ella el índice de step, ahora se calcula explícitamente la posición de transporte continua en beats como `transportPositionBeats = transportBeats_ + beatPhase_` y, a partir de ahí, se obtiene el step activo con:
  - `beatsPerStep = 1.0 / 4.0` (16 steps por compás de 4/4, semicorcheas),
  - `stepPhase = transportPositionBeats / beatsPerStep`,
  - `newAudioStep = floor(stepPhase) % SequencerPreset::kNumSteps`.
- Esto garantiza que:
  - El `Sequencer` recorre **exactamente 16 steps en 4 beats** para el caso típico `speed=1` (semicorchea) documentado en `research/sequencer.md`,
  - Los pasos del `Sequencer` quedan **fase-bloqueados** con los Loops (que ya usan `loopGlobalBeatCounter_` + `loopBeatPhase_`) y con los pulsos visuales de BPM, evitando pequeños desfases acumulados entre relojes independientes.
- La firma externa del runtime no cambia (se mantiene un `runSequencerStep(stepIndex)` que se ejecuta únicamente cuando el índice de step cambia), pero internamente el cálculo de `newAudioStep` pasa a compartir la misma noción de “beat” que el resto de la sesión, reforzando la coherencia entre Loops de audio, notas de `Oscillator` disparadas por `Sequencer` y el beat central que se dibuja en la UI.

#### Limpieza de gating extra y mapeo Decay/Release en Oscillator
- El runtime anterior introducía un gating adicional basado en `SequenceTrack::speed` y `speed_type="binary"` para módulos `Oscillator` conectados a un `Sequencer`: al disparar un paso se calculaba una duración en beats (`binarySpeedToBeats`) y se programaba un “note-off” extra en `moduleNoteOffBeats_` que forzaba el parámetro `gain` del Oscillator a 0 cuando el transporte alcanzaba ese beat. Esta lógica se ha eliminado por completo de `MainComponent`.
- A partir de ahora, la duración audible de las notas que salen de un `Sequencer` hacia un `Oscillator` se gobierna únicamente por:
  - Los pasos activos/inactivos del propio `Sequencer` (cuando un paso está deshabilitado y `sequencerControlsVolume_` es verdadero, el runtime fija explícitamente `gain=0` en los Oscillators aguas abajo en ese beat), y
  - La envolvente AR de cada voz en `AudioEngine` (tiempos de ataque y release) configurada a partir del `<envelope>` del Oscillator cargado desde el `.rtp`.
- Para que el parámetro `decay` de los Oscillators tenga un efecto audible aun cuando `release` es 0 en el patch (caso típico de `Loopdemo.rtp`), el mapeo de envelope en `MainComponent_Audio` se ha ajustado de forma que el **release efectivo** en el motor de audio sea `env.release` si es > 0, o en su defecto `env.decay`. Es decir:
  - `audioEngine_.setVoiceEnvelope(voice, env.attack, env.decay, env.duration, effectiveReleaseMs)`,
  - donde `effectiveReleaseMs = (env.release > 0 ? env.release : env.decay)`.
- Dado que `AudioEngine` implementa por ahora una envolvente simple tipo AR (Attack/Release), este cambio hace que el “Decay” definido en el `.rtp` se traduzca en la cola de release cuando el release original era 0, evitando que las notas disparadas por el Sequencer caigan inmediatamente a volumen 0 nada más terminar el paso activo.

### Sequencer v1 basado en pulsos (steps/volumes) y versionado
- Se ha introducido un campo de versión en `soundtable::SequencerModule` (`core/src/core/AudioModules.h`), expuesto mediante `version()` y `set_version(int)`. El valor se interpreta como la versión del tangible Sequencer en el `.rtp`; cuando el atributo `version` no está presente en la etiqueta `<tangible type="Sequencer" ...>`, el módulo se inicializa por defecto con versión 1 (modo legado de pulsos), reservando versiones ≥2 para futuros modos melódicos/avanzados.
- En el loader de sesiones Reactable (`core/src/core/ReactableRtpLoader.cpp`), el bloque que trata `type == "Sequencer"` ahora lee el atributo opcional `version` usando `ParseInt(attrs, "version", 1)` y lo pasa al módulo mediante `seq->set_version(sequencer_version)`. El atributo `version` ya no se vuelca como parámetro numérico genérico del módulo. El resto de atributos numéricos del tangible (`current_track`, `autoseq_on`, `noteedit_on`, `duration`, `num_tracks`, `offset`, etc.) siguen copiándose en parámetros internos del `SequencerModule` como antes.
- La estructura `SequenceTrack` ya contenía todos los campos relevantes de los `<sequence>` del `.rtp` (`rows`, `speed`, `speed_type`, `step_frequencies`, `steps`, `tenoriX`, `volumes`) y el loader sigue poblando estos vectores a partir de los atributos CSV. Sobre esta base, se ha ajustado la lógica de `SequencerModule::SyncPresetsFromTracks()` (`core/src/core/AudioModules.cpp`) para que el comportamiento dependa de la versión:
  - En **versión 1** (modo pulsos), el sequencer **no codifica información melódica** en los presets: cada `SequencerStep` se considera un disparo (trigger) binario definido únicamente por `steps` (0/1) y `volumes` (amplitud en [0,1]). La función mantiene la semántica ya existente para estos dos campos: `step.enabled` se deriva de `track.steps` y `step.velocity01` se toma de `track.volumes`, clampeando a [0,1] y forzando `0.0` cuando el paso está deshabilitado. La altura/energía de cada pulso queda predeterminada por el volumen correspondiente.
  - Para **versión 1**, el campo `pitch` de cada `SequencerStep` se fija explícitamente a una nota constante (C4, MIDI 60) y no se consulta `track.step_frequencies`, pero esta nota **no** se usa en el runtime de audio: actúa como placeholder interno para mantener la estructura de datos homogénea con versiones melódicas futuras. En ejecución, los módulos destino (`Oscillator`/`Sampleplay`) siguen determinando la nota audible a partir de su propia configuración (`midifreq`/`freq`); el Sequencer v1 sólo aporta el trigger (paso activo/inactivo) y la intensidad (`velocity01` derivada de `volumes`). El vector `pitches` de cada step sigue conteniendo un único valor igual a `pitch` cuando `enabled` es verdadero, preservando la estructura pensada para modos polifónicos futuros.
  - En **versiones ≥2**, se conserva el comportamiento actual de `SyncPresetsFromTracks`: los `step_frequencies` del `.rtp` se convierten a notas MIDI usando la relación estándar entre frecuencia y `69/440 Hz` (`midi = 69 + 12*log2(freq/440)`), se clampean al rango [0,127] y se asignan a `step.pitch`. Esto permite que un Sequencer v2 se use como secuenciador melódico real con pitches por paso cuando el runtime de audio implemente esta variante.
- A nivel de tiempo musical, la información de tempo sigue residiendo en los módulos `Tempo` (tempo en BPM, metro, swing) y en los campos `speed` y `steps` de `SequenceTrack`. Para **version 1** se formaliza la interpretación: cuando `speed=1` en un `<sequence>`, el patrón completo de `N` pasos ocupa exactamente **4 beats**; el índice de paso activo $i$ en un tiempo global $t$ medido en beats puede obtenerse como $i = \lfloor ( (t \bmod 4) / 4 ) \cdot N \rfloor$. Esta relación aún no se aplica en un motor de secuenciación en tiempo real, pero queda documentada para futuras fases de implementación del runtime que a partir de `tracks`, `speed` y `TempoModule` deberán decidir en qué beat se disparan los pulsos.
- Se ha añadido un test mínimo en `tests/scene_tests.cpp` que carga un patch `.rtp` embebido con un único `<tangible type="Sequencer" id="6" ...>` sin atributo `version` y un solo `<sequence>` con `steps` y `volumes` similares al ejemplo `Loopdemo.rtp`. El test comprueba que:
  - El loader crea exactamente un módulo `Sequencer` y un `ObjectInstance` asociado.
  - `seqModule->version()` es `1` al no declararse el atributo `version`.
  - Al llamar a `SyncPresetsFromTracks()` (invocado desde el loader) el preset 0 refleja correctamente los pasos habilitados/inhabilitados según el vector `steps` y las velocidades en [0,1] según `volumes`, con `velocity01 == 0.0` cuando el paso está deshabilitado.
  - Todos los pasos del preset (habilitados o no) comparten `step.pitch == 60`, verificando que en versión 1 se ignora `step_frequencies` y el sequencer se comporta como generador de pulsos sin codificar melodía.

### Priorización por ventana de 30 frames y filtro ganador en TrackerEngine
- Se ha rediseñado la lógica de selección de filtros en [tracker/src/TrackerEngine.cpp](tracker/src/TrackerEngine.cpp#L80-L260) para que, cuando se detecta por primera vez un fiducial, el tracker abra una **ventana de evaluación de 30 frames** en la que ejecuta todos los filtros de umbral disponibles sobre cada frame y cuenta cuántas veces cada filtro consigue ver **ese mismo fiducial**.
- `TrackerEngine` sigue modelando cuatro filtros concretos sobre la imagen en escala de grises reescalada: `OtsuBinary`, `OtsuBinaryInv`, `AdaptiveBinary` y `AdaptiveBinaryInv`. En la clase ([tracker/src/TrackerEngine.h](tracker/src/TrackerEngine.h#L20-L80)) se ha introducido un pequeño estado asociado a un "fiducial principal":
  - `primaryFiducialId_`: id del fiducial que se toma como referencia cuando aparece el primero en escena.
  - `trainingFramesRemaining_`: número de frames que quedan en la ventana de 30 frames sobre la que se evalúa qué filtro ve más veces ese fiducial.
  - `hasActiveFilter_` y `activeFilter_`: indican si ya hay un filtro ganador fijado y cuál es.
  - `primaryLostLastFrame_`: marca si en el frame anterior el filtro activo dejó de ver al fiducial principal, para activar la lógica de recuperación descrita más abajo.
  - `framesSincePrimarySeen_`: cuenta cuántos frames consecutivos llevamos sin ver al fiducial principal con ningún filtro.
  - `filterSuccessCount_[4]`: acumula, durante la ventana de entrenamiento, en cuántos frames cada filtro ha sido capaz de detectar el fiducial principal.
  - `filterSeenIds_[4]`: almacena, para cada filtro, el conjunto de IDs distintos que ha visto durante la ventana de entrenamiento.
- Durante la ventana de entrenamiento (`trainingFramesRemaining_ > 0`), `processFrameInternal` ejecuta los cuatro filtros en cada frame, acumula la unión de todos los fiduciales detectados como resultado y, para cada filtro, añade todos los IDs vistos a su conjunto en `filterSeenIds_`. Si el resultado de un filtro contiene el `primaryFiducialId_`, se incrementa también su contador en `filterSuccessCount_`. Al agotar los 30 frames (`kTrainingWindowFrames = 30`), se selecciona como **filtro ganador** aquel que cumpla dos criterios: (1) haber visto el fiducial principal al menos una vez (contador > 0), y (2) tener el número más bajo de IDs distintos acumulados; en caso de empate en (2), se usa como desempate el contador de éxitos.
- Mientras exista filtro ganador activo y el fiducial principal siga viéndose, el tracker entra en un modo de **uso exclusivo del filtro ganador**: en cada frame sólo se ejecuta `activeFilter_` para binarizar y detectar fiduciales, reduciendo el coste de CPU respecto a probar todos los filtros en cada paso.
- Si en algún frame el filtro activo deja de ver al fiducial principal, `primaryLostLastFrame_` pasa a `true` y, en el frame siguiente, el tracker **ejecuta de nuevo los cuatro filtros**: si alguno de ellos vuelve a detectar el `primaryFiducialId_`, se considera que el fiducial ha reaparecido y se reinicia una nueva ventana completa de 30 frames de evaluación (empezando a contar desde ese mismo frame); si ninguno lo ve, se interpreta que el fiducial realmente ha desaparecido y se limpia todo el estado adaptativo (`hasActiveFilter_ = false`, `primaryFiducialId_ = -1`, contadores y conjuntos de IDs a cero), volviendo al modo base.
- En el modo base (sin fiducial principal ni filtro activo), `processFrameInternal` ejecuta todos los filtros, devuelve la unión de todas las detecciones y, en el primer frame donde aparezca algún fiducial, escoge el id del primer objeto como `primaryFiducialId_`, inicializa contadores y conjuntos (`filterSuccessCount_`, `filterSeenIds_`) y arranca la ventana de entrenamiento de 30 frames descrita arriba.
- Además, se ha introducido un umbral duro de desaparición: si el fiducial principal lleva más de 4 frames consecutivos sin aparecer en los resultados (ni siquiera al ejecutar todos los filtros), se descarta inmediatamente (`primaryFiducialId_ = -1`) y se resetea todo el estado adaptativo (`hasActiveFilter_`, contadores por filtro y conjuntos de IDs vistos). De este modo, el tracker no mantiene durante demasiado tiempo un filtro "aprendido" basándose en un fiducial que ya no está presente en escena.
- El helper estático `filterIndex(ThresholdFilter)` en [tracker/src/TrackerEngine.cpp](tracker/src/TrackerEngine.cpp#L260-L300) sigue proporcionando el índice `[0,3]` asociado a cada valor del enum para indexar los arrays internos cuando es necesario.
- En builds de depuración (`NDEBUG` desactivado), al finalizar cada ventana de entrenamiento se escribe una traza a stderr con el resumen de resultados por filtro: número de frames de entrenamiento, aciertos por filtro y número de IDs distintos vistos por cada uno, junto con el nombre del filtro ganador. Esto facilita inspeccionar rápidamente qué estrategias de umbral están resultando más robustas bajo las condiciones de iluminación actuales.
- Tras estos cambios, se ha vuelto a ejecutar el test de tracker vía CTest (`ctest -R tracker`) y `soundtable-tracker-tests` sigue pasando: las imágenes de prueba `fiducial_30.jpg` y `fiducial_55.jpg` se detectan correctamente con sus IDs esperados, aunque en las imágenes de prueba también se observan algunos IDs adicionales secundarios (activados por la mejora en la lógica de unión de detecciones por filtro), lo que sirve de caso realista para ajustar esta heurística de selección de filtro.

### Extensión rango Oscillator y carga de sesiones RTP (Loopdemo)
- Se ha ampliado el mapeo de frecuencia del `OscillatorModule` para que el
  parámetro normalizado `freq` cubra aproximadamente el rango de notas
  MIDI 0–127 (≈8 Hz–12.5 kHz). Esto alinea el comportamiento con los
  patches originales de Reactable donde `midifreq` puede estar en todo
  el rango MIDI.
- El loader de sesiones RTP (`ReactableRtpLoader`) ahora, al cargar un
  `Oscillator` con atributo `midifreq`, calcula la frecuencia en Hz
  usando la fórmula estándar MIDI→Hz y la convierte a valor normalizado
  `freq` usando `base_frequency_hz` y `frequency_range_hz` del módulo.
  De este modo la afinación por defecto del oscilador en la escena
  coincide con la nota indicada en el `.rtp`.
- Para los módulos `Loop` y `Oscillator`, el `<envelope>` definido en
  el archivo `.rtp` se parsea a la estructura `Envelope` y, además, se
  vuelca en los parámetros del módulo (`attack`, `decay`, `duration`,
  `release`). Esto facilita que la UI y el motor de audio puedan
  consultar/aplicar el ADSR de forma consistente.
- Se han ampliado los tests en `tests/scene_tests.cpp` para comprobar
  que:
  - `midifreq` se expone como parámetro del `Oscillator` tras cargar
    una sesión RTP.
  - El parámetro normalizado `freq` queda inicializado de forma que la
    frecuencia efectiva en Hz sea coherente con la nota `midifreq`.
  - Los valores ADSR del `<envelope>` de un `Oscillator` se almacenan
    tanto en la estructura `Envelope` interna como en los parámetros del
    módulo.

### ADSR aplicado en runtime a Oscillator y Loop
- Se ha añadido soporte de envolvente simple tipo AR en `AudioEngine`
  para las voces de `Oscillator`: el motor detecta transiciones del
  nivel de voz (0→>0 como note-on, >0→0 como note-off) y aplica una
  rampa de ataque y una de release en tiempo de muestra usando los
  tiempos `attack` y `release` cargados desde el `<envelope>` del
  módulo. `decay` y `duration` se reservan para una futura
  implementación de ADSR completo, pero ya se propagan hasta el motor.
- `MainComponent_Audio` ahora pasa la envolvente de cada
  `OscillatorModule` a través de `AudioEngine::setVoiceEnvelope`, de
  modo que cada voz conoce los tiempos de ataque/decaimiento/duración/
  release configurados en la sesión RTP.
- Para los módulos `Loop`, `AudioEngine::LoopInstance` mantiene ahora
  un pequeño estado de envolvente (fase, valor actual y tiempos
  attack/release). `MainComponent_Audio` llama a
  `setLoopModuleParams` incluyendo los cuatro tiempos del
  `<envelope>` del Loop; en el callback de audio el motor suaviza los
  cambios de ganancia del loop (por mute/desmute o cambios de `amp`)
  aplicando la misma envolvente AR basada en los tiempos de ataque y
  release.
- Esta primera fase garantiza que los parámetros de envelope definidos
  en `.rtp` tienen un efecto audible: los osciladores y loops ya no
  reaccionan con saltos bruscos de nivel, sino que respetan rampas de
  entrada/salida según los tiempos de ataque y release de la sesión.

#### Extensión: retrigger de envelope por paso de Sequencer
- Se ha ampliado la lógica de envolvente por voz en `AudioEngine` para
  que, además de las transiciones de nivel 0↔>0, pueda reaccionar a
  **disparos explícitos** procedentes del runtime del `Sequencer`.
  Cada voz mantiene ahora un flag atómico `voiceEnvRetrigger_[v]` que
  se marca desde el hilo de UI y se consume en el callback de audio;
  cuando está activo, la envolvente de esa voz reinicia la fase de
  `attack` independientemente de si el nivel actual era ya > 0.
- Se ha añadido el método público `AudioEngine::triggerVoiceEnvelope(int)
 `, que marca el flag de retrigger para una voz concreta. Este método
  se utiliza desde `MainComponent_Audio` cuando un módulo
  `SequencerModule` avanza un paso activo hacia un `OscillatorModule`
  conectado.
- En `MainComponent_Audio::timerCallback`, dentro del lambda
  `runSequencerStep`, la rama que trata destinos `OscillatorModule`
  mantiene el comportamiento previo (v2: puede sobreescribir `freq`
  a partir de `step.pitch`; cuando `sequencerControlsVolume_` está
  activo, mapea `velocity01` a `gain`), pero ahora además localiza el
  índice de voz asignado al oscilador en `moduleVoiceIndex_` y llama a
  `audioEngine_.triggerVoiceEnvelope(voiceIndex)` para cada paso
  habilitado.
- Con este cambio, incluso cuando una secuencia mantiene varios pasos
  consecutivos con `velocity01 > 0` (es decir, el nivel del oscilador
  no llega a caer a cero entre beats), cada beat activo del Sequencer
  **reinicia la envolvente** del Oscillator. En la práctica, los
  módulos de tipo Oscillator conectados a un Sequencer pasan a seguir
  las notas del secuenciador mediante pulsos de envolvente por paso,
  respetando los tiempos de ataque/release definidos en el `<envelope>`
  del módulo, en lugar de mantener una envolvente en sustain continuo.

### Normalización y límites para ADSR y `midifreq`
- El parser de `<envelope>` en `ReactableRtpLoader.cpp` ahora aplica
  límites razonables a los tiempos en milisegundos: `attack`, `decay`
  y `release` se clampean al rango `[0, 2000]` ms y `duration` al
  rango `[0, 7500]` ms. Valores negativos, no finitos o con formato
  inválido se normalizan primero a `0.0F` antes de aplicar el clamping
  superior. Los arrays `points_x` y `points_y` siguen leyéndose como
  CSV de flotantes (`SplitFloats`), por lo que valores decimales en el
  `.rtp` (como los de `Loopdemo.rtp`) se conservan tal cual en
  `Envelope::points_x/points_y`.
- En `MainComponent_Audio.cpp`, el cálculo de la nota MIDI para
  `SampleplayModule` dentro de `triggerSampleplayNotesOnBeat` pasa de
  usar `lround` a `std::floor` sobre el parámetro `midifreq`. Esto
  respeta la semántica acordada: `midifreq` puede ser entero o decimal
  en el `.rtp`, pero en Sampleplay siempre se trunca hacia abajo a un
  número de nota MIDI entero en `[0, 127]` antes de disparar la nota.
- Para `OscillatorModule`, el loader sigue usando el valor de
  `midifreq` como `float` completo al convertir de MIDI→Hz y
  normalizar el parámetro `freq`, de forma que ajustes finos (por
  ejemplo, microafinación expresada como decimales) en el `.rtp` se
  trasladan directamente a la frecuencia base del oscilador dentro del
  rango expandido (~8–12.5 kHz).

### Próximos pasos relacionados

- Extender el mapeo de envelope en tiempo de ejecución para cubrir
  casos más avanzados (por ejemplo, shapes no lineales a partir de
  `points_x`/`points_y` o modulación de otros parámetros distintos de
  la amplitud) tanto en `Oscillator` como en `Loop`.
- Revisar el flujo de `Sampleplay` para decidir cómo usar `midifreq`
  como afinación por defecto al cargar sesiones RTP, manteniendo la
  compatibilidad con el disparo actual por beat.

### Implementación de sustain ADSR para Oscillator

- Se ha implementado un envelope ADSR completo para las voces de
  Oscillator en `AudioEngine`, utilizando los tiempos de
  `attack/decay/release` y derivando el nivel de `sustain` a partir
  de los puntos de control `Envelope::points_y` cargados desde el
  `.rtp`.
- La estructura `AudioEngine::Voice` incorpora ahora un campo atómico
  `sustainLevel`, configurado a través de la nueva firma de
  `AudioEngine::setVoiceEnvelope(int index, float attackMs,
  float decayMs, float durationMs, float releaseMs, float
  sustainLevel)`. El sustain se limita al rango [0,1] dentro del
  callback de audio.
- En `audioDeviceIOCallbackWithContext`, la rama de envolvente por voz
  sin `duration` (antes modo "AR clásico") pasa a implementar un
  ADSR completo gobernado por note-on/note-off:
  - `Attack`: rampa de 0→1 usando `attackMs` (con mínimo de 0.5 ms
    para evitar clics).
  - `Decay`: nuevo tramo opcional que interpola linealmente de 1.0 al
    `sustainLevel` en `decayMs`.
  - `Sustain`: mantiene `sustainLevel` mientras la nota siga activa.
  - `Release`: rampa lineal desde el valor de envelope en el momento
    del note-off hasta 0 en `releaseMs`, usando un nuevo buffer
    interno `voiceEnvReleaseStart_` para recordar el nivel de partida.
- El modo one-shot basado en `durationMs` se mantiene para futuros
  usos, pero los Oscillator existentes dejan de entrar en esa rama al
  forzar `durationMs=0` en la capa de UI.
- En `MainComponent_Audio.cpp`, la configuración de la envolvente para
  módulos `OscillatorModule` se actualiza para:
  - Forzar `durationMs` a 0 cuando se llama a
    `audioEngine_.setVoiceEnvelope`, de forma que los osciladores se
    comporten como fuentes sostenidas gobernadas por note-on/note-off
    (tangible activo) en lugar de envelopes one-shot cortos.
  - Calcular el `sustainLevel` a partir de `Envelope::points_y` con la
    heurística siguiente: buscar el tramo "plano" interno más largo de
    puntos consecutivos con `y > 0` (ignorando primer/último punto) y
    usar ese nivel como sustain; si no existe, usar el máximo `y`
    previo al último punto o 1.0 como fallback.
  - Mantener el comportamiento previo de `release` efectivo: si el
    `.rtp` define `release > 0` se usa su valor; si no, se cae a
    `decay` para garantizar una cola suave.
- Con este cambio, el Oscillator de onda seno de la mesa por defecto
  mantiene ahora un sustain continuo mientras el módulo esté activo:
  la línea de sonido en la UI coincide con el audio real, eliminando
  el corte brusco que se producía al tratar su envelope como
  one-shot basado en `duration`.

### Ajuste visual de mute pendiente en líneas de audio
- Se ha modificado el pintado de las líneas radiales de audio en `MainComponent_Paint.cpp` para que, cuando una línea está marcada como "pendiente de silenciar" (estado de cut/mute en hover sobre la conexión), se mantenga la waveform existente y sólo cambie el color de la línea de sonido de blanco a amarillo. Anteriormente, al marcar una línea para mute, se sustituía la waveform por una línea recta amarilla, dando la sensación de que se dibujaba una nueva línea plana sin información de audio.
- Para conseguirlo, las ramas de pintado de waveform de radiales asociadas a `SampleplayModule`, `LoopModule` y módulos con voces procedurales dejan de descartar el caso `isMarkedForCut`; ahora siguen obteniendo su snapshot de waveform (por conexión o global) y llaman a `drawWaveformOnLine` con el mismo patrón espacial, pero seleccionando el color en función del estado: blanco cuando la línea está activa normalmente y amarillo cuando está marcada para mute pendiente, de forma uniforme en todos los tipos de módulo.
- La rama de fallback que antes dibujaba explícitamente una línea recta amarilla de mayor grosor cuando `isMarkedForCut` se ha simplificado para actuar sólo cuando no hay waveform disponible (líneas sin audio o en silencio): en ese caso se sigue resaltando la conexión con una línea amarilla fina, pero nunca se reemplaza una waveform existente por una línea plana. Esto alinea el comportamiento visual con la expectativa de que el gesto de hover/mute pendiente "colorea" la línea de audio sin alterar su forma.

### Contador global de beats para LoopModule y continuidad al cambiar de sample
- Se ha introducido en `AudioEngine` un contador global de beats específico para los módulos `Loop`, implementado como un `std::atomic<unsigned int> loopGlobalBeatCounter_` junto con los métodos públicos `resetLoopBeatCounter(unsigned int)`, `advanceLoopBeatCounter()` y `loopBeatCounter()`. Este contador se incrementa exactamente una vez por cada beat de tempo y se inicializa a 0 al cargar una sesión en `MainComponent` mediante `audioEngine_.resetLoopBeatCounter(0U)`, cumpliendo el requisito de disponer de una variable global de "beats marcados" que avanza con el transporte.
- Además del contador entero, el motor mantiene ahora una fase fraccional de beat en `std::atomic<double> loopBeatPhase_` que se actualiza desde `MainComponent_Audio.cpp` en cada `timerCallback()` usando el mismo `beatPhase_` que alimenta las animaciones de pulsos (`audioEngine_.setLoopBeatPhase(beatPhase_)`). De esta forma, el motor dispone de una posición global de beat **continua** calculada como `loopBeats = loopGlobalBeatCounter_ + loopBeatPhase_`, compartida por todos los módulos Loop.
- La estructura interna `LoopInstance` en `AudioEngine.h` se ha ampliado con un campo `int lastSelectedIndexForPlayback{-1};` que solo se utiliza en el hilo de audio. Este campo recuerda qué índice de slot se alineó por última vez para reproducción y permite detectar cuándo el usuario cambia de sample activo en un `LoopModule` sin necesidad de escribir sobre `readPositions` desde el hilo de UI, evitando condiciones de carrera.
- En el callback de audio `audioDeviceIOCallbackWithContext`, tanto en la rama con voces de oscilador activas como en la rama sin voces, la mezcla de loops se ha modificado para que, justo antes de calcular el `step` de avance, cuando hay un slot válido con `slot.beats > 0` y `totalFrames > 0`, se compruebe si `lastSelectedIndexForPlayback != slotIndex`. Si el índice ha cambiado, se calcula una nueva posición de reproducción basada en la posición global de beat **continua**:
  - Se toma `loopBeats` al inicio del callback como `double` a partir de `loopGlobalBeatCounter_` y `loopBeatPhase_`.
  - Para el slot actual se calcula `beatsPerLoop = static_cast<unsigned int>(slot.beats)` y `loopBeatsMod = fmod(loopBeats, beatsPerLoop)`.
  - La fracción dentro del loop se obtiene como `fracBeat = loopBeatsMod / beatsPerLoop` y se traduce a frames mediante `targetFrame = fracBeat * totalFrames`, clampando el resultado al rango `[0, totalFrames-1]`.
  - Esta posición se escribe en `instance.readPositions[slotIndex]` y se actualiza `lastSelectedIndexForPlayback = slotIndex`.
  Con ello, cada vez que se cambia de sample activo en un módulo Loop, el nuevo sample comienza a reproducirse en la posición coherente con el **tiempo continuo de transporte**, incluso cuando el cambio se hace en mitad de un beat, como si todos los loops estuvieran sonando en paralelo y simplemente se cambiase cuál se escucha.
- La lógica existente de avance de fase por muestra (`step` basado en `sourceSampleRate`, `sampleRate_` y la sincronía opcional a BPM/`beats`) se mantiene intacta. La posición global de beat se usa únicamente como referencia para fijar la posición inicial del slot cuando cambia la selección; a partir de ahí, el avance se realiza de forma continua por muestra. Esto respeta el comportamiento anterior de loops que siguen sonando aunque se mutee su radial (la fase interna nunca se resetea por mute), añadiendo sólo el requisito extra de que cambiar de sample preserve la alineación temporal con el transporte.
- En `MainComponent.cpp`, justo después de `loadLoopSamples()`, se llama explícitamente a `audioEngine_.resetLoopBeatCounter(0U)` para garantizar que cada sesión carga con el contador de beats de loop en un origen bien definido. Este reset no afecta a `transportBeats_`, que sigue siendo un `double` usado para etiquetar eventos MIDI, pero asegura que los cálculos de posición de los loops (basados en el entero global de beats más la fase fraccional) empiezan desde 0 en cada mesa/carga de sesión.

### Rotación del LoopModule con parámetro continuo y scroll infinito
- Se ha ajustado la lógica de control por rotación para los módulos de tipo `Loop` en `MainComponent_Audio.cpp` de modo que el parámetro normalizado `"sample"` se actualiza de forma **continua** con la rotación del fiducial, manteniéndose siempre en el rango `[0,1]` mediante wrap sin clamp duro. Un giro completo de 360º sigue recorriendo los cuatro segmentos de loop (≈90º por segmento), pero ahora el valor subyacente conserva la fracción decimal necesaria para un movimiento suave en la UI.
- El índice de slot activo se sigue derivando cuantizando `"sample"` a cuatro tramos (`0..3`) en `timerCallback`, por lo que el cambio efectivo de sample se mantiene discreto cada ~90º de rotación. Sin embargo, al no forzar el parámetro a los centros de segmento, es posible seguir acumulando rotación más allá de una vuelta completa y el parámetro hace **scroll infinito**, volviendo al primer/último sample al cruzar los extremos `[0,1]` sin “atascarse” en los bordes.
- En `MainComponent_Paint.cpp`, el triángulo indicador de la barra izquierda de los módulos Loop usa directamente el valor continuo de `"sample"` para su posición vertical a lo largo de toda la barra, sin sesgos adicionales por segmento. Esto garantiza que el movimiento del triángulo sea totalmente continuo y proporcional a la rotación del fiducial, y que no haya saltos visibles al cruzar los límites entre segmentos; la selección de slot sigue siendo discreta vía el índice entero derivado de `"sample"`, de modo que el cambio de sample ocurre cada ~90º aunque la animación del marcador sea suave.
 - La geometría de los segmentos de la barra izquierda del Loop se ha invertido para que el índice `0` corresponda a la parte baja de la barra y el índice `3` a la parte alta, en coherencia con el nuevo mapeo vertical del triángulo (que se desplaza de abajo hacia arriba al aumentar `"sample"`). Con ello, el segmento resaltado y la posición del triángulo dejan de estar “en espejo” y ambos representan el mismo orden lógico de slots en la UI.
- Con este cambio, la interacción cumple el comportamiento esperado: cada 90º de rotación se avanza al siguiente segmento de loop (con wrap alrededor de toda la vuelta), y el triángulo refleja visualmente la posición decimal exacta del parámetro sobre la barra, moviéndose de forma continua y coherente con la rotación física del objeto.

### Extensión de los arcos laterales Freq/Gain casi hasta el semi-círculo completo
- Se ha ajustado el recorrido vertical de las barras laterales de frecuencia y volumen en `MainComponent_Paint.cpp` para que los arcos izquierdo (Freq) y derecho (Gain) abracen casi todo el semi-círculo alrededor del nodo, dejando solo un pequeño hueco en la parte superior. Esto se consigue reduciendo el margen vertical `sliderMargin` de `6.0F` a `3.0F`, de modo que las barras comienzan y terminan más cerca de los puntos extremos del círculo sin llegar a cerrarse del todo.
- El hueco superior está pensado específicamente para que la línea radial de audio (y su waveform animada) pueda atravesar el nodo sin quedar tapada por las barras laterales: el módulo se sigue rotando de forma que su "arriba" local se alinee con la línea al centro, y el pequeño gap en la parte superior del anillo queda exactamente en esa dirección radial.
- En `MainComponent_Input.cpp` se ha actualizado la geometría de hit-test de los controles laterales (cálculo de `sliderTop`/`sliderBottom` y lambdas `isOnFreqControlBar`/`isOnGainControlBar`) para usar el mismo `sliderMargin = 3.0F`. Con ello, el área clicable de las barras coincide con el nuevo recorrido visual casi completo del semi-círculo, evitando desajustes entre lo que se ve y dónde responde el control al hacer click o arrastrar.

### Ajuste de grosor en barras laterales de frecuencia y volumen
- Se ha refinado la representación visual de los controles laterales en los módulos con `uses_frequency_control()` y/o `uses_gain_control()` para que resulten más finos y discretos. En `MainComponent_Paint.cpp` el trazo de la barra de frecuencia (arco izquierdo) pasa de un grosor de `7.0F` a `5.0F` tanto para el fondo atenuado como para la parte rellena que indica el valor actual, haciendo la barra 2 píxeles más delgada sin cambiar su recorrido geométrico.
- La barra de volumen/ganancia (arco derecho) reduce su grosor de trazo de `2.0F` a `1.0F`, de modo que el control lateral de nivel se percibe menos pesado visualmente y no compite con el cuerpo del módulo ni con la forma de onda que se dibuja sobre las líneas de audio.
- El handle circular del control de volumen (el "punto" que se dibuja sobre el arco derecho) se ha hecho más pequeño para reforzar esta sensación de ligereza: el diámetro pasa de `12x12` píxeles a `8x8`, manteniendo el mismo color blanco pero con un radio más contenido. Esto hace que el punto de control parezca más fino y alineado con el nuevo grosor de la barra, sin modificar en absoluto la lógica de interacción (click/drag) ni el mapeo del parámetro de ganancia.

### Corrección de artefactos visuales en extremos de la barra de frecuencia
- Se ha ajustado el pintado de la barra de frecuencia lateral para eliminar el pequeño “hueco” que aparecía en los extremos cuando el valor era exactamente 0% o 100%. El efecto se producía porque la parte rellena de la barra se calcula recortando el arco con un rectángulo vertical y, en los extremos, quedaba una franja pintada solo con el color de fondo.
- En `MainComponent_Paint.cpp` se detectan ahora explícitamente los casos `freqValue <= 0.001F` (barra vacía) y `freqValue >= 0.999F` (barra llena) y se tratan de forma distinta: si la barra está al 0%, se dibuja únicamente el arco de fondo sin ninguna pasada adicional recortada, evitando que el clipping vertical genere pequeños triángulos o fragmentos visibles; si la barra está al 100%, el arco de fondo se dibuja ya con el mismo color que la parte rellena, de modo que cualquier desajuste entre ambas capas resulte invisible.
- Con este cambio, la transición entre 0%, valores intermedios y 100% mantiene el mismo esquema de “fondo tenue + tramo relleno brillante” en los valores intermedios, pero en los extremos desaparecen los artefactos visuales producidos por la geometría de recorte vertical frente al arco curvo y por el anti-aliasing en el borde del recorte.

### Ajuste de la barra de frecuencia lateral en módulos con control de `freq`
- Se ha simplificado el control visual de frecuencia en los módulos que usan `uses_frequency_control()` (por ejemplo, Oscillator y Filter) eliminando la "bola" o handle circular que se dibujaba sobre la barra izquierda. En `MainComponent_Paint.cpp` la barra de frecuencia sigue representándose como un arco curvo pegado al lado izquierdo del nodo, pero ahora sin indicador puntual: el valor se comunica exclusivamente a través de la posición relativa sobre la barra y su waveform asociada.
- Para mejorar la legibilidad de este control y preparar su reutilización en más módulos, se ha incrementado el grosor del trazo de la barra de frecuencia: el `PathStrokeType` usado para el arco izquierdo pasa de `3.0F` a `7.0F`, manteniendo el mismo recorrido geométrico pero haciendo la barra más ancha y visible incluso sin el handle, especialmente en escenas con mucho contenido.
- Además, la barra ahora muestra explícitamente qué porcentaje está "lleno" o "vacío": se dibuja primero un arco de fondo más oscuro a lo largo de todo el recorrido y, sobre él, un tramo más brillante desde la parte inferior de la barra hasta la posición correspondiente al valor normalizado de `freq`. De este modo, el usuario puede leer de un vistazo cuánta barra está activa sin necesidad de un handle independiente.
- La lógica de input en `MainComponent_Input.cpp` se ha ajustado para que el área clicable de la barra de frecuencia crezca **solo hacia el exterior del nodo** (lado izquierdo en pantalla) y no hacia el centro del módulo. Se han separado dos lambdas de hit-test: `isOnFreqControlBar` amplía la zona de click 7 píxeles adicionales hacia la izquierda, manteniendo el margen interior igual para no invadir el área del cuerpo circular que se usa para arrastrar el módulo; `isOnGainControlBar` conserva una zona simétrica alrededor de la barra de ganancia derecha.
- El gesto de usuario sigue siendo el mismo: hacer click en cualquier punto de la barra de frecuencia mueve instantáneamente el valor a esa posición y comienza un drag continuo. Con el nuevo hit-test asimétrico, es más fácil acertar en la barra de `freq` desde el exterior de la mesa sin interferir con los clicks destinados a seleccionar y mover el módulo por su zona central. Este patrón visual y de interacción está pensado para reutilizarse en futuros módulos que compartan control lateral de frecuencia.

### LookAndFeel personalizada con fuente embebida opcional para evitar escaneo masivo de fuentes del sistema
- Se ha introducido una clase `RectaiLookAndFeel` en `core/src/RectaiLookAndFeel.{h,cpp}` que hereda de `juce::LookAndFeel_V4` y, de forma opcional, carga una tipografía TTF embebida desde disco para usarla como fuente sans-serif por defecto en toda la aplicación.
- La clase intenta localizar un archivo `soundtable-default.ttf` en rutas estables relativas al binario (pensadas para el layout actual del repo): `com.reactable/Resources/soundtable-default.ttf` y `resources/soundtable-default.ttf`. Si encuentra el fichero, lo lee completo en memoria y crea un `juce::Typeface` con `juce::Typeface::createSystemTypefaceFor(...)`, que se instala como tipo de letra sans-serif por defecto mediante `setDefaultSansSerifTypeface(embeddedTypeface_)`.
- Este diseño permite que el binario sólo tenga que abrir un único archivo de fuente conocido en tiempo de ejecución, evitando que JUCE/fontconfig recorran todas las fuentes de `/usr/share/fonts/...` durante la inicialización para resolver la fuente por defecto. La fuente TTF concreta **no** se versiona en el repositorio (para respetar licencias externas); el usuario puede copiar la tipografía que desee a una de esas rutas con el nombre `soundtable-default.ttf` para activar el comportamiento embebido.
- En `core/src/Main.cpp` se ha añadido un miembro `RectaiLookAndFeel lookAndFeel_` a `RectaiApplication`. En `initialise` se llama a `juce::LookAndFeel::setDefaultLookAndFeel(&lookAndFeel_)` antes de crear la `MainWindow`, y en `shutdown` se restaura el estado llamando a `setDefaultLookAndFeel(nullptr)` antes de destruir la ventana. De este modo, toda la UI pasa a usar la fuente embebida (cuando existe) sin cambios adicionales en el código de pintado (`MainComponent_Paint.cpp` sigue usando `g.setFont(size)` y se beneficia automáticamente de la tipografía fija).
- Si no se encuentra `soundtable-default.ttf` en las rutas esperadas, `RectaiLookAndFeel` ahora fija explícitamente `"DejaVu Sans"` como nombre de fuente sans-serif por defecto mediante `setDefaultSansSerifTypefaceName("DejaVu Sans")`. Esto hace que JUCE/fontconfig resuelvan directamente esa familia ampliamente disponible en Linux a partir de las cachés del sistema, reduciendo la necesidad de escanear todo `/usr/share/fonts`. Si la creación de la `Typeface` embebida falla por cualquier motivo, también se recurre a este mismo fallback, de modo que el comportamiento resulta determinista tanto con como sin TTF embebido.

### Barra lateral de Tempo ligada al BPM global
- El módulo `TempoModule` aprovecha ahora la misma barra lateral izquierda de "frecuencia" que usan los generadores, pero reinterpretada como control de tempo: cuando el tangible de Tempo está en la mesa (o en el dock), se muestra una barra vertical a su izquierda cuya posición refleja el BPM global normalizado en el rango [40, 400].
- En `MainComponent_Paint.cpp`, la frecuencia normalizada de los controles laterales se calcula, para `TempoModule`, a partir del valor global `bpm_` en lugar de leer un parámetro `freq`; además, la barra se fuerza a mostrarse aunque el módulo no marque `uses_frequency_control()` para no interferir con el mapeo genérico de frecuencia de otros módulos.
- En `MainComponent_Input.cpp`, tanto el click como el drag sobre la barra izquierda de un `TempoModule` actualizan el BPM global (`bpm_`) y sincronizan el parámetro lógico `tempo` del propio módulo, reutilizando la misma geometría de slider que el resto de tangibles pero mapeando la posición vertical a un BPM en el intervalo [40, 400]. También se actualiza `bpmLastChangeSeconds_` para que la etiqueta numérica de BPM siga mostrándose y haciendo fade tras interacciones con el slider, igual que ocurre con los gestos de rotación.
 - Además, la rueda del ratón sobre el nodo de Tempo en la mesa ajusta ahora el BPM global en pasos de ±1 por notch, o en pasos de ±5 cuando la tecla Shift está pulsada, manteniendo siempre el parámetro `tempo` del `TempoModule` sincronizado y respetando el mismo rango [40, 400].
