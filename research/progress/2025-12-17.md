## 2025-12-17

### Diseño inicial de soporte TUIO 1.1 y anuncio OSC
- Se ha creado un nuevo documento de diseño en [research/tuio-protocol.md](research/tuio-protocol.md) que describe la estrategia inicial para integrar el protocolo TUIO en el proyecto, comenzando por TUIO 1.1 sobre transporte OSC/UDP y dejando preparada la evolución posterior hacia TUIO 2.0.
- El documento resume los perfiles relevantes de TUIO 1.1 para `rectai-table` (principalmente `tuio/2Dobj` para fiduciales y `tuio/2Dcur` para fingers), los tipos de mensajes (`set`, `alive`, `fseq`) y el mapeo conceptual de los atributos actuales de fiduciales del tracker (session id, symbol id, posición normalizada y ángulo) a los campos estándar de TUIO.
- Se definió un mensaje ligero de anuncio `/tuio/hello` que `rectai-tracker` envía una vez al arrancar en modo TUIO, incluyendo identificador de cliente, versión TUIO (`"1.1"`) y versión interna de tracker (`"0.1.0"`), sin esperar ninguna respuesta por parte del core. El core, al recibir este mensaje, simplemente lo registra en los logs (tracker id, versión de cliente y protocolo TUIO usado) y continúa recibiendo mensajes TUIO estándar.
- Se ha esbozado también el plan para integrar detección de fingers en el tracker y exponerlos al core mediante el perfil `tuio/2Dcur`, de forma que puedan traducirse en múltiples punteros lógicos (eventos equivalentes a ratón) y permitan interacciones multitouch. La adaptación interna del core para soportar múltiples punteros y el soporte de TUIO 2.0 quedan planificados para fases posteriores.

### Implementación inicial de soporte TUIO 1.1 entre rectai-tracker y rectai-core
- En el tracker se ha introducido un pequeño módulo de configuración en [tracker/src/TuioNegotiation.h](tracker/src/TuioNegotiation.h) que define el enum `rectai::tracker::TuioOutputMode` (`LegacyOsc` vs `Tuio11`). La lógica de negociación TUIO que existía en versiones anteriores se ha eliminado y el modo de salida se decide ahora directamente en `main.cpp` en función del flag `--osc` y de la disponibilidad del socket OSC.
- Para reutilizar la infraestructura de empaquetado OSC existente en el tracker, `OscSender` ([tracker/src/OscSender.h](tracker/src/OscSender.h#L1-L80), [tracker/src/OscSender.cpp](tracker/src/OscSender.cpp#L1-L240)) ha ganado un método público `sendHelloTuio11(const std::string& trackerId, const std::string& trackerVersion)`. Este método construye un mensaje OSC con dirección `/tuio/hello` y type tags `",sss"` que codifica tres strings: identificador del tracker, versión TUIO (`"1.1"`) y versión interna del tracker (`"0.1.0"` por ahora), y lo envía por el mismo socket UDP ya conectado hacia el core (host `127.0.0.1`, puerto 3333). En el flujo actual, `rectai-tracker` envía este mensaje una sola vez al arrancar en modo TUIO, sin esperar respuesta.
- En el arranque de `rectai-tracker` ([tracker/src/main.cpp](tracker/src/main.cpp#L1-L160)), justo después de crear el `OscSender`, se decide el modo de salida en función de un nuevo flag de línea de comandos `--osc`. Si se pasa `--osc` se fuerza `TuioOutputMode::LegacyOsc` y el tracker conserva el formato OSC propietario (`/rectai/object` y `/rectai/remove`). Si no se pasa el flag y el socket OSC se ha creado correctamente, se selecciona `TuioOutputMode::Tuio11` (modo TUIO) y se envía un `/tuio/hello` "best effort" sin depender de un ACK.
- En el core se ha extendido `TrackingOscReceiver` ([core/src/TrackingOscReceiver.h](core/src/TrackingOscReceiver.h#L1-L60), [core/src/TrackingOscReceiver.cpp](core/src/TrackingOscReceiver.cpp#L1-L180)) para escuchar también la dirección `/tuio/hello`. Además de registrar los listeners para `/rectai/object`, `/rectai/remove` y `/tuio/2Dobj`, el método privado `handleTuioHelloMessage` valida que el mensaje entrante contenga al menos dos strings (id de tracker y versión TUIO), extrae opcionalmente la versión de cliente si viene como tercer string, y registra en el log de JUCE una línea del tipo `[rectai-core] TUIO hello from rectai-tracker (client 0.1.0, TUIO 1.1, via localhost:3333)`. No se envía ninguna respuesta; el mensaje sirve únicamente como anuncio one-way.
- Cuando el modo activo es `TuioOutputMode::Tuio11`, el tracker emite mensajes TUIO estándar para objetos 2D (`/tuio/2Dobj` con los comandos `set`, `alive` y `fseq`) usando como `s_id` el id de tracking de cada fiducial y como `i_id` el **id lógico de módulo** obtenido a partir de una tabla interna de mapeo fiducial→módulo. En este modo TUIO el tracker **ya no envía** `/rectai/object`/`/rectai/remove`. Si se fuerza `LegacyOsc` con `--osc`, el tracker mantiene el protocolo OSC propietario actual como fallback.
- En el core, `TrackingOscReceiver` sigue soportando ambos formatos en paralelo (TUIO y `/rectai/*`) para que versiones antiguas del tracker sigan funcionando sin cambios. El manejador de `/tuio/2Dobj set` crea/actualiza instancias de `ObjectInstance` usando `sessionId` como `tracking_id`, `i_id` como `logical_id` y coordenadas normalizadas en el sistema de mesa, y ahora también almacena los campos de velocidad TUIO `X`, `Y` y `A` en los nuevos atributos `velocity_x`, `velocity_y` y `angular_velocity` de `ObjectInstance`.

### Integración de TUIO 2Dcur como cursor/touch principal en el core
- Se ha extendido `TrackingOscReceiver` para escuchar también mensajes TUIO de cursores 2D (`/tuio/2Dcur`) además de los objetos 2D. El receptor parsea los comandos estándar `set`, `alive` y `fseq`, manteniendo un conjunto de `sessionId` activos y la última posición normalizada de cada cursor.
- Para simplificar la integración con la UI, `TrackingOscReceiver` expone ahora callbacks opcionales `setTuioCursorCallbacks(onDown, onMove, onUp)` que reciben coordenadas en el sistema de mesa (origen en el centro, radio 1) y el `sessionId` del cursor. La implementación actual trata el **primer `set`** de un `sessionId` como un "pointer down", los siguientes `set` como "move" y la desaparición del id en el siguiente `alive` como "pointer up".
- `MainComponent` registra estos callbacks en su constructor ([core/src/MainComponent.cpp](core/src/MainComponent.cpp#L480-L505)), proyectando las coordenadas de mesa a píxeles de componente mediante el mismo radio y centro que `objectTableToScreen`. Sobre esa posición de pantalla, `MainComponent` reutiliza exactamente la misma lógica que el ratón real: se ha extraído el cuerpo de `mouseDown`, `mouseDrag` y `mouseUp` a helpers privados `handlePointerDown/handlePointerDrag/handlePointerUp` que operan sobre `juce::Point<float>` y `juce::ModifierKeys`.
- Se han añadido los métodos `handleTuioCursorDown/handleTuioCursorMove/handleTuioCursorUp` en `MainComponent` ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L1725-L1756)), que convierten coordenadas TUIO (`tableX`, `tableY`) a posición de pantalla y delegan en los helpers de puntero. De este modo, un cursor TUIO 2Dcur se comporta, desde el punto de vista de la lógica de interacción, como el "ratón principal": al aparecer genera un flujo equivalente a `mouseDown`, al moverse a `mouseDrag` y al desaparecer a `mouseUp`, reutilizando toda la semántica existente (arrastre de módulos, gestos de corte, hold-mute, etc.).

### Logs de depuración para TUIO en rectai-core
- Se ha ampliado `TrackingOscReceiver` para registrar en el log de JUCE la llegada de mensajes TUIO tanto de objetos (`/tuio/2Dobj`) como de cursores (`/tuio/2Dcur`). En concreto, cada comando `set` y `alive` genera ahora una línea `[rectai-core]` con el tipo de comando, número de argumentos y un resumen de ids y coordenadas normalizadas recibidas, lo que permite verificar desde la consola que los eventos TUIO están alcanzando el core y con el formato esperado.
- El handler genérico `oscMessageReceived` también escribe una traza cuando llega un mensaje OSC con una dirección no registrada (`/rectai/object`, `/rectai/remove`, `/tuio/hello`, `/tuio/2Dobj` o `/tuio/2Dcur`), incluyendo la dirección y el número de argumentos. Esto ayuda a diagnosticar rápidamente discrepancias de puerto o de ruta (por ejemplo, si un emisor está usando otra dirección TUIO o un puerto distinto de 3333).

### Corrección de type-tags TUIO 2Dobj en rectai-tracker
- Se ha corregido el mensaje `set` TUIO 2Dobj que emite el tracker en `OscSender::sendTuio2DobjSet` ([tracker/src/OscSender.cpp](tracker/src/OscSender.cpp#L40-L120)). El payload que se construía ya contenía los 10 campos estándar de TUIO 1.1 (`set`, `s_id`, `i_id`, `x`, `y`, `a`, `X`, `Y`, `A`, `m`, `r`), es decir, 2 enteros de 32 bits y 8 floats, pero la cadena de type-tags declarada era `",siiffffff"` (2 enteros y solo 7 floats).
- Esta discrepancia hacía que el receptor OSC de JUCE (`OSCReceiver`) leyera menos elementos de los realmente presentes y detectara bytes sobrantes al final del mensaje, emitiendo el error `OSC input stream format error: wrong element content size encountered while reading` y descartando el contenido de ese paquete.
- Ahora el tracker declara correctamente la firma del mensaje como `",siiffffffff"` (2 enteros y 8 floats), alineando la longitud efectiva del mensaje con los type-tags y evitando los `OSCFormatError` al recibir TUIO 2Dobj en el core.

### Soporte de OSC Bundles en el receptor TUIO de rectai-core
- `TrackingOscReceiver` se ha adaptado para recibir no sólo mensajes OSC planos, sino también bundles anidados como los que generan `reacTIVision` y TUIO Simulator. En lugar de usar `OSCReceiver::ListenerWithOSCAddress`, ahora implementa la interfaz genérica `OSCReceiver::Listener<MessageLoopCallback>` y se registra con `addListener(this)`.
- Se ha añadido una implementación de `oscBundleReceived(const juce::OSCBundle& bundle)` en [core/src/TrackingOscReceiver.cpp](core/src/TrackingOscReceiver.cpp#L20-L80) que recorre recursivamente cada elemento del bundle (mensaje u otro bundle) y, cuando encuentra un `OSCMessage`, llama a `oscMessageReceived` con él. De este modo, todos los mensajes `/tuio/2Dobj` y `/tuio/2Dcur` contenidos dentro de un `#bundle` pasan por el mismo flujo de dispatch que los mensajes enviados de forma independiente por `rectai-tracker`.
- Esto resuelve el problema observado con TUIO Simulator: antes, al enviar únicamente bundles (sin mensajes OSC planos), el receptor basado en `ListenerWithOSCAddress` nunca llegaba a ver los mensajes internos y no disparaba `handleTuio2DobjMessage` ni `handleTuio2DcurMessage`. Tras el cambio, los bundles se “aplanan” y el core procesa todas las actualizaciones TUIO estándar, permitiendo ver tanto objetos como cursores enviados por cualquier fuente TUIO 1.1 compatible.

## 2025-12-17

### Parámetro de resolución y control de downscale en línea de comandos para rectai-tracker
- Se ha añadido un parser sencillo de argumentos en [tracker/src/main.cpp](tracker/src/main.cpp#L20-L110) que reconoce un nuevo flag opcional `--resolution=WxH`. El valor se interpreta como dos enteros positivos separados por `x` (por ejemplo, `--resolution=1920x1080`); si el formato no es válido, contiene caracteres no numéricos o alguno de los dos valores es menor o igual que 0, el parser devuelve `std::nullopt` y el binario ignora silenciosamente el flag, manteniendo el comportamiento anterior.
- Para soportar este flag se ha introducido una pequeña estructura `Resolution { int width; int height; }` y la función `parseResolutionArg(int argc, char** argv)`, que recorre los argumentos de la línea de comandos, localiza el prefijo `--resolution=`, extrae la subcadena posterior y la separa por el primer carácter `'x'`. La conversión `std::stoi` de ambas partes está protegida con `try/catch` para devolver `std::nullopt` en caso de error en lugar de lanzar.
- Además, se ha incorporado un flag booleano `--no-downscale` parseado por `hasNoDownscaleFlag(int argc, char** argv)`, que simplemente comprueba la presencia literal del argumento en la línea de comandos.
- En la inicialización del modo en vivo de `rectai-tracker` ([tracker/src/main.cpp](tracker/src/main.cpp#L110-L170)), justo después de abrir la cámara, se obtiene la resolución nativa del dispositivo mediante `cv::CAP_PROP_FRAME_WIDTH` y `cv::CAP_PROP_FRAME_HEIGHT`. Si `parseResolutionArg` ha devuelto una resolución válida, estos valores se sobrescriben con los enteros indicados en el flag antes de llamar a `trackerEngine.initialise(0, width, height, initError, enableDownscale)`, donde `enableDownscale` es `!noDownscale`.
- La clase `TrackerEngine` ha extendido la firma de `initialise` en [tracker/src/TrackerEngine.h](tracker/src/TrackerEngine.h#L20-L55) y [tracker/src/TrackerEngine.cpp](tracker/src/TrackerEngine.cpp#L40-L90) para aceptar un parámetro opcional `bool enableDownscale = true`. El bloque que antes forzaba la reducción de resolución interna a `kMaxProcessingWidth x kMaxProcessingHeight` ahora sólo se ejecuta cuando `enableDownscale` es verdadero. De este modo, al lanzar el binario con `--no-downscale`, `TrackerEngine` trabaja directamente a la resolución de entrada solicitada (tanto si viene de la cámara como del flag `--resolution`) y deja de aplicar el tope interno, evitando que las imágenes procesadas por libfidtrack se reescalen por debajo de la resolución original.
- Si no se pasa `--resolution` o si el valor es inválido, el tracker continúa inicializándose con la resolución que expone la cámara. Si no se pasa `--no-downscale`, el comportamiento por defecto sigue siendo aplicar el clamp interno a `kMaxProcessingWidth/kMaxProcessingHeight` para limitar el coste de CPU de libfidtrack. Los tests de `tracker_tests.cpp` siguen compilando y funcionado como antes al usar la sobrecarga de `initialise` con el valor por defecto de `enableDownscale`.

### Optimización de CPU en rectai-tracker (libfidtrack + OpenCV)
- Se ha reducido la carga de CPU del servicio de tracking `rectai-tracker` actuando sobre las rutas calientes identificadas en perfiles de Callgrind (`reacTIVision/ext/libfidtrack/segment.c:build_regions`, `merge_regions`, `new_region`, así como `cv::threshold` y `cv::adaptiveThreshold`). La optimización se centra en dos frentes: limitar la resolución interna de procesado para libfidtrack y simplificar la estrategia de binarización previa.
- En `TrackerEngine` ([tracker/src/TrackerEngine.cpp](tracker/src/TrackerEngine.cpp#L10-L120)) se ha introducido un tope de resolución interna para el segmenter Amoeba: constantes `kMaxProcessingWidth = 640` y `kMaxProcessingHeight = 480`. Durante `initialise`, los valores `frameWidth_` y `frameHeight_` ya no se usan directamente como vienen de la cámara; si alguno de los dos excede el tope, se calcula un factor de escala `scale = min(640 / width, 480 / height)` y se reescala ambos manteniendo la relación de aspecto. El segmenter (`initialize_segmenter`) y toda la lógica de `detectAmoebaFiducials` pasan a trabajar siempre con esta resolución acotada, mientras que `processFrameInternal` reescala cada frame de cámara a `frameWidth_ x frameHeight_` antes de binarizar.
- Este cambio hace que el coste de CPU de las funciones más caras de libfidtrack (`build_regions`, `merge_regions`, `r1_adjacent_contains_r2`, etc.) sea proporcional a un área máxima fija (aprox. 640×480) en lugar de crecer con la resolución nativa del sensor (por ejemplo, 1920×1080). En escenarios donde la cámara opera en HD o superior, el número de píxeles que atraviesan el pipeline de segmentación se reduce en un factor aproximado de 3–4×, con impacto directo en el porcentaje de instrucciones atribuidas a `segment.c` en nuevos perfiles de Callgrind.
- Adicionalmente, se ha simplificado la estrategia de binarización en `TrackerEngine::processFrameInternal` ([tracker/src/TrackerEngine.cpp](tracker/src/TrackerEngine.cpp#L120-L210)). Antes se probaban hasta cuatro estrategias por frame: Otsu normal, Otsu invertido y dos variantes de `cv::adaptiveThreshold` (normal e invertida), cada una llamando a `detectAmoebaFiducials` y, por tanto, a `step_segmenter` y `find_fiducialsX`. Esto podía multiplicar por 3–4 el coste de segmentación en frames donde no se encontraban marcadores o donde sólo funcionaba una de las estrategias adaptativas.
- Ahora `processFrameInternal` mantiene únicamente las dos primeras estrategias (Otsu normal e invertido) y ha eliminado las dos llamadas a `cv::adaptiveThreshold`. El flujo es: se convierte a escala de grises, se reescala a la resolución interna fijada, se aplica `cv::threshold(..., THRESH_BINARY | THRESH_OTSU)` y, si no hay fiduciales válidos, se intenta una segunda vez con `THRESH_BINARY_INV | THRESH_OTSU`. Si ambas fallan, la función retorna una lista vacía sin seguir probando más umbrales. Esto reduce tanto el trabajo en OpenCV (ya no se ejecutan kernels costosos de `adaptiveThreshold` por frame) como el número máximo de ejecuciones de `step_segmenter`/`find_fiducialsX` por frame a dos.
- El cambio mantiene el comportamiento básico esperado en condiciones de iluminación normales (marcadores oscuros sobre fondo claro o viceversa), que ya cubre la mayoría de casos de uso actuales sobre la mesa Reactable. Para escenarios extremos de iluminación no uniforme donde la detección dependiera exclusivamente del threshold adaptativo, la precisión podría degradarse; en caso de ser necesario, se puede reintroducir una variante adaptativa condicionada (por ejemplo, sólo tras N frames consecutivos sin detecciones) sin perder la estructura de optimización actual.
- Tras estos ajustes, se han ejecutado todos los tests del proyecto vía `ctest` (targets de `tests/` incluidos) y continúan pasando, lo que confirma que la reducción de resolución interna y la simplificación de umbrales no han roto la API de `TrackerEngine` ni los casos de prueba de `tracker_tests.cpp`.

### Flags de optimización de CPU en CMake
- Se ha añadido una opción de CMake `RECTAI_ENABLE_CPU_OPTIMIZATIONS` (activada por defecto en toolchains no-MSVC) en [CMakeLists.txt](CMakeLists.txt#L1-L80) que inyecta flags específicos de CPU únicamente en configuraciones `Release` y `RelWithDebInfo`.
- Para compiladores GCC/Clang, si el toolchain soporta las flags, se añaden `-march=native` y `-mtune=native` mediante `check_cxx_compiler_flag` y `add_compile_options`, manteniendo intactos los niveles de optimización generales (`CMAKE_BUILD_TYPE`, flags recomendados de JUCE, etc.).
- Estas flags se aplican a todos los targets del proyecto (app principal, tracker, tests y librerías) pero quedan desactivadas en `Debug` para facilitar el debugging y evitar optimizaciones agresivas en builds de desarrollo.

### Flags de -ffast-math y frame pointer en CMake
- En el CMake raíz ([CMakeLists.txt](CMakeLists.txt#L20-L80)) se han añadido flags globales específicas para GCC/Clang que actúan según el tipo de configuración:
  - En builds `Release` y `RelWithDebInfo` se activa `-ffast-math` de forma global, permitiendo optimizaciones más agresivas sobre coma flotante en todos los targets (rectai-core, rectai-tracker, tests y librerías). Esto se suma a las flags de CPU (`-march/-mtune=native`) cuando `RECTAI_ENABLE_CPU_OPTIMIZATIONS` está habilitado.
  - En builds `Debug` se fuerza `-fno-omit-frame-pointer`, lo que mantiene el frame pointer incluso con optimizaciones bajas y mejora la calidad de los perfiles (perf, Callgrind) y de los backtraces al depurar, a cambio de un coste mínimo de rendimiento en entornos no críticos.
- Estas flags sólo se aplican en toolchains no-MSVC y se expresan con `add_compile_options` y `generator expressions` por configuración, de forma que no afectan a la semántica de compilación en otros entornos (Windows/MSVC seguirá usando su configuración por defecto más las flags recomendadas proporcionadas por JUCE).

### Gating de AudioEngine en escenas totalmente idle
- Se ha añadido un mecanismo explícito de **gating de procesado de audio** para reducir la carga de CPU cuando la mesa está completamente en reposo (sin módulos dentro del área musical ni rutas de audio activas). El objetivo es que, al abrir la aplicación sin colocar ningún módulo en la zona de música o en escenas donde ningún módulo transporte audio audible, el `AudioEngine` mantenga el dispositivo inicializado pero deje de generar/samplear audio de forma continua.
- En `AudioEngine` ([core/src/AudioEngine.h](core/src/AudioEngine.h#L260-L340) y [core/src/AudioEngine.cpp](core/src/AudioEngine.cpp#L120-L215)) se han introducido dos flags atómicos:
  - `processingRequested_`: indica si la capa de UI (MainComponent) considera que hay **audio activo** en la escena (módulos dentro del área musical con cadenas de audio no muteadas).
  - `hasPendingOutput_`: lo mantiene el propio hilo de audio y marca si el bloque de callback anterior ha producido alguna muestra no nula (incluyendo colas de release de envolventes, loops o notas Sampleplay).
  Además, se expone el método público `setProcessingActive(bool)` que actualiza `processingRequested_` desde el hilo de UI.
- El callback `audioDeviceIOCallbackWithContext` ahora aplica un **early-return barato** al inicio: si `sampleRate_` es válido, pero tanto `processingRequested_` es `false` como `hasPendingOutput_` es `false`, el motor simplemente rellena los buffers de salida con ceros y retorna sin ejecutar el camino pesado de síntesis/sampling (no se llama a `SampleplaySynth::render`, no se recorren voces de oscilador ni loops). Esto permite que, en escenas totalmente idle, el coste de CPU del hilo de audio se reduzca prácticamente al mínimo, cumpliendo el requisito de no generar ni samplear audio de forma continua cuando no hay módulos activos en la zona musical.
- Para que el motor sepa cuándo puede entrar en ese estado idle sin cortar colas de sonido, se añade un contador por bloque `blockHasNonZeroOutput` en el propio callback:
  - Se inicializa a `false` al principio del procesamiento de un bloque.
  - En ambos caminos (con voces de Oscillator activas y sin ellas, donde sólo se mezclan Sampleplay y Loop), tras limitar y escribir `leftOut/rightOut` para cada muestra se comprueba si `(leftOut != 0 || rightOut != 0)`; si es así, se marca `blockHasNonZeroOutput = true`.
  - Al final del bucle de muestras, `hasPendingOutput_` se actualiza con el valor de `blockHasNonZeroOutput`. De este modo, aunque la UI deje de solicitar procesado (por ejemplo, al sacar el último módulo del área musical), el motor sigue procesando bloques mientras exista salida no nula (colas de release o loops sonando) y sólo pasa a la ruta idle cuando un bloque completo ha resultado silencioso.
- En `MainComponent_Audio::timerCallback` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L1120-L1210 y core/src/MainComponent_Audio.cpp#L1960-L2105)) se reutiliza el set existente `modulesWithActiveAudio_` —que ya se poblaba con los ids de módulos que efectivamente transportan audio audible (Oscillator con nivel > 0, Loop con `loopGain > 0`, Sampleplay con notas disparadas y no muteadas hacia el master)— para informar al motor de audio del estado de actividad:
  - Al inicio del mapeo de escena a audio se limpian `modulesWithActiveAudio_` y `moduleVoiceIndex_`.
  - Durante el cálculo de niveles de generadores, loops y Sampleplay, cada módulo cuya cadena tiene ganancia efectiva > 0 e incluye una ruta no muteada hacia el master inserta su id en `modulesWithActiveAudio_`.
  - Tras configurar las voces de `AudioEngine`, los parámetros de filtros, los loops y las waveform taps por conexión, se llama a `audioEngine_.setProcessingActive(!modulesWithActiveAudio_.empty())`. De esta manera, si no queda ningún módulo con audio audible (por ejemplo, escena vacía, todos los módulos fuera del área musical, o todas las rutas muteadas), `processingRequested_` pasa a `false` y el callback podrá entrar en la ruta idle tan pronto como se agoten las colas existentes.
- Este enfoque garantiza dos cosas:
  - **Escena completamente vacía / sin módulos en el área musical**: `modulesWithActiveAudio_` permanece vacío desde el primer tick, `processingRequested_` es `false` y, como no se ha generado ningún audio, `hasPendingOutput_` sigue siendo `false`. El callback entra directamente en el camino rápido que sólo limpia buffers, cumpliendo el requisito de no ejecutar ninguna operación de generación o muestreo en idle completo.
  - **Escenas con audio transitorio (notas, loops, releases)**: mientras haya salida no nula en el bloque (por ejemplo, por colas de release de Oscillator o loops en curso), `blockHasNonZeroOutput` se mantiene en `true` y, por tanto, `hasPendingOutput_` también. Incluso si en un tick posterior la UI marca `processingActive=false` (por ejemplo, se mutean todas las rutas o se sacan módulos del área musical), el motor continuará procesando bloques hasta observar uno totalmente silencioso, momento en el que podrá dejar de ejecutar la ruta de síntesis sin cortar abruptamente el audio.
- En conjunto, estos cambios reducen sensiblemente la carga de CPU atribuible al hilo de audio cuando se abre la aplicación sin módulos en el área musical o cuando el patch cargado (por ejemplo, `default.rtp`) se encuentra en un instante en el que no hay módulos con audio efectivo. La carga residual de CPU en estos estados pasa a estar dominada por el bucle de `repaint()` y la lógica de UI, tal y como se pretende en el roadmap de optimización de rendimiento.

### Hardlinks por colisión física entre módulos (toggle dinámico ↔ hardlink)
- Se ha corregido la detección de colisiones entre módulos dentro del área musical que disparaba el toggle de hardlinks al chocar dos tangibles compatibles. Tras la migración del modelo de coordenadas de mesa a un sistema centrado en el origen (centro `(0,0)`, radio `1`), el código de colisiones en [core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L620-L700) seguía tratando `ObjectInstance::x/y` como offsets relativos a la esquina superior izquierda del componente (`bounds.getX()/getY()` y `bounds.getWidth()/getHeight()`), en lugar de utilizar el mismo mapeo centro+radio que el render. El resultado era que, visualmente, los módulos podían entrar en contacto, pero las coordenadas usadas para el cálculo de distancia nunca llegaban a estar dentro del umbral de colisión, por lo que no se generaban/toggleaban hardlinks.
- Ahora la detección de colisiones reutiliza la función de ayuda `MainComponent::objectTableToScreen` (definida en [core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L40-L60)), que mapea las coordenadas de mesa (origen en el centro, radio 1) a píxeles de componente usando el mismo centro de la mesa y `tableRadius = 0.45 * min(width, height)` que emplea el pintado. En el bucle de colisiones se sustituye el cálculo manual:
  - Antes: `ax = bounds.getX() + objA->x() * bounds.getWidth()` / `ay = bounds.getY() + objA->y() * bounds.getHeight()` (y análogo para `bx/by`).
  - Después: `posA = objectTableToScreen(*objA, bounds)` y `posB = objectTableToScreen(*objB, bounds)`, usando sus coordenadas `posA.x/posA.y` y `posB.x/posB.y` para calcular la distancia entre centros.
  De esta forma, el radio virtual de colisión (`collisionRadius = 30 px`, con solape mínimo de 4 px) se aplica sobre las mismas posiciones que se usan para dibujar los nodos, alineando el comportamiento lógico (cuándo se considera que han “chocado”) con lo que el usuario ve en pantalla.
- La lógica de toggle del hardlink (`toggleHardlinkBetweenObjects`) no se ha modificado, pero vuelve a ser ejercitada correctamente: cuando dos módulos compatibles se tocan dentro del área musical y no existía conexión previa entre ellos, se crea una conexión `Scene::Connection` marcada como `is_hardlink = true`. Si ya existía una conexión dinámica entre ambos (no hardlink), dicha conexión se promueve a hardlink recordando la pareja en `promotedHardlinkPairs_` para poder restaurar posteriormente la conexión dinámica original cuando el usuario vuelva a separar y hacer colisionar los módulos.
- Como parte de esta corrección se ha añadido un test de dominio en [tests/scene_tests.cpp](tests/scene_tests.cpp#L560-L620) que verifica el comportamiento de promoción/democión de conexiones en `Scene::AddConnection` y `Scene::RemoveConnection` sin depender de la UI:
  - Se crea una escena con un `OscillatorModule` (`osc1`) y un `FilterModule` (`filter1`), se inserta primero una conexión dinámica `osc1 -> filter1` (`is_hardlink = false`) y se comprueba que se acepta.
  - A continuación se simula la promoción a hardlink eliminando la conexión dinámica y añadiendo una nueva conexión con los mismos extremos marcada como `is_hardlink = true`. El test exige que `Scene::AddConnection` acepte esta nueva conexión (los hardlinks no cuentan para el límite de “una única salida dinámica” por módulo) y que la única conexión presente tenga `c.is_hardlink == true`.
  - Finalmente se elimina el hardlink y se reintroduce una conexión dinámica con los mismos extremos, comprobando que vuelve a aceptarse y que la conexión resultante tiene `c.is_hardlink == false`. Este flujo refleja la semántica esperada de la UI: al chocar dos módulos con una conexión dinámica previa, ésta se convierte en hardlink; al volver a togglear, se restablece la conexión dinámica original en lugar de dejar los módulos desconectados.
- Con este cambio, la interacción “chocar módulos para conectarlos” vuelve a funcionar como en versiones anteriores: dos módulos audio-compatibles que se mueven dentro de la zona musical y se hacen tocar generan un hardlink (o promueven la conexión dinámica a hardlink) respetando las reglas globales de ruteo definidas en `Scene` (una sola salida dinámica por módulo, múltiple hardlinks permitidos, exclusión de controladores globales y rutas implícitas al `MASTER_OUTPUT_ID`). Todos los tests (`ctest`) se han ejecutado tras la modificación y siguen pasando.

- Se ha reforzado la interacción con el módulo master invisible (`Output`, id lógico `MASTER_OUTPUT_ID`) para que funcione de forma coherente tanto al cargar sesiones como durante la sesión en vivo:
  - En el bucle de colisiones entre módulos de [core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L620-L700) se siguen excluyendo explícitamente los objetos cuya `logical_id()` es `MASTER_OUTPUT_ID` a la hora de considerar **pares módulo↔módulo**, de modo que los choques físicos entre un tangible y el master no se tratan como colisión entre dos módulos visibles.
  - A continuación, en el mismo bloque, se introduce una segunda pasada que detecta choques entre cada módulo dentro del área musical y el **centro geométrico de la mesa** (usando `bounds.getCentre()` y el mismo radio virtual `collisionRadius` que para los nodos). Cuando la distancia entre el centro de un módulo y el centro de la mesa es menor que el umbral de colisión, se considera un “choque módulo↔centro” y se llama a `toggleHardlinkBetweenObjects(objId, masterObjectId)` usando el `ObjectInstance` asociado al `MASTER_OUTPUT_ID`. Gracias a esto, al "empujar" un módulo contra el centro de la mesa se puede crear/eliminar un hardlink módulo→master en tiempo real:
    - Si el módulo tenía ya una conexión dinámica auto-wired a `MASTER_OUTPUT_ID`, la primera colisión la promueve a hardlink (recreando la conexión con `is_hardlink = true`).
    - Si venía de un `<hardlink to="-1" />` cargado desde el `.rtp`, la primera colisión elimina el hardlink (sin crear una conexión dinámica nueva), y la siguiente colisión vuelve a crearlo.
    - En todos los casos se reutiliza el mecanismo de `activeHardlinkCollisions_` y `makeObjectPairKey` para debouncing, de manera que mientras el módulo permanezca pegado al centro de la mesa no se producen toggles adicionales.
  - El test de carga de hardlinks desde RTP en [tests/scene_tests.cpp](tests/scene_tests.cpp#L340-L390) se ha reforzado para comprobar que, tras cargar un patch con `<hardlink to="-1" />` para `Delay(10)`, cualquier intento posterior de insertar otra conexión `10:out -> -1:in` (tanto marcada como hardlink como dinámica) mediante `Scene::AddConnection` es rechazado. Esto blinda la invariante de “una única conexión entre el mismo par de módulos y puertos” también en el caso especial del master, y garantiza que el toggle por colisión centro↔módulo siempre actúa sobre una única conexión Delay→-1 (alternando entre presente/ausente o dinámica/hardlink según el caso) en lugar de crear duplicados.

### Hardlinks desde sesiones RTP con mute por conexión y sin duplicados dinámicos
- Se ha extendido el modelo de dominio `rectai::Connection` en [core/src/core/Scene.h](core/src/core/Scene.h#L80-L115) para incluir un flag `muted` por conexión (`bool muted{false}`), manteniendo la semántica de igualdad basada únicamente en `from_module_id`, `from_port_name`, `to_module_id` y `to_port_name`. Esto permite representar en el modelo el estado de mute persistente de una conexión (por ejemplo, un hardlink muteado cargado desde una sesión Reactable) sin afectar a las reglas de unicidad de conexiones.
- `AudioGraph::Edge` en [core/src/core/AudioGraph.h](core/src/core/AudioGraph.h#L24-L40) ahora propaga también este flag (`Edge::muted`), y el rebuild del grafo en [core/src/core/AudioGraph.cpp](core/src/core/AudioGraph.cpp#L60-L80) copia el valor desde `Scene::Connection`. Aunque el motor de audio sigue utilizando `mutedConnections_` como capa de mute dinámica, esta información queda disponible para lógica y tooling futuros.
- El serializador de escenas de texto en [core/src/core/SceneSerialization.cpp](core/src/core/SceneSerialization.cpp#L32-L60) ahora emite la palabra clave opcional `muted` al final de cada línea `connection ...` cuando `connection.muted` es verdadero, además de la ya existente etiqueta `hardlink`. Esto facilita inspeccionar escenas serializadas y distinguir conexiones dinámicas, hardlinks y hardlinks muteados.
- El loader de patches Reactable (`LoadReactablePatchFromString`) se ha ajustado en [core/src/core/ReactableRtpLoader.cpp](core/src/core/ReactableRtpLoader.cpp#L286-L360 y core/src/core/ReactableRtpLoader.cpp#L920-L985) para:
  - Mantener una lista local `pending_hardlinks` con las hardlinks declaradas en los tangibles `Delay`: por cada `<hardlink to="..." muted="..." />` se guarda `{from_module_id, target_tangible_id, muted}` sin cambiar la API de `DelayModule` (los ids se siguen almacenando también en `DelayModule::hardlink_targets()` para compatibilidad).
  - Parsear el nuevo atributo opcional `muted="1"` en las etiquetas `<hardlink>` usando `ParseBool(hl_attrs, "muted", false)`; cuando el atributo falta, la conexión se considera no muteada (`muted=false`).
  - Derivar las `rectai::Connection` de estos `pending_hardlinks` al final del loader: por cada entrada se resuelve el `target_tangible_id` usando `tangible_to_module_id` y se crea una conexión `from_module_id -> target_module_id` con puertos estándar `"out" -> "in"`, marcada con `is_hardlink=true` y el flag `muted` correspondiente. Estas conexiones se insertan en la escena a través de `Scene::AddConnection`, que sigue aplicando las invariantes globales (no duplicar conexiones, máximo una salida dinámica, etc.).
- El bloque previo que reconstruía hardlinks recorriendo todos los `DelayModule` y sus `hardlink_targets()` se ha sustituido por este nuevo recorrido sobre `pending_hardlinks`, de manera que ahora el loader dispone de toda la información necesaria (id de tangible destino y estado de mute) en el momento de crear las conexiones del modelo.
- Dado que `Scene::Connection::operator==` y las comprobaciones de duplicados en `Scene::AddConnection` **no tienen en cuenta** ni `is_hardlink` ni `muted`, cualquier intento posterior de crear una conexión dinámica con los mismos extremos y puertos que un hardlink previamente insertado se considera duplicado y se rechaza. Esto garantiza la condición pedida: al cargar una sesión, primero se materializan las conexiones de hardlink y, a continuación, tanto el loader (auto-wiring a master y conexiones Oscillator→Filter) como el runtime dinámico de `MainComponent_Audio` respetan esas conexiones y **no crean segundas conexiones coincidentes**.
- En `MainComponent`, tras cargar una sesión RTP con `LoadReactablePatchFromFile`, se inicializa ahora el estado de mute por conexión de la UI en [core/src/MainComponent.cpp](core/src/MainComponent.cpp#L116-L146):
  - Se limpian las entradas previas de `mutedConnections_`.
  - Se recorre `scene_.connections()` y, para cada conexión con `conn.muted == true`, se genera la clave lógica con `rectai::ui::makeConnectionKey(conn)` y se inserta en `mutedConnections_`.
  De esta forma, un `<hardlink to="-1" muted="1" />` en el `.rtp` se traduce automáticamente en una conexión hardlink Delay→Output marcada como muteada tanto en el modelo como en la capa de interacción: la línea correspondiente aparece ya silenciada al cargar la sesión y las gesturas de hold/cut siguen actuando sobre el mismo `connection_key`.
- Los tests de dominio en [tests/scene_tests.cpp](tests/scene_tests.cpp#L340-L390) se han ampliado para cubrir este comportamiento:
  - El test original de "Hardlink-based connection creation" comprueba ahora además que, en ausencia de atributo `muted` en `<hardlink>`, la conexión resultante desde `Delay(10)` a `Output(-1)` tiene `c.muted == false`.
  - Se ha añadido un nuevo bloque de prueba que carga un patch embebido con `<hardlink to="-1" muted="1" />` y verifica que la única conexión creada es un hardlink con `c.is_hardlink == true` y `c.muted == true`. Esto asegura que el parser de `<hardlink>` reconoce correctamente el atributo `muted` y lo propaga al modelo.
- Con estas modificaciones, los hardlinks declarados en sesiones Reactable (por ejemplo, el `Delay` id="10" con `<hardlink to="-1" />` de `Loopdemo.rtp`) se cargan como conexiones únicas Delay→Output, marcadas como hardlinks, y pueden opcionalmente empezar muteadas. La lógica dinámica de conexiones de `MainComponent_Audio` (tanto auto-wiring como conexiones geométricas) respeta estas conexiones existentes al consultar `Scene::connections()` y `Scene::AddConnection`, por lo que ya no se generan rutas duplicadas hacia el master que impidan mutear correctamente la línea. Los tests (`ctest`) se han ejecutado tras el cambio y siguen pasando.

- Se ha corregido un caso específico de interacción al cortar líneas cerca de módulos con hardlink al master (por ejemplo, `Delay -> -1`):
  - Durante el gesto de corte, el segmento entre módulo y master se representaba tanto como línea objeto→centro (radial implícita) como como conexión explícita módulo→Output(-1). El trazado podía cruzar ambas geometrías a la vez.
  - En `mouseUp`, el código de corte de radiales (`touchCutObjects_`) y el de conexiones (`touchCutConnections_`) aplicaban sendos toggles sobre la misma ruta lógica módulo→master. El primero muteba la conexión, pero el segundo la volvía a desmutear inmediatamente, dejando el audio sin cambios aunque las dos líneas se iluminaran en amarillo.
  - Ahora, en la detección de intersecciones de "conexiones módulo a módulo" en [core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L1120-L1185), se omiten explícitamente las conexiones cuyo destino es el Output invisible (`to_module_id == MASTER_OUTPUT_ID`). Es decir, los cortes sobre la ruta hacia el master se modelan sólo a través de la radial objeto→centro, evitando el doble toggle sobre el mismo `connection_key`.
  - Resultado: al cortar la línea del Delay hacia el centro de la mesa, se mutea correctamente la ruta Delay→-1 (y por extensión su radial). El comportamiento cumple los requisitos: el Output lógico `-1` sigue sin representarse como módulo visible, sólo como bola central blanca, y es posible definir hardlinks explícitos hacia `-1` y silenciarlos mediante gestos de corte/hold.

### Caché de fondo estático de la mesa en rectai-core
- En la UI principal (`MainComponent`) se ha añadido una caché de imagen (`juce::Image tableBackgroundCache_`) para el fondo estático de la mesa (fondo negro, disco central azul/rojo y anillo de gradiente que se funde con el negro). Este fondo se renderiza ahora en un buffer off-screen únicamente cuando cambian el tamaño del componente o el color de la mesa, reutilizándose en todos los repaints posteriores mediante un simple `drawImageAt` en `paint()`.
- Para soportar esta caché se han introducido dos helpers privados en `MainComponent`:
  - `invalidateTableBackground()`, que marca la caché como sucia (se llama en el constructor y en `resized()`), y
  - `renderTableBackgroundIfNeeded(const juce::Rectangle<int>& bounds)`, que recrea la imagen si el tamaño ha cambiado o la caché está marcada como sucia y dibuja en ella el mismo fondo que antes se generaba directamente en `paint()` (incluyendo gradiente y disco sólido).
- El bloque de pintado del fondo en `MainComponent_Paint.cpp` se ha sustituido por una llamada a `renderTableBackgroundIfNeeded()` seguida de un blit de `tableBackgroundCache_`. El resto de la lógica de `paint` (waveforms, conexiones, pulsos, dock, etc.) permanece inalterada. Este cambio reduce sensiblemente el trabajo por frame en reposo, ya que las rutas calientes de JUCE (`EdgeTable`, `PixelARGB::set/getNativeARGB`, gradientes radiales) dejan de ejecutarse a 240 Hz y solo se recalculan cuando la geometría de la mesa cambia.

### Caché de iconos del atlas para módulos y dock
- Se ha añadido en `MainComponent` una caché de iconos del atlas (`atlasIconCache_`) que almacena imágenes `juce::Image` en formato `SingleChannel` ya reescaladas por sprite y tamaño de destino. La clave de caché combina el identificador lógico del icono (`icon_id()` de cada módulo) con las dimensiones enteras de destino (`"iconId#WxH"`), de modo que cada combinación sprite+tamaño se re-muestrea una sola vez desde el atlas original de 2048×2048 píxeles.
- El método privado `getCachedAtlasIcon(const std::string& iconId, int destWidth, int destHeight)` encapsula esta lógica: valida que el atlas está cargado, localiza el `AtlasSprite` correspondiente y, si aún no existe una entrada válida en `atlasIconCache_`, crea una nueva imagen `SingleChannel` del tamaño solicitado y copia en ella la máscara alfa del sprite usando `Graphics::drawImage`. El resultado se guarda en la caché y se devuelve como `juce::Image` (compartido por referencia), listo para ser tintado en `paint()` mediante `setColour`.
- En `MainComponent_Atlas.cpp`, todas las rutas de carga y fallo de `loadAtlasResources()` se han actualizado para limpiar `atlasIconCache_` junto con `atlasImage_` y `atlasSprites_`, garantizando que al recargar el atlas (o si falla la carga) no queden iconos desincronizados con la imagen de origen.
- En `MainComponent_Paint.cpp`, el pintado de iconos dentro del cuerpo de los nodos de la mesa se ha modificado para que, cuando exista `icon_id()` y sprite en el atlas, se utilice preferentemente la imagen preescalada de `getCachedAtlasIcon`. Una vez calculados los bounds destino (`destX/destY/destW/destH`) a partir de `iconBounds`, se obtiene la imagen cacheada y se dibuja con `drawImageAt` tras fijar el tinte dinámico según el brillo del `bodyColour`. Si el icono corresponde a un `TempoModule`, se mantiene el comportamiento de rotar la imagen alrededor del centro del nodo mediante `AffineTransform::rotation`, pero ahora aplicando la transformación a la imagen pequeña ya escalada en lugar de al atlas completo. Si por cualquier motivo la caché no devuelve una imagen válida, se conserva como fallback el `drawImage` directo desde `atlasImage_` recortando el rectángulo del sprite.
- El bloque de pintado de iconos del dock (tira derecha) se ha adaptado de forma análoga: para cada módulo presente en el dock se calcula `iconBounds` y, en lugar de reescalar cada frame el rectángulo del sprite desde `atlasImage_`, se intenta reutilizar una imagen preescalada desde `getCachedAtlasIcon`. Cuando ésta es válida, el icono se dibuja con `drawImageAt` usando la misma lógica de tinte por brillo de fondo; sólo en el caso de que la caché no tenga aún esa entrada se recurre al `drawImage` sobre el atlas grande. Como la geometría del dock (radio de nodo y, por tanto, tamaño de icono) es prácticamente estable, cada icono del dock se calcula una sola vez y se reutiliza en todos los repaints.
- Esta caché reduce de forma apreciable el trabajo de píxel que antes se hacía en caliente: en lugar de re-samplear el atlas de 2048×2048 para cada icono visible en mesa y dock en cada frame, la reescala se realiza únicamente la primera vez que se necesita un icono de un tamaño concreto; las repeticiones posteriores se limitan a blits de imágenes pequeñas en `SingleChannel` con tinte, que son mucho más baratas que las combinaciones de recorte+escalado+mezcla sobre el atlas completo observadas como hotspots (`PixelARGB::blend`, `ImageFill::copyRow`, etc.) en los perfiles de Callgrind.

### Manejo de ratón sin repaints extra (mouseMove/mouseWheelMove)
- Se ha añadido un override explícito de `mouseMove` en `MainComponent` que delega directamente en `juce::Component::mouseMove` y **no llama a `repaint()`**. Esto garantiza que los eventos de hover puro (movimiento de ratón sin botones pulsados) no añaden repaints adicionales a los ya generados por el timer de 240 Hz ni por los gestos de drag/click, acotando el coste de CPU de “mover el ratón por encima de la mesa” cuando no hay interacción activa.
- En `mouseWheelMove`, el bloque de scroll del dock derecho se ha ajustado para que sólo dispare un `repaint()` cuando `dockScrollOffset_` cambia realmente. Antes se recalculaba el offset y se repintaba incluso cuando el contenido ya estaba en el límite superior/inferior y el `jlimit` devolvía el mismo valor, lo que hacía que al insistir con la rueda en los extremos se generasen frames de más sin cambio visual. Ahora se compara `previousOffset` con el nuevo valor y sólo en caso de diferencia se solicita repintado.
- Los usos de la rueda sobre módulos Tempo y Loop ya estaban condicionados a cambios efectivos (por ejemplo, en Tempo no se repinta si el nuevo BPM es igual al actual), por lo que no se han tocado. Con estos ajustes, la combinación de hover + wheel sobre zonas sin cambios reales deja de provocar repaints innecesarios, reduciendo picos de CPU asociados a eventos de entrada que no alteran el estado visual.
### Mute-on-hold coherente para Loop, Sampleplay y Oscillator
- Se ha extendido la lógica de **mute temporal al mantener pulsado sobre una línea de audio (mute on hold)** para que afecte de forma coherente a todos los módulos que generan sonido, no sólo a `Oscillator`. Hasta ahora, al mantener el ratón sobre la radial de un módulo `Loop`, la línea se partía visualmente pero el audio del loop seguía sonando; con este cambio, la salida de audio también queda silenciada mientras dura el gesto.
- En `MainComponent_Audio.cpp` se ha añadido un chequeo explícito de `activeConnectionHold_` en dos puntos:
  - Para el camino global de `Sampleplay` (ganancia `sampleplayOutputGain`): si el hold está activo sobre la radial del módulo Sampleplay o sobre una de sus conexiones de audio (según `connection_key` de `activeConnectionHold_` y la lista de `audioEdges`), se fuerza `sampleplayOutputGain = 0.0F` mientras dure el gesto, independientemente del estado de mute persistente de las conexiones. Esto hace que el sonido de SoundFont se detenga de forma inmediata al mantener pulsado sobre la línea, igual que ocurre con los generadores procedurales.
  - Para cada módulo `Loop`: dentro del bucle que configura `setLoopModuleParams`, se calcula `isHeldForLoop` combinando el id de objeto (`object_id` de `activeConnectionHold_`) y la clave de conexión retenida (`connection_key`). Cuando `isHeldForLoop` es verdadero, el `loopGain` calculado a partir del parámetro `amp` y del volumen global se fuerza a `0.0F` antes de llamar a `setLoopModuleParams`. De este modo, los loops siguen avanzando internamente en fase (según el contador global de beats), pero su contribución a la mezcla pasa a ser silencio durante el hold.
- En `MainComponent_Paint.cpp` se ha generalizado el pintado de la radial en estado de hold para que la **primera mitad de la línea (módulo → punto de split)** muestre una waveform representativa del tipo de módulo, tal y como ocurre ya en el estado normal:
  - Para módulos `Sampleplay`, se resuelve la conexión lógica `Sampleplay → Output(-1)` y se usa `audioEngine_.getConnectionWaveformSnapshot` sobre esa clave para obtener la waveform que se dibuja desde el módulo hasta el punto de split. De este modo, al hacer mute-on-hold sobre la radial de Sampleplay se sigue viendo la forma de onda recortada hasta el punto exacto donde se ha hecho clic.
  - Para módulos `Loop`, se llama directamente a `audioEngine_.getLoopModuleWaveformSnapshot` con el id lógico del módulo, normalizando la señal y dibujando la waveform del loop unicamente en el tramo módulo → split. La amplitud visual se escala con el mismo `visualLevel` y el mismo grosor de línea usado en el modo normal, de forma que la mitad activa conserva exactamente el aspecto habitual de la radial de Loop.
  - Para el resto de generadores procedurales (Oscillator y similares) se mantiene la rama existente que usa los buffers `voiceWaveformsPost` y `voiceRmsPost` por voz. Si no hay waveform disponible para el módulo en cuestión, se cae a un fallback de línea blanca recta entre el módulo y el punto de split.
- En todos los casos, la **segunda mitad de la línea (split → centro)** se sigue dibujando como un segmento discontinuo (línea discontinua blanca semitransparente), indicando claramente que la salida hacia el master está temporalmente silenciada. La combinación de waveform parcial + tramo punteado da como resultado una UX consistente: el usuario ve hasta dónde llega la señal antes del corte y percibe visualmente que, a partir de ahí, el audio está siendo bloqueado.
- Los tests (`ctest`) se han ejecutado tras los cambios y siguen pasando, lo que confirma que la integración del estado de hold en el runtime de audio (Loop/Sampleplay) y en la capa de pintado no rompe el resto de rutas de audio ni la serialización de la escena.

### Refactor de drags en paneles de módulo (ActivePanelDrag)
- Se ha generalizado el manejo de gestos de drag dentro de los paneles de detalle por módulo (ventanas de Envelope, LoopFiles, etc.) introduciendo un estado único `ActivePanelDrag` en `MainComponent` ([core/src/MainComponent.h](core/src/MainComponent.h#L430-L460)). Este estado captura el tipo de drag de panel (`PanelDragKind`), el `moduleId` propietario y un índice opcional para subcontroles (por ejemplo, el índice de barra en Envelope).
- El objetivo es que, cuando un gesto **empieza dentro de un panel de módulo**, ese puntero quede “capturado” por dicho panel y sus movimientos posteriores **no se interpreten como gestos globales** sobre la mesa (corte de líneas, arrastre de módulos, side controls, etc.). De este modo, al arrastrar una barra de Envelope o desplazar el `TextScrollList` de LoopFiles no se silencian líneas por accidente ni se inicia ningún otro tipo de drag en paralelo.
- En `handlePointerDown` ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L360-L420)) se ha sustituido el reseteo específico de sobres `activeEnvelopeDrag_` por `activePanelDrag_`, y los dos casos de inicio de drag de panel pasan ahora a rellenar `ActivePanelDrag`:
  - Al hacer down sobre una barra de Envelope, se guarda `kind = kEnvelopeBar`, `moduleId = panelState.moduleId` y `index = bar` (0 = Attack, 1 = Decay, 2 = Sustain, 3 = Release).
  - Al hacer down dentro del área de contenido de LoopFiles, justo antes de llamar a `TextScrollList::beginPointerAt`, se guarda `kind = kLoopFilesScroll`, `moduleId = panelState.moduleId` e `index = -1`.
- En `handlePointerDrag` ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L520-L620 y [core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L1820-L1895)) el código que antes dependía de `activeLoopFilesDrag_` y `activeEnvelopeDrag_` se ha unificado sobre `activePanelDrag_`:
  - Mientras `activePanelDrag_.kind == kLoopFilesScroll`, los drags se envían exclusivamente al `TextScrollList` del panel LoopFiles correspondiente (`dragPointerTo(localY)`), usando la misma geometría y rotación que el hit-test de down, y retornando antes de evaluar el bloque de line-cut.
  - Mientras `activePanelDrag_.kind == kEnvelopeBar`, los drags actualizan continuamente el ADSR del módulo (`AudioModuleWithEnvelope`) calculando la posición local dentro del rectángulo de barras y mapeando `y` a `value01` visual, igual que antes, pero ahora sin un tipo de drag separado por panel.
- En `handlePointerUp` ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L2515-L2635)) se ha reemplazado el bloque específico de LoopFiles por uno genérico que consulta `activePanelDrag_` y, cuando `kind == kLoopFilesScroll`, reproyecta la posición de release al espacio local del panel, llama a `TextScrollList::endPointerAt(localY)` y sólo después resetea `activePanelDrag_`. Otros tipos de drag de panel (como Envelope) simplemente se limpian en este punto, sin lógica adicional.
- Con este refactor:
  - El patrón de “captura de drag por panel” queda centralizado en un único estado (`ActivePanelDrag` + `PanelDragKind`), facilitando la incorporación futura de nuevos paneles/controles con drags propios sin riesgo de interferir con gestos globales.
  - La semántica existente de Envelope y LoopFiles se mantiene, pero ahora ambos casos comparten el mismo mecanismo de captura; los gestos de corte de líneas siguen estando restringidos a gestos cuya `mouseDown`/`pointerDown` empezó en espacio vacío de la zona musical, no dentro de un panel de módulo.

### Hitbox circular invisible para interacción con el módulo (evitar colisiones con barras laterales)
- En `MainComponent_Input.cpp` se ha ajustado el hit-test de ratón para los módulos de la mesa de forma que exista un **círculo invisible de interacción** que coincide con el cuerpo circular del módulo (`nodeRadius = 26.0F`). Este círculo se utiliza para decidir si un click debe interpretarse como interacción directa con el módulo (por ejemplo, arrastrar para mover el tangible) o con los controles laterales.
- Dentro de `mouseDown`, justo antes de evaluar las barras laterales de Freq y Gain, se calcula para cada objeto la distancia del click (transformado a espacio local cuando el módulo está dentro del área musical) al centro del nodo. Si el punto de click cae dentro del radio del círculo del módulo (`insideModuleCircle`), las lambdas de hit-test de las barras laterales siguen funcionando pero sus resultados sólo se consideran válidos cuando `!insideModuleCircle`.
- En la práctica, esto significa que clicks realizados claramente "dentro" del círculo del módulo ya **no activan las barras laterales** aunque sus rectángulos de hit se solapen parcialmente con esa zona; en su lugar, esos clicks pasan al bloque posterior de selección de objeto, que marca `draggedObjectId_` y permite arrastrar el módulo como hasta ahora.
- La geometría de las barras laterales (izquierda Freq, derecha Gain) y su área de interacción permanece intacta hacia el exterior del nodo, por lo que el usuario sigue pudiendo hacer click y arrastrar sobre los arcos laterales cuando apunta a la zona que rodea al módulo. El cambio únicamente reserva el área del cuerpo circular para la interacción principal con el tangible, evitando la sensación de estar colisionando con los controles de volumen/frecuencia cuando se hace click aparentemente en el centro del módulo.
 
### Selector de modos de módulo (botón inferior + menú radial interactivo)
- Se ha introducido un descriptor genérico de modos de ajuste `AudioModuleMode` y una pequeña API de modos en `rectai::AudioModule` en [core/src/core/Scene.h](core/src/core/Scene.h#L80-L190) y [core/src/core/Scene.cpp](core/src/core/Scene.cpp#L90-L150). Cada módulo puede exponer ahora una lista ordenada de modos soportados (`supported_modes()` devuelve un `AudioModuleModes`), donde cada modo incluye un id numérico estable (`id`), un identificador lógico corto (`type`, por ejemplo "sine"/"lowpass") y el `icon_id` del atlas. La UI dispone de un índice de modo activo (`current_mode_index()` y `set_mode(int)`) y helpers genéricos de ciclo (`cycle_mode_forward`/`cycle_mode_backward`) que permiten cambiar de modo sin conocer la implementación interna del módulo. Además, la implementación por defecto de `on_mode_changed(int, const AudioModuleMode&)` en `AudioModule` ahora sincroniza automáticamente el `icon_id` visual del módulo con el `icon_id` del modo seleccionado, de forma que cualquier módulo que sólo defina `supported_modes()` pero no sobreescriba `on_mode_changed` obtiene gratis el cambio de icono al cambiar de modo. Para los módulos que sí sobreescriben `on_mode_changed` (como `OscillatorModule` y `FilterModule`), la implementación concreta delega en la base (`AudioModule::on_mode_changed`) para reutilizar este comportamiento de icono por defecto.

- Internamente, `AudioModule` inicializa ahora su índice de modo a `-1` en lugar de `0` ([core/src/core/Scene.h](core/src/core/Scene.h#L230-L270)). Esto garantiza que la **primera** llamada a `set_mode(0)` (o `set_mode("sine")` en el constructor de `OscillatorModule`) no se trate como un no-op y siempre dispare `on_mode_changed`, fijando el icono inicial al del modo por defecto (`oscillator_sine` en el caso del Oscillator). Los módulos sin modos siguen devolviendo `-1` en `current_mode_index()`.

- Se ha añadido también un helper de conveniencia `current_mode()` en `AudioModule` ([core/src/core/Scene.h](core/src/core/Scene.h#L150-L190), [core/src/core/Scene.cpp](core/src/core/Scene.cpp#L110-L140)) que devuelve un puntero al `AudioModuleMode` activo (o `nullptr` si el módulo no expone modos o el índice es inválido). Esto simplifica el código de consumidores como `MainComponent_Audio`, que puede consultar directamente `current_mode()->id` para derivar el tipo de filtro o forma de onda sin volver a indexar sobre `supported_modes()`.
- Los módulos `Oscillator` y `Filter` implementan esta API de modos en [core/src/core/AudioModules.h](core/src/core/AudioModules.h#L90-L210) y [core/src/core/AudioModules.cpp](core/src/core/AudioModules.cpp#L60-L240): el Oscillator expone cuatro modos (`sine`, `saw`, `square`, `noise`) cuyos `icon_id` coinciden con los que ya usaba el módulo y mapean 1:1 con el enum `Waveform`, mientras que el Filter expone tres modos (`filter_lowpass`, `filter_bandpass`, `filter_hipass`) alineados con su enum interno `Mode`. En ambos casos `current_mode_index()` refleja el estado actual del módulo y `set_mode(int)` valida el índice y delega en los setters existentes (`set_waveform`, `set_mode`).
- Se han añadido aserciones de dominio en [tests/scene_tests.cpp](tests/scene_tests.cpp#L1-L260) que verifican el tamaño y contenido de `supported_modes()` para Oscillator y Filter, el valor inicial de `current_mode_index()` y el comportamiento ante cambios de modo tanto vía `cycle_waveform`/`cycle_mode` como vía `set_mode(int)`, incluyendo el tratamiento de índices fuera de rango (no cambian el modo actual).
- En la UI principal, cada módulo que expone modos soportados dibuja ahora un **botón de ajuste** en la ranura inferior entre las barras laterales Freq/Gain. Este botón se pinta en [core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L2130-L2185) como un pequeño rectángulo redondeado bajo el círculo del módulo que siempre muestra el `icon_id` principal del módulo (reutilizando la caché del atlas) y actúa como ancla del menú radial de modos.
- El controlador de entrada se ha ampliado en [core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L560-L640 y core/src/MainComponent_Input.cpp#L1180-L1280) con nuevo estado por-módulo (`modeControlObjectId_`, `modeDragStartLocal_`, `modeSelection_`) que detecta clicks sobre el botón inferior y gestos de arrastre hacia la izquierda en el espacio local del módulo (teniendo en cuenta su rotación en la mesa). Cuando el usuario arrastra suficientemente hacia el lado izquierdo local, se marca `modeSelection_.menuVisible = true` para ese módulo y se fuerza un repintado.
- Cuando el menú de modos está visible, `MainComponent::paint` dibuja una superposición semitransparente sobre las barras laterales para atenuarlas y, a continuación, un **anillo de iconos** con un sprite por cada modo soportado, distribuidos desde la parte inferior del nodo hasta el lado izquierdo local, en [core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L2185-L2245). El modo activo se resalta con un tamaño ligeramente mayor y mayor opacidad, reutilizando `supported_modes()[i].icon_id` y `current_mode_index()` para decidir icono y énfasis.
- Finalmente, el manejador de `handlePointerUp` se ha hecho interactivo para este menú radial en [core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L1537-L1815): se mantiene la última posición conocida del puntero en `lastPointerPosition_` y, si al soltar el botón el menú radial sigue visible para un módulo dado, se replica la misma geometría usada en el pintado (centro del módulo, radio del anillo, ángulos entre 270° y 180° y escalado del icono activo) pero en coordenadas locales del módulo. Si la posición de liberación cae dentro del radio de hit de alguno de los iconos, se llama a `set_mode(i)` sobre el `AudioModule` correspondiente, actualizando inmediatamente tanto el `icon_id` central como el resaltado del menú en el siguiente frame. El menú se cierra al finalizar el gesto, manteniendo la relación 1:1 entre selección visual y modo lógico del módulo.

### Ajuste geométrico del selector de modos (alineación con semicírculo Freq)
- Se ha afinado la geometría del menú de modos para que los iconos sigan con mayor precisión el semicírculo de la barra de Freq y el icono inferior quede razonablemente alineado con el botón de modo, desplazando además la columna completa 7 px hacia la izquierda (`extraLeft = 7.0f`) para despegar visualmente los iconos de la barra de Freq. En el pintado ([core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L2170-L2335)) se mantienen los ángulos derivados de `sliderTop/sliderBottom` pero se aplica ahora una ligera compresión del arco por la parte superior (`angleTop = angleBottom + (angleTop - angleBottom) * 0.85f`) para que los iconos altos no se salgan de la curva de Freq.
- La lógica de hit-test en `handlePointerUp` se ha actualizado para reutilizar exactamente la misma geometría angular que el pintado (misma compresión y mismos ángulos inferior/superior) y se ha reducido de 5 a 4 el número de “slots virtuales” (`maxSlots = 4`) tanto en pintado como en input ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L1840-L1995)). Esto aumenta ligeramente la separación vertical entre iconos (al repartir 3–4 iconos sobre un arco algo más corto) y mantiene las zonas clicables alineadas con la curva visible.

### Doble control de volumen en Oscillator: bola blanca (módulo) y bola gris (Sequencer)
- Se ha ajustado la interacción entre el `Sequencer` y los módulos `Oscillator` para que los mensajes de control de volumen (velocidad de nota) ya **no modifiquen directamente** el parámetro `gain` del Oscillator, que corresponde a la **bola blanca** en la barra lateral derecha y representa el volumen de salida del módulo fijado por el usuario.
- En `MainComponent` se introduce un mapa `oscillatorSequencerGain_` que almacena, por id de módulo, un factor de ganancia normalizado en `[0,1]` controlado exclusivamente por el `Sequencer` cuando `sequencerControlsVolume_` es `true`. Este factor se actualiza en `MainComponent_Audio::timerCallback`, dentro de `runSequencerStep`:
  - Cuando un paso activo del Sequencer dispara un Oscillator, se toma `step.velocity01` como valor de volumen del paso, se clampa a `[0,1]` y se guarda en `oscillatorSequencerGain_[oscId]`.
  - Cuando un paso está desactivado y el Sequencer está autorizado a controlar volumen, en lugar de forzar `gain = 0` sobre el módulo, se fija `oscillatorSequencerGain_[oscId] = 0.0F`, dejando intacto el valor de `gain` elegido por el usuario.
- La mezcla de audio de generadores en `MainComponent_Audio.cpp` se ha actualizado para que el nivel efectivo de cada cadena cuyo origen es un `OscillatorModule` se base en **dos componentes**:
  - `userGainParam`: el parámetro `gain` del módulo (bola blanca), leído y clampeado a `[0,1]`.
  - `seqGain`: el factor de ganancia controlado por el Sequencer, leído de `oscillatorSequencerGain_` cuando existe o asumido como `1.0F` en ausencia de modulaciones.
  El `gainParam` que alimenta el cálculo de `calculatedLevel` se define ahora como `min(userGainParam, seqGain)` cuando el módulo es un Oscillator y `sequencerControlsVolume_` está activo. De esta forma, el Sequencer **puede reducir el volumen** efectivo de una cadena de Oscillator pero **nunca aumentarlo** por encima del valor fijado en la bola blanca.
- Visualmente, la barra de volumen lateral derecha en `MainComponent_Paint.cpp` se ha extendido para representar **ambos niveles**:
  - La bola blanca sigue representando el valor del parámetro `gain` del módulo (controlado por clic/drag del usuario) y mantiene el mismo comportamiento de siempre.
  - Para módulos `OscillatorModule` y sólo cuando `sequencerControlsVolume_` es `true`, se dibuja una **segunda bola gris** en la misma barra, cuyo valor vertical corresponde al `seqGain` del mapa `oscillatorSequencerGain_`, clampeado con `cappedSeq = min(gainValue, seqGain)`.
  - La bola gris sólo se muestra cuando el Sequencer está intentando **bajar el volumen** respecto al nivel del módulo (es decir, cuando `cappedSeq < gainValue`), de modo que visualmente actúa como un “segundo cursor” que se mueve por debajo de la bola blanca siguiendo los pasos del Sequencer.
- La bola gris es puramente informativa y **no es interactiva**: la lógica de input en `MainComponent_Input.cpp` no se ha modificado y sigue utilizando únicamente la barra de `gain` como región clicable, mapeando los clics y drags al parámetro `gain` del módulo (bola blanca). Cualquier interacción del usuario con la barra sigue afectando exclusivamente a la bola blanca; la bola gris se limita a reflejar, en la misma barra, el volumen instantáneo que el Sequencer está imponiendo a ese Oscillator.
- A nivel de sonido, el resultado es que:
  - El volumen audible de un Oscillator conectado a un Sequencer está gobernado por la combinación `min(gain_módulo, factor_Sequencer)`.
  - El usuario ve siempre el volumen máximo permitido para ese módulo (bola blanca) y, cuando el Sequencer atenúa la señal, observa la bola gris moverse por debajo hasta donde llegue el paso actual, sin que ésta pueda **superar** nunca la altura de la bola blanca.

### Ajustes de la vista Envelope ADSR: mapeo no lineal y sustain basado en points_y
- Se ha refinado la implementación de la pestaña **Envelope** para que el mapeo entre la posición del puntero y los valores ADSR sea coherente con la curva no lineal acordada y con la semántica de sustain del modelo de envolventes. El helper de UI `MainComponent_ModulePanelEnvelope` ([core/src/MainComponent_ModulePanelEnvelope.h](core/src/MainComponent_ModulePanelEnvelope.h), [core/src/MainComponent_ModulePanelEnvelope.cpp](core/src/MainComponent_ModulePanelEnvelope.cpp)) define ahora dos funciones auxiliares explícitas: `moduleEnvelopeVisualFromNormalised(float)` y su inversa `moduleEnvelopeNormalisedFromVisual(float)`. Ambas implementan una curva `sqrt` sobre el valor normalizado en `[0,1]`, de modo que valores muy pequeños de tiempo (por ejemplo, `20/2000` o `125/2000`) ocupan una fracción mayor de la altura de la barra y son más fáciles de ajustar con precisión.
- En el pintado de la vista ADSR (`paintModuleEnvelopeView`), las barras de **Attack**, **Decay** y **Release** siguen mostrando tiempos en milisegundos normalizados respecto a sus máximos (`kModuleEnvelopeMaxAttackMs = kModuleEnvelopeMaxDecayMs = kModuleEnvelopeMaxReleaseMs = 2000 ms`) y se convierten a altura visual aplicando `moduleEnvelopeVisualFromNormalised` sobre el valor lineal `time_ms / max_ms`. La barra de **Sustain**, en cambio, se ha desacoplado de `Envelope::duration` y pasa a representar el **nivel de sustain** de la envolvente: su altura se obtiene ahora directamente de `envelope.points_y[2]` (tercer punto de la curva, interpretado como valor normalizado 0–1) sin aplicar curva adicional, de modo que la barra de sustain se visualiza de forma lineal con respecto al nivel de sustain definido en el modelo.
- En la capa de input (`handlePointerDown` y `handlePointerDrag` en [core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp)), el hit-test de barras (`hitTestModuleEnvelope`) devuelve siempre un valor visual `value01` en `[0,1]` que indica la altura de la barra bajo el puntero (0 en la base, 1 en la parte superior). Para Attack, Decay y Release, ese valor visual se pasa por la inversa `moduleEnvelopeNormalisedFromVisual` antes de escalarlo por el máximo en ms, asegurando que:
  - La **barra se dibuja exactamente hasta la altura del click/drag del usuario** (el valor visual se conserva tal cual para el relleno), y
  - El valor interno en ms se ajusta siguiendo la curva `sqrt`, dando más resolución práctica a tiempos cortos sin romper la correspondencia visual.
- La barra de **Sustain** se trata de forma especial: al hacer click o arrastrar sobre la tercera barra (índice `barIndex == 2`), el valor visual `value01` se usa de forma lineal para actualizar el nivel de sustain en el `Envelope` del módulo. Concretamente, se obtienen referencias mutables a `envelope.points_y[2]` y `envelope.points_y[3]` (cuando existen) y se les asigna el valor `sustain01 = clamp(value01, 0, 1)`, manteniendo así un plateau horizontal entre el tercer y cuarto punto de la envolvente con amplitud igual al sustain. De esta manera, el control de sustain de la UI actúa directamente sobre la curva `points_y`, alineando la representación visual con los datos que usa el motor de audio para inferir el plateau.
- Para que los cambios de sustain se reflejen en el sonido **de forma inmediata y sin necesidad de retrigger** de la nota, se ha ampliado el helper `MainComponent::updateOscillatorSustainFromEnvelope` ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L2116-L2224), [core/src/MainComponent.h](core/src/MainComponent.h#L95-L110)). Este helper ya analizaba la envolvente Reactable (`points_x`/`points_y`) para detectar el plateau de sustain y derivar el `sustainLevel` y el tipo de envolvente (one-shot vs sustain). Ahora se invoca también cada vez que el usuario modifica la barra de sustain (click o drag) además de al aplicar presets, recalculando inmediatamente el `sustainLevel` efectivo y llamando a `audioEngine_.setVoiceEnvelope` sobre la voz de `Oscillator` actualmente asociada al módulo. El resultado es que, al subir o bajar la barra de sustain (por ejemplo, de 0 a 0.5), la bola gris de volumen controlado por el Sequencer y el nivel audible del Oscillator se ajustan al instante sin necesidad de cambiar la nota ni mutear/desmutear la línea.
- Por último, se ha unificado el comportamiento de drag continuo sobre las barras ADSR para que utilice el mismo mapeo que el click inicial: al arrastrar sobre Attack, Decay o Release, `handlePointerDrag` calcula de nuevo la fracción visual de altura, la convierte con `moduleEnvelopeNormalisedFromVisual` y actualiza el tiempo en ms con el máximo correspondiente, garantizando que en todo momento la barra siga exactamente el dedo/puntero del usuario aunque el valor interno se mapee con la curva no lineal. En el caso de Sustain, el drag actualiza linealmente `points_y[2]`/`[3]` y vuelve a llamar a `updateOscillatorSustainFromEnvelope`, manteniendo la sincronía inmediata entre UI, modelo y motor de audio durante toda la interacción.

### Actualización incremental de inside_music_area en cada tick
- La función `MainComponent::refreshInsideMusicAreaFlags` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L40-L70)) se ejecuta en cada tick del timer para mantener sincronizado el flag `inside_music_area_` de cada `ObjectInstance` con la geometría actual de la mesa (coordenadas normalizadas en el disco de radio 1). Hasta ahora, el código tomaba un snapshot de `scene_.objects()`, recalculaba `computeInsideMusicArea` para cada objeto, asignaba el nuevo valor y llamaba a `scene_.UpsertObject(updated)` incondicionalmente en todos los casos.
- Para reducir trabajo innecesario en escenas estables (por ejemplo, módulos que permanecen docked o inmóviles durante largos periodos), se ha introducido una comprobación previa antes de hacer el upsert: se calcula `inside = computeInsideMusicArea(obj)` a partir del snapshot y, si `inside` coincide con el valor almacenado actualmente en `obj.inside_music_area()`, se omite cualquier actualización sobre la `Scene` para ese objeto.
- Sólo cuando el valor recién calculado difiere del flag almacenado (por ejemplo, cuando un módulo cruza por primera vez el borde del disco musical, deja de estar docked o se ha añadido nuevo dentro del área), se crea una copia `updated` del objeto, se llama a `updated.set_inside_music_area(inside)` y se invoca `scene_.UpsertObject(updated)`. Esto mantiene intacta la semántica original (el modelo siempre refleja correctamente qué objetos están dentro del área musical), pero evita tráfico de upserts redundantes en ticks donde la posición y el estado de dock de los objetos no han cambiado.
- Este cambio ayuda a rebajar el coste per-tick de la fase de “sincronización de flags de área musical”, especialmente en patches con muchos objetos estáticos, sin introducir nuevas estructuras de caché: se reutiliza el propio `inside_music_area_` como referencia de estado previo y se conserva el patrón de snapshot para no invalidar el iterador mientras se modifican objetos en la `Scene`.

### Desacoplo de frecuencia de timer y de repaints de UI
- El `MainComponent` usa un `Timer` para sincronizar la lógica de audio/UI con el transporte global. Tras los ajustes al Sequencer y al gating de audio, el timer se ejecuta a 240 Hz (`startTimerHz(240)`) para reducir el jitter en el disparo de pasos: `timerCallback` consulta `audioEngine_.transportBeats()`, avanza `sequencerAudioStepCounter_` y ejecuta todos los pasos intermedios necesarios para mantener el ritmo alineado con el hilo de audio.
- En versiones anteriores, cada `timerCallback` terminaba inevitablemente en un `repaint()`, lo que implicaba entrar en la ruta completa de `MainComponent::paint` hasta 240 veces por segundo. Dado que los perfiles de Callgrind mostraban que el coste dominante de CPU está en las funciones de rasterizado software de JUCE (`EdgeTableFillers::ImageFill::copyRow`, `EdgeTableFillers::SolidColour::handleEdgeTableRectangle`, `PixelARGB::blend/set`), este acoplamiento timer=repaint generaba una gran carga incluso en escenas con poca actividad visual.
- Para aliviar este cuello de botella sin empeorar la precisión temporal del Sequencer, se ha introducido un timestamp independiente `lastRepaintSeconds_` en `MainComponent` ([core/src/MainComponent.h](core/src/MainComponent.h#L120-L150)) inicializado junto con `lastTimerSeconds_` en el constructor ([core/src/MainComponent.cpp](core/src/MainComponent.cpp#L600-L640)).
- Al final de `MainComponent::timerCallback` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L2440-L2625)) ya no se llama siempre a `repaint()`. En su lugar, se calcula un intervalo mínimo entre repaints `minRepaintInterval = 1.0 / kMaxRepaintsPerSecond` con `kMaxRepaintsPerSecond = 120.0` y sólo se dispara `repaint()` cuando `nowSeconds - lastRepaintSeconds_ >= minRepaintInterval`. Tras cada repaint efectivo, `lastRepaintSeconds_` se actualiza al valor actual de `nowSeconds`.
- Con este cambio, la lógica de audio y de Sequencer (incluida la generación de pulsos BPM y el avance de steps de audio) sigue corriendo a 240 Hz, pero el pipeline de pintura de JUCE se ejecuta, como máximo, a ~120 fps. Para el usuario, las animaciones de waveforms y widgets siguen siendo fluidas, pero el número de veces que se invocan las funciones más costosas de JUCE por segundo (copias de imágenes grandes, rellenos de rectángulos con EdgeTable, mezclas de píxeles) se reduce aproximadamente a la mitad.

#### Ajustes adicionales de repintado y opacidad en MainComponent
- A partir de nuevos perfiles con Callgrind cargando la sesión `android_theme.rtp`, se ha constatado que, incluso con el gating de audio y el límite de repaints, una parte muy significativa de las instrucciones sigue concentrándose en las rutas software de JUCE asociadas a `PixelARGB::blend/set` y a los rellenos de paths (círculos de módulos, disco central y conexiones). Para seguir reduciendo la carga de CPU sin alterar la semántica del modelo de audio, se han aplicado dos optimizaciones adicionales en `MainComponent`:
  - En el constructor de `MainComponent` ([core/src/MainComponent.cpp](core/src/MainComponent.cpp#L90-L140)) se llama ahora explícitamente a `setOpaque(true)`. Dado que el componente cubre siempre todo su `getLocalBounds()` con un fondo totalmente opaco (negro + disco coloreado cacheado), esta indicación permite a JUCE omitir limpiezas y mezclas innecesarias con el contenido subyacente de la ventana al repintar, reduciendo trabajo por píxel en cada frame.
  - La caché de fondo de la mesa `tableBackgroundCache_` se crea ahora como imagen `juce::Image::RGB` sin canal alfa en lugar de `juce::Image::ARGB` transparente ([core/src/MainComponent.cpp](core/src/MainComponent.cpp#L20-L60)). Como el fondo se rellena por completo con negro sólido, disco de color y anillo de gradiente opacos, no se necesita información de transparencia y puede evitarse parte del coste de mezcla asociado a `PixelARGB` cuando se hace el `drawImageAt` en cada `paint`.
- Además, el límite de repintado máximo por segundo en `MainComponent_Audio::timerCallback` se mantiene en 60 fps (`kMaxRepaintsPerSecond = 60.0` en [core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L2520-L2620)), pero se ha añadido una compuerta simple de actividad visual: sólo se lanza `repaint()` cuando existe audio realmente activo (`!modulesWithActiveAudio_.empty()`), pulsos BPM en curso (`!pulses_.empty()`), una etiqueta de BPM aún visible (menos de 6 s desde `bpmLastChangeSeconds_`) o un gesto de hold/mute (`activeConnectionHold_`) en progreso. En estados completamente inactivos (sin audio ni animaciones ni interacción), el timer sigue ejecutando la lógica ligera de sincronía, pero deja de entrar en la ruta de pintura de JUCE, reduciendo de forma notable el consumo de CPU en reposo.
- Esta simple compuerta temporal sobre `repaint()` debería reflejarse en una caída directa del porcentaje de instrucciones atribuidas a `juce::RenderingHelpers::ImageFill::copyRow` y `EdgeTableFillers::SolidColour::handleEdgeTableRectangle` en nuevos perfiles de Callgrind, acercando la carga de CPU a los objetivos marcados (~<60% con foco en repaint) sin sacrificar la solidez temporal del transporte y del Sequencer.

##### Caché de fondo del dock derecho
- El dock derecho que agrupa los módulos `docked="1"` se dibujaba por completo en cada `paint`: panel de fondo (`fillRoundedRectangle` gris oscuro), contorno semitransparente, título "Dock" y, después, las burbujas e iconos de cada módulo. Aunque el área del dock es relativamente pequeña, el panel con esquinas redondeadas y texto suponía trabajo adicional de rasterizado y mezcla en cada frame.
- Para reducir este coste sin cambiar la apariencia, se ha introducido una **caché específica para el fondo del dock** en `MainComponent`:
  - Nuevos miembros `dockBackgroundCache_` y `dockBackgroundDirty_` en [core/src/MainComponent.h](core/src/MainComponent.h#L100-L140), paralelos a la caché de fondo de la mesa.
  - Nuevos helpers `invalidateDockBackground()` y `renderDockBackgroundIfNeeded(const juce::Rectangle<int>& dockBounds)` en [core/src/MainComponent.h](core/src/MainComponent.h#L270-L310) y su implementación en [core/src/MainComponent.cpp](core/src/MainComponent.cpp#L20-L80):
    - La función crea (cuando cambia el tamaño) una imagen `juce::Image::RGB` del tamaño exacto del área de dock y dibuja en ella el panel gris con esquinas redondeadas, su contorno blanco semitransparente y el texto estático "Dock" en la parte superior.
    - El resto del tiempo, `renderDockBackgroundIfNeeded` devuelve inmediatamente si el tamaño coincide y la caché no está sucia.
  - En `MainComponent::resized()` ([core/src/MainComponent.cpp](core/src/MainComponent.cpp#L520-L560)) se llama ahora también a `invalidateDockBackground()` junto con `invalidateTableBackground()` para asegurar que cualquier cambio de tamaño reprocesa ambos fondos en la siguiente pintura.
- En el bloque de pintado del dock en [core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L2388-L2445), se ha sustituido el dibujo directo del panel por un blit de la caché:
  - Antes: para cada `paint`, se calculaba `dockArea`, se llamaba a `fillRoundedRectangle + drawRoundedRectangle` y se pintaba el texto "Dock" sobre la marcha.
  - Ahora: se llama a `renderDockBackgroundIfNeeded(dockArea.toNearestInt())` y, si `dockBackgroundCache_` es válida, se hace un `drawImageAt` de la imagen cacheada en la posición `dockArea.getX()/getY()`. A continuación se recorta `dockArea.removeFromTop(titleHeight)` para que el layout de módulos reutilice exactamente el mismo espacio que antes.
- Las burbujas de cada módulo docked, sus iconos (ya optimizados con `atlasIconCache_`) y las etiquetas opcionales de BPM de Tempo se siguen dibujando cada frame como antes. La mejora se centra únicamente en el panel de fondo y el título estático, que pasan de ser paths y texto rasterizados en caliente a una imagen RGB opaca reutilizada, reduciendo unas cuantas llamadas a `PixelARGB::blend` y `EdgeTableFillers::SolidColour::handleEdgeTableRectangle` por frame cuando hay muchos repaints.

##### Gesto de corte más barato cuando la mesa está vacía
- En escenas donde no hay ningún módulo sobre el área musical (todos los tangibles están docked o fuera del círculo), hacer `mouseDown` y arrastrar sobre el fondo no aporta información visual útil, pero hasta ahora activaba igualmente el modo "cut" (cursor rojo + trail) y el pipeline completo de detección de intersecciones sobre radiales y conexiones en `mouseDrag`, generando repaints y trabajo extra aunque no hubiese líneas que cortar.
- En `MainComponent_Input::mouseDown` ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L860-L930)) se ha añadido una comprobación previa antes de activar `isCutModeActive_`:
  - Sólo se habilita el modo de corte si el punto inicial del gesto está dentro del círculo musical **y** existe al menos un `ObjectInstance` no docked con `inside_music_area == true` (es decir, al menos un módulo sobre la mesa).
  - Cuando el área musical está verdaderamente vacía, el gesto se sigue registrando como toque/touch (para el cursor blanco), pero no se entra en modo cut, de manera que los drags subsiguientes no intentan evaluar intersecciones con líneas inexistentes.
- En `MainComponent_Input::mouseDrag` ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L930-L1040)) se ha introducido además un early-return barato:
  - Al inicio del handler se calcula un flag `hasActiveGesture` que sólo es verdadero cuando hay realmente una interacción visual en curso: modo cut activo, scroll del dock, ajuste de barras laterales o drag de un módulo (`draggedObjectId_ != 0`).
  - Si `hasActiveGesture` es falso, la función retorna inmediatamente después de actualizar `isTouchHeld_` y `currentTouchPosition_`, evitando por completo la lógica de trail, búsqueda de intersecciones y llamadas a `repaint()` mientras el usuario simplemente arrastra el ratón sobre una mesa vacía.
- El registro de puntos de trail (`touchTrail_`) también se ha restringido a los casos en los que `isCutModeActive_` es verdadero; de este modo, los drags que sólo afectan a dock scroll, side controls o movimiento de módulos no acumulan puntos de trail innecesarios.
- En conjunto, estos cambios hacen que, con el área musical vacía, mover o incluso arrastrar el ratón sobre el fondo no dispare el pipeline de corte ni repaints adicionales: la carga de CPU en ese estado vuelve a estar dominada por el timer y las animaciones realmente visibles (por ejemplo, los pulsos BPM), sin picos extra debidos a interacción de ratón sin objetivos.
-
##### Helper de rate-limit de repaints compartido entre timer e input
- Para evitar que distintas fuentes de repintado (timer de 240 Hz, gestos de ratón, cambios en controles laterales o acciones sobre el dock) puedan forzar a `MainComponent` a repintar por encima de 60 fps, se ha extraído la lógica de limitación de repaints a un helper privado reutilizable: `MainComponent::repaintWithRateLimit()` en [core/src/MainComponent.cpp](core/src/MainComponent.cpp#L90-L120), declarado en [core/src/MainComponent.h](core/src/MainComponent.h#L280-L310).
- `repaintWithRateLimit()` calcula el tiempo actual con `juce::Time::getMillisecondCounterHiRes()`, impone un intervalo mínimo de `1.0 / 60.0` segundos entre repaints efectivos y sólo llama a `repaint()` cuando `nowSeconds - lastRepaintSeconds_ >= minRepaintInterval`, actualizando `lastRepaintSeconds_` tras cada repintado. De este modo, cualquier código que solicite un repaint a través de este helper queda automáticamente acotado a un máximo de 60 fps sin necesidad de duplicar lógica en cada llamada.
- En `MainComponent_Audio::timerCallback` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L2600-L2625)) se ha sustituido el bloque inline que combinaba `hasVisualActivity` con el cálculo local de `kMaxRepaintsPerSecond` por una llamada a `repaintWithRateLimit()` cuando `hasVisualActivity` es verdadero. El timer sigue ejecutándose a 240 Hz y evaluando la lógica de audio/Sequencer en cada tick, pero los repaints de UI se agrupan de forma que nunca superen los 60 por segundo.
- En `MainComponent_Input.cpp` ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L200-L1200)) se han reemplazado varias llamadas directas a `repaint()` por `repaintWithRateLimit()`, incluyendo:
  - El `mouseDown` general sobre la mesa (activación de cursor blanco o rojo, selección de objeto/touch).
  - Los gestos sobre controles laterales (por ejemplo, arrastre de barras de Freq/Gain) que actualizan visualmente el estado del módulo.
  - El final de `mouseDrag`, que antes siempre terminaba en un `repaint()` para actualizar el cursor rojo y el trail de corte, y ahora delega en el helper compartido para que esos repaints no rompan el límite global de 60 fps.
- Estas llamadas conviven con el gating previo de `hasVisualActivity` en el timer, de forma que incluso en escenas con mucha interacción de ratón sobre una mesa compleja (muchos módulos y conexiones visibles), la tasa combinada de repaints de UI no supera el objetivo de 60 fps. Visualmente, el usuario sigue percibiendo animaciones y feedback de input fluidos, pero los perfiles de CPU muestran menos tiempo en las rutas de rasterizado software de JUCE al evitar ráfagas de repaints redundantes disparadas desde múltiples sitios.

### Optimización de waveforms en conexiones y radiales en `paint`
- A partir de un perfil de Callgrind sobre la app principal (`RectaiTable`) se confirmó que, tras introducir el gating de audio, la mayor parte de las instrucciones de CPU se concentran en el subsistema de gráficos de JUCE (`PixelARGB::blend`, `ImageFill::copyRow`, `SolidColour::replaceLine`, etc.) invocado desde `MainComponent::paint`. El coste dominante procede de la rasterización de paths complejos (radiales con waveform y conexiones módulo→módulo) más que del código de dominio en sí.
- En `MainComponent_Paint.cpp` ([core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L420-L1180)) se han aplicado varias optimizaciones específicas a la representación de **waveforms en conexiones y radiales** para reducir este coste sin alterar la semántica visual básica:
  - En las waveforms de **conexión continua** (`module → module`, tanto hardlink como dinámica) se ha eliminado la estimación de periodo por autocorrelación (`estimateWaveformPeriod`) a partir de los taps por conexión. Antes se llamaba a `estimateWaveformPeriod(tempWave, kWaveformPoints)` para cada conexión visible en cada `paint`, lo que añadía un coste O(N²) por conexión (N ≈ 512 muestras) además del propio stroke del path. Ahora estas conexiones utilizan simplemente `periodSamples = kWaveformPoints` con un número fijo moderado de segmentos (72) y `tiled = !involvesSampleplay`, de modo que se sigue repitiendo el buffer a lo largo de la línea sin necesidad de detectar su periodo exacto. En los segmentos de línea en estado de hold (`activeConnectionHold_`) se mantiene deliberadamente la estimación de periodo por autocorrelación para priorizar la precisión visual de ese gesto puntual, aun a costa de más CPU.
  - Se ha introducido un **umbral de nivel visual** (`connectionLevel > 0.05f`) para decidir si merece la pena dibujar una waveform sobre una conexión audio-carrying. Cuando la amplitud efectiva de la conexión es muy baja (por debajo del umbral), ahora se omite por completo la llamada a `drawWaveformOnLine` y se dibuja únicamente una línea recta fina con el color activo. Visualmente, la diferencia es mínima para señales casi silenciosas, pero se evita el coste de construir y recorrer paths con muchos segmentos y de rasterizar su waveform en cada repaint.
- Estas optimizaciones se limitan a las waveforms de **conexión** (incluidas las asociadas a estados de hold); las radiales principales de Oscillator, Sampleplay y Loop siguen usando sus buffers y normas de amplitud existentes para conservar la expresividad visual. El objetivo es reducir el trabajo de rasterización en los casos donde el usuario apenas puede distinguir detalles de waveform (conexiones de nivel muy bajo o segmentos duplicados) y eliminar cálculos de periodo innecesarios en rutas que no dependen visualmente de la periodicidad precisa de la señal.
- Conceptualmente, el impacto esperado es:
  - Menos instrucciones dedicadas a preparación de paths y a autocorrelaciones por conexión, lo que alivia parcialmente el coste de CPU en `paint` observado en Callgrind.
  - Menos invocaciones de `g.strokePath` para waveforms en conexiones de nivel casi nulo, que pasaban inadvertidas al ojo pero generaban trabajo de píxel innecesario.
  Estas mejoras deben contribuir a mantener la carga de CPU del hilo de UI por debajo del objetivo (~60%) en escenas como `default.rtp`, especialmente cuando hay muchas conexiones visibles pero con niveles de audio modestos.

### Opción de AVX/AVX2 específica para rectai-tracker
- Se ha añadido una opción de CMake `RECTAI_TRACKER_ENABLE_AVX` en [tracker/CMakeLists.txt](tracker/CMakeLists.txt#L1-L80) para habilitar flags de vectorización avanzada (AVX, AVX2 y FMA) **sólo** en el binario `rectai-tracker` y únicamente en toolchains no-MSVC.
- Cuando `RECTAI_TRACKER_ENABLE_AVX` está activada, el script comprueba de forma independiente el soporte de `-mavx`, `-mavx2` y `-mfma` mediante `check_cxx_compiler_flag` y añade cada flag soportada al target `rectai-tracker` con `target_compile_options`, restringiéndolas a configuraciones `Release` y `RelWithDebInfo` mediante `generator expressions`. Esto evita afectar a los builds de `Debug` usados para depuración y perfiles de desarrollo.
- La opción queda desactivada por defecto (`OFF`) para mantener la máxima compatibilidad de CPU en binarios distribuidos (por ejemplo, contenedores Docker o builds compartidos). En entornos controlados donde se conoce de antemano que la CPU de destino soporta AVX2/FMA, se puede forzar desde la configuración de CMake con `-DRECTAI_TRACKER_ENABLE_AVX=ON` junto con `-DCMAKE_BUILD_TYPE=Release` para obtener kernels de OpenCV y libfidtrack compilados con estas extensiones, sumándose a las optimizaciones ya aplicadas de `-march=native` cuando `RECTAI_ENABLE_CPU_OPTIMIZATIONS` está activo.

## 2025-12-17

### Unificación de BPM global y helpers en TempoModule
- Se ha introducido en `TempoModule` un rango canónico de BPM (`kMinBpm=40`, `kMaxBpm=400`) junto con helpers estáticos `ClampBpm`, `BpmFromNormalised` y `NormalisedFromBpm` que encapsulan el mapeo entre valores normalizados [0,1] y BPM reales. Estos helpers usan `std::clamp` y viven en el header de `AudioModules`, evitando dependencias directas de JUCE en los headers de dominio.
- `MainComponent` pasa a almacenar el BPM global como `float bpm_` en lugar de `double`, ya que no se necesita más precisión para la sesión en marcha. Al cargar un patch (`LoadReactablePatchFromFile`), el valor inicial de `bpm_` se toma del parámetro lógico `tempo` del `TempoModule` (si existe) y se normaliza mediante `TempoModule::ClampBpm`.
- Toda la interacción de UI que modifica el tempo (rueda de ratón sobre el nodo de Tempo, clicks y drags en la barra lateral izquierda interpretada como control de tempo, y la rotación del tangible de Tempo en el bucle de audio) reutiliza ahora los helpers de `TempoModule`:
  - En `MainComponent_Input.cpp`, los gestos de rueda sobre el `TempoModule` ajustan `bpm_` en pasos de ±1 BPM (o ±5 BPM con Shift) usando `ClampBpm`, y sincronizan el parámetro `tempo` del módulo asignando directamente el `float bpm_` sin conversiones intermedias a `double`.
  - En los clicks y drags sobre la barra lateral de Tempo, la posición vertical se mapea a BPM utilizando `BpmFromNormalised` y se muestra la barra leyendo `NormalisedFromBpm(bpm_)`, eliminando la lógica duplicada de límites [40,400] y normalización que había repartida por varios archivos.
  - En `MainComponent_Audio.cpp`, la rotación del tangible Tempo convierte el delta angular en `deltaBpm` `float` y aplica `TempoModule::ClampBpm` para obtener el nuevo `bpm_`, actualizando a continuación el parámetro lógico `tempo` del módulo.
   - En el mismo `timerCallback` de `MainComponent_Audio` se ha afinado también la animación de los pulsos BPM centrales: el lifetime visual de cada pulso se ha reducido de ~0.3 s a ~0.2 s para que la expansión del círculo y su desvanecimiento ocurran más deprisa dentro de cada beat, manteniendo la generación de pulsos bloqueada al transporte global (`audioEngine_.transportBeats()`). Esto hace que el efecto de dibujo resulte más “rápido” y acorde a la percepción musical sin tocar el tempo real.
   - En la capa de pintura (`MainComponent_Paint.cpp`), el grosor del trazo de cada círculo pasa de ser constante (4 px para pulsos fuertes, 2 px para débiles) a crecer de forma suave a lo largo de la vida del pulso: se parte de ese grosor base y se añade hasta ~3 px extra en función de una edad normalizada `tRadius` (resultado de una curva cúbica tipo Bezier). De este modo, a medida que la onda se expande hacia fuera, el contorno se hace ligeramente más grueso, reforzando la sensación de avance del pulso sin introducir nuevos cálculos costosos ni ramas en el render.
   - Para la propia expansión radial y el desvanecimiento se han sustituido las rampas lineales originales por curvas de easing simples: el radio usa una `ease-out` cúbica (equivalente a una Bezier con aceleración inicial) que hace que el círculo crezca rápido al inicio y se frene hacia el final del pulso, mientras que la opacidad usa una caída cuadrática sobre `1 - t` que mantiene el pulso visible más tiempo antes de suavizar el fade-out en la cola. Estas curvas suavizan tanto la “entrada” como la desaparición del pulso sin afectar al bloqueo de fase respecto al transporte.
- El pintado de la barra lateral de Tempo y de la etiqueta numérica de BPM (`MainComponent_Paint.cpp`) utiliza ahora `TempoModule::NormalisedFromBpm(bpm_)` para derivar la posición de la barra y sigue mostrando el valor entero de BPM a partir del `float bpm_`, con el mismo comportamiento de fade basado en `bpmLastChangeSeconds_`.
- En `AudioEngine`, el tempo global de loops (`loopGlobalBpm_`) se ha cambiado de `std::atomic<double>` a `std::atomic<float>` y el setter `setLoopGlobalTempo` ahora recibe un `float`. El motor de audio sigue convirtiendo este valor a `double` solo en el cálculo intermedio de `beatsPerSecond`, pero el almacenamiento y la API expuesta se mantienen en `float` para alinearse con `MainComponent::bpm_`. `MainComponent_Audio` continúa llamando a `audioEngine_.setLoopGlobalTempo(bpm_)` en cada tick del timer para mantener los loops sincronizados con el tempo global.

### Waveform individual por módulo Loop en radiales
- Se ha extendido `AudioEngine` (`core/src/AudioEngine.{h,cpp}`) con un pequeño sistema de historiales de waveform específicos para módulos `LoopModule`. Se introduce la constante `kMaxLoopWaveforms = 16` y un nuevo bloque de estado privado formado por `loopWaveformBuffers_[kMaxLoopWaveforms][kWaveformHistorySize]`, un `unordered_map<string,int> loopModuleToWaveformIndex_` y un contador `numLoopWaveformSlots_`. Cada módulo Loop que necesite visualización obtiene un índice entero estable en este rango, y el hilo de audio escribe en su buffer dedicado usando el mismo índice de escritura global (`waveformWriteIndex_`) que el resto de historiales.
- La estructura `LoopInstance` incorpora un campo `int visualWaveformIndex{-1}` que apunta al slot de waveform asignado a ese módulo. El campo se copia/mueve explícitamente en los constructores y operadores de copia/move para que la instantánea usada por el hilo de audio (`loopModulesSnapshot_`) conserve el índice visual sin tener que consultar maps en tiempo de audio.
- `AudioEngine::setLoopModuleParams` se encarga ahora de reservar el slot visual la primera vez que se actualizan parámetros de un módulo Loop: si `visualWaveformIndex` es negativo, busca en `loopModuleToWaveformIndex_` un índice ya asignado para ese `moduleId` y, si no existe y aún hay espacio (< `kMaxLoopWaveforms`), crea una entrada nueva e incrementa `numLoopWaveformSlots_`. Tras actualizar los parámetros (slot seleccionado, gain y tiempos de envolvente), el método replica también `visualWaveformIndex` en el snapshot activo (`loopModulesSnapshot_`) para que el hilo de audio conozca el índice sin locks.
- En el callback de audio (`audioDeviceIOCallbackWithContext`), dentro de ambas ramas donde se mezclan loops (con y sin voces de oscilador activas), se aprovecha el bucle que ya recorre los `LoopInstance` activos: justo después de aplicar la envolvente AR y calcular el `finalGain`, se deriva una muestra mono por módulo a partir del canal izquierdo (`const float monoWithGain = l * finalGain;`). Esta muestra se suma al mix estéreo cuando `finalGain > 0` y, en cualquier caso, se escribe en el buffer visual correspondiente siempre que `visualWaveformIndex` esté en rango (`loopWaveformBuffers_[wfIndex][bufIndex] = monoWithGain;`). De este modo, el historial de waveform por módulo refleja la señal post‑gain/envolvente del loop y se va rellenando con ceros cuando el módulo deja de sonar, haciendo que las ondas en la UI se desvanezcan de forma natural.
- Se ha añadido el método público `AudioEngine::getLoopModuleWaveformSnapshot(const std::string& moduleId, float* dst, int numPoints, double windowSeconds)`, que sigue la misma estrategia que `getWaveformSnapshot` y `getConnectionWaveformSnapshot`: localiza el índice del módulo en `loopModuleToWaveformIndex_`, valida rangos y, a partir de `waveformWriteIndex_`, calcula una ventana temporal (por defecto ~50 ms) dentro del historial circular. La ventana se remuestrea de forma uniforme en `numPoints` posiciones escribiendo en `dst`. Si el módulo no tiene historial o aún no hay muestras suficientes, el buffer se rellena con ceros.
- En la capa de pintado (`core/src/MainComponent_Paint.cpp`), la rama específica para radiales de Loop se ha cambiado para usar el nuevo API per‑módulo en lugar del buffer global mezclado. Donde antes se llamaba a `audioEngine_.getWaveformSnapshot(loopRadialWave, kWaveformPoints, 0.05)`, ahora se invoca `audioEngine_.getLoopModuleWaveformSnapshot(object.logical_id(), loopRadialWave, kWaveformPoints, 0.05)`. La normalización posterior (`maxAbs` y `loopRadialNorm`) y el dibujo vía `drawWaveformOnLine` se mantienen igual, pero ahora cada Loop radial refleja únicamente la forma de onda del sample y ganancia de ese módulo, en lugar de la suma global de todos los loops y demás fuentes.
- Con este cambio, cuando se colocan varios módulos Loop con samples distintos, la “línea soundwave” radial de cada uno muestra su waveform individual (derivada de su propio sample + envolvente) y ya no aparece idéntica entre módulos. La visualización sigue respetando el mute por conexión (`isRadialMuted`) y el gating por `modulesWithActiveAudio_`/`lineCarriesAudio`, y los tests (`ctest`) siguen pasando sin cambios adicionales.

### Fade temporal del título de instrumento en Sampleplay
- El título del instrumento activo de los módulos `Sampleplay` (texto que se pinta a la derecha del nodo) ahora se muestra de forma destacada solo durante unos segundos tras una interacción relevante y luego se desvanece progresivamente. `MainComponent` mantiene un mapa `sampleplayLabelLastChangeSeconds_` que asocia el id de módulo con un timestamp en segundos; este valor se actualiza tanto cuando un `SampleplayModule` entra en el área musical (al arrastrar el tangible desde el dock o desde fuera del círculo) como cuando se cambia de instrumento o banco con click derecho (`CycleInstrument` / `CycleBank`). En `MainComponent_Paint.cpp`, la sección de render del título de Sampleplay consulta dicho timestamp y calcula una alpha: el texto permanece al 100% hasta 3 segundos después del último cambio y, entre los 3 y 3.5 segundos, hace un fade lineal hasta desaparecer; si no existe aún entrada en el mapa (escenas cargadas al inicio), la primera vez que se pinta se inicializa el temporizador para garantizar un comportamiento consistente. De esta forma, el nombre del instrumento es claramente visible justo después de colocar o reconfigurar un Sampleplay, pero la UI se limpia automáticamente tras un breve periodo de inactividad.

### Control opcional de volumen desde el Sequencer
- En `MainComponent` se ha añadido el flag `sequencerControlsVolume_` (por defecto `true`) que gobierna si el runtime del `SequencerModule` está autorizado a modificar el volumen de los módulos destino. Cuando está activado (valor por defecto actual), los pasos del secuenciador siguen modulando la velocidad de las notas disparadas en `Sampleplay` (multiplicando `velocity01` de cada step en `runSequencerStep`) y escribiendo el parámetro `gain` de los `OscillatorModule` conectados, forzando además `gain = 0.0` en los pasos desactivados para garantizar silencios claros: si un Oscillator está conectado a un Sequencer y el paso correspondiente tiene `enabled = 0`, el oscilador no suena en ese beat. Cuando se desactiva este flag, el Sequencer sigue controlando pitch/trigger (frecuencia destino y disparo de notas) pero deja de escalar la velocidad de las notas y no toca el parámetro `gain` en osciladores ni fuerza silencio en pasos vacíos, permitiendo que el volumen llegue desde otras fuentes MIDI o controladores globales sin ser sobreescrito por el patrón del secuenciador.

### Duración de nota derivada de `speed` (figura binaria)
- Aunque `SequenceTrack` ya almacenaba los campos `speed` y `speed_type` de cada `<sequence>` del `.rtp`, hasta ahora el runtime del Sequencer no los utilizaba y todas las notas tenían una duración efectiva ligada al envelope del destino o a cambios manuales de `gain`. Se ha dado el primer paso para respetar la semántica original de Reactable donde, con `speed_type="binary"`, el entero `speed` codifica la **figura musical** de la nota: `0=fusa (1/32)`, `1=semicorchea (1/16)`, `2=corchea (1/8)`, `3=negra (1/4)`, `4=blanca (2/4)`, `5=redonda (4/4)`.
- En `MainComponent_Audio.cpp` se ha introducido el helper `binarySpeedToBeats(int)` (en un namespace anónimo) que mapea estos valores a longitudes en beats asumiendo compás 4/4 y negra=1 beat: `0→1/8` (0.125 beats), `1→1/4`, `2→1/2`, `3→1`, `4→2`, `5→4`. Este helper sólo se aplica cuando el `SequenceTrack.speed_type` es exactamente `"binary"`; para otros tipos el runtime mantiene, por ahora, una duración por defecto de negra (1 beat).
- El runtime del Sequencer en `runSequencerStep` consulta ahora, para cada `SequencerModule`, el `SequenceTrack` asociado al preset activo (`tracks()[current_preset]`) y, cuando `sequencerControlsVolume_` es verdadero y el destino es un `OscillatorModule`, calcula una `noteLengthBeats` llamando a `binarySpeedToBeats(track.speed)`. Con esa longitud programa un **note-off en beats** para el módulo destino almacenándolo en `moduleNoteOffBeats_[oscModule->id()] = transportBeats_ + noteLengthBeats`.
- `MainComponent` mantiene el mapa `moduleNoteOffBeats_` y, en cada `timerCallback`, calcula la posición global de transporte como `transportBeats_ + beatPhase_`. Para cada entrada cuya hora de corte se haya alcanzado o superado, fuerza `Scene::SetModuleParameter(moduleId, "gain", 0.0F)` (sólo si el módulo sigue siendo un `OscillatorModule`) y elimina la entrada del mapa. De esta forma, mientras un Oscillator esté conectado a un Sequencer y `sequencerControlsVolume_` sea `true`, el valor `speed` de su `SequenceTrack` determina cuánto tiempo permanece el `gain` distinto de cero tras cada disparo de paso, aproximando la duración audible de la nota a la figura binaria especificada en el patch.

### Scroll con rueda en el dock de módulos
- `MainComponent` implementa ahora `mouseWheelMove` para permitir hacer scroll vertical en el dock derecho usando la rueda del ratón siempre que el cursor esté dentro del área del dock. El manejo de la rueda reutiliza el mismo cálculo de límites que el drag vertical del dock (`minOffset` basado en `contentHeight` y `availableHeight`), actualizando `dockScrollOffset_` mediante un pequeño desplazamiento en píxeles proporcional a `wheel.deltaY` y forzando un `repaint()`. De este modo, cuando hay más módulos dockeados de los que caben en pantalla, el usuario puede navegar por la lista tanto arrastrando con el ratón como empleando la rueda, sin afectar al resto de la superficie musical.

### Normalización de idioma en comentarios de código (core)
- Se han revisado los archivos de código en `core/src/` relacionados con entrada de usuario, pintado de escena y modelo de audio (`MainComponent_Input.cpp`, `MainComponent_Paint.cpp`, `MainComponent.cpp`, `MainComponent.h`, `core/Scene.{h,cpp}`, `core/ReactableRtpLoader.cpp`, `core/AudioModules.{h,cpp}`) para localizar comentarios escritos en español y traducirlos al inglés, alineando así el código con la convención general del proyecto.
- En `MainComponent_Input.cpp` se han traducido los comentarios que describen el comportamiento del scroll con rueda en el dock, la selección y mute de líneas centro→objeto y la lógica de corte de líneas, manteniendo la semántica original (limitación del scroll al área del dock, criterios de clic/corte sólo sobre módulos que producen o consumen audio, exclusión de controladores globales y módulos sólo MIDI/control).
- En `MainComponent_Paint.cpp` se ha ajustado el comentario que documenta la reutilización de `drawWaveformOnLine` para conexiones dinámicas ya renderizadas como líneas rectas.
- En `MainComponent.cpp` y `core/AudioModules.{h,cpp}` se han traducido los comentarios que explican la heurística de mapeo entre bancos lógicos de `Sampleplay` y presets reales del SoundFont (drums vs synths), así como el avance de banco lógico (`CycleBank`) y el uso de `default_preset_indices_`.
- En `MainComponent.h` se han pasado a inglés las descripciones de fase/step del sequencer visual y de audio, el contador de beats (`transportBeats_`) y el flag `sequencerControlsVolume_`, aclarando su rol en la modulación opcional de volumen desde el Sequencer.
- En `core/src/core/Scene.{h,cpp}` se han traducido los encabezados de sección de gestión de módulos, conexiones y objetos, y los comentarios que documentan la eliminación de conexiones asociadas a un módulo borrado y la prevención de duplicados al añadir conexiones.
- En `core/src/core/ReactableRtpLoader.cpp` se han traducido los comentarios que describen la normalización del volumen del módulo `Volume` desde porcentaje (0..100) a rango [0,1] y la derivación de presets monofónicos de `Sequencer` a partir de `SequenceTrack`, eliminando las frases en español dentro de explicaciones mixtas.

### Enumeración de presets SF2 con FluidSynth y Sampleplay integrado
- Se ha completado la integración de FluidSynth para el módulo `Sampleplay`, de forma que el audio ya no depende de tonos senoidales de prueba sino de los instrumentos reales del archivo SoundFont2 (`.sf2`). La clase `SampleplaySynth` en `core/src/core/SampleplaySynth.{h,cpp}` encapsula `fluid_settings_t` y `fluid_synth_t` y expone métodos para cargar un soundfont, ajustar el sample rate y renderizar audio estéreo hacia buffers `float*`, además de lanzar notas (`noteOn`) y liberarlas (`noteOff`) según banco/programa y nota MIDI.
- `AudioEngine` (`core/src/AudioEngine.{h,cpp}`) utiliza ahora `SampleplaySynth` como fuente de audio para todos los módulos de tipo `Sampleplay`. En el callback de audio mezcla el resultado de FluidSynth (buffers izquierdo/derecho) con las voces procedurales existentes (osciladores, etc.), aplicando limitación suave por canal y manteniendo el buffer circular de muestras para la visualización de formas de onda en las líneas.
- En `MainComponent_Audio.cpp` se ha introducido la función `triggerSampleplayNotesOnBeat(bool strongBeat)`, invocada en `timerCallback` cada vez que `beatPhase_` supera un nuevo beat. Esta función recorre los `SampleplayModule` activos en el área musical, calcula una nota MIDI a partir del parámetro `midifreq`, deriva una velocidad normalizada desde `amp` y el volumen global y llama a `audioEngine_.triggerSampleplayNote(bank, program, midiKey, velocity01)` usando el banco y programa del instrumento activo. De este modo, los Sampleplay lanzan notas sincronizadas con el tempo global utilizando el motor de SoundFont real.
- Se ha implementado la enumeración de presets de SoundFont en `core/src/core/SoundfontUtils.{h,cpp}` mediante la función `EnumerateSoundfontPresets`. Para evitar problemas con tipos opacos de FluidSynth en C++, esta función declara solo el subconjunto mínimo de la API C necesario y trata los handles de soundfont y preset como punteros opacos (`void*`). A partir de un soundfont cargado con `fluid_synth_sfload`, la función recorre un rango razonable de bancos y programas (0–127) usando `fluid_sfont_get_preset` y, para cada preset encontrado, obtiene `bank`, `program` y `name` con `fluid_preset_get_*`, rellenando un `std::vector<SoundfontPreset>` que alimenta el modelo de `Sampleplay`.
- El lambda `loadSampleplaySoundfonts` en `MainComponent.cpp` sigue siendo el punto central para inicializar los módulos `Sampleplay` tras cargar un patch `.rtp`: resuelve la ruta del `.sf2` desde `com.reactable/Soundfonts`, llama a `SampleplayModule::LoadSoundfont` para validar el archivo y, si la carga es correcta, usa `EnumerateSoundfontPresets` para reconstruir la lista de `SampleInstrument` del módulo a partir de los presets reales del SF2. La lista de instrumentos declarada en el `.rtp` se utiliza solo como pista para elegir el preset por defecto cuando hay coincidencia de nombre.
- Una vez que se encuentra al menos un `SampleplayModule` con SoundFont válido, `loadSampleplaySoundfonts` informa también al `AudioEngine` de la ruta del soundfont llamando a `audioEngine_.setSampleplaySoundfont(sampleModule->soundfont_path())`, asegurando que el motor de audio y el modelo de escena utilizan exactamente el mismo archivo SF2. El comportamiento de la UI (título de instrumento a la derecha del módulo y cambio de instrumento por click derecho) se mantiene, pero ahora los nombres y presets provienen directamente del contenido del SoundFont.
- Se ha refinado la interpretación de los Sampleplay respecto al archivo `default.rtp`: el atributo `channel` de los tangibles Sampleplay se interpreta como índice de banco lógico (0 → primer `<instrument>` del `.rtp`, 1 → segundo `<instrument>`, etc.) y el orden de los elementos `<instrument>` se usa como mapeo de “modos” (por ejemplo, drums vs synths). `MainComponent::loadSampleplaySoundfonts` construye ahora un vector de índices de preset por banco (`default_preset_indices_` en `SampleplayModule`) buscando cada nombre de `<instrument>` entre los presets enumerados del SF2 y selecciona como preset activo el correspondiente al canal declarado por el patch, con fallback razonable cuando no hay coincidencia.
- `SampleplayModule` mantiene ahora un campo `channel_` y un vector `default_preset_indices_` que enlaza bancos lógicos con presets concretos de SoundFont. El método `CycleInstrument()` cicla preferentemente entre los presets del mismo banco físico (mismo `bank` SF2 que el preset por defecto del canal actual), y se ha añadido `CycleBank()` para rotar entre bancos lógicos (canales) actualizando el preset activo al índice por defecto de cada banco.
- En la interacción de la UI (`MainComponent_Input.cpp`), el click derecho sobre un Sampleplay sin modificadores sigue ciclando los instrumentos dentro del banco actual, mientras que un click derecho con la tecla CONTROL pulsada alterna entre los bancos lógicos (por ejemplo, del banco de drums al banco de synths), seleccionando automáticamente el preset por defecto de cada banco según lo definido por el `.rtp` y resuelto contra el contenido real del SF2.

### Volumen dedicado y waveform visual para Sampleplay
- Se ha activado un control de ganancia específico para `SampleplayModule` en `core/src/core/AudioModules.cpp` habilitando `uses_gain_control_` y ajustando el mapeo de nivel con `set_level_mapping(0.05F, 0.95F)`. Esto hace que el arco derecho de cada Sampleplay en la UI represente su volumen principal y que el parámetro `amp` pueda recorrer un rango útil de loudness cuando se combina con la curva de volumen global (`VolumeModule`).
- En `MainComponent_Paint.cpp`, el cálculo del valor de ganancia para los sliders laterales distingue ahora explícitamente entre módulos: `Volume` sigue usando `volume`, los `Filter` usan `q`, y los módulos `Loop`/`Sampleplay` leen su nivel desde `amp`. De este modo, el arco derecho de Sampleplay refleja siempre el valor real que se aplicará al disparar notas vía SoundFont.
- La lógica de input en `MainComponent_Input.cpp` se ha ampliado para que el side control derecho escriba sobre el parámetro `amp` en módulos `Loop` y `Sampleplay` tanto al hacer click en la barra como durante el drag continuo (antes solo actualizaba `gain` salvo en `Volume` y `Filter`). Esto alinea el gesto de usuario con el modelo de parámetros: el slider derecho de Sampleplay ajusta realmente el volumen de sus disparos, y el gesto de drop seguro con CONTROL sigue pudiendo forzar `amp = 0.0` al colocar el módulo sobre la mesa.
- En el motor de audio (`core/src/AudioEngine.{h,cpp}`) se ha añadido un buffer circular mono dedicado a Sampleplay (`sampleplayWaveformBuffer_`) y un método público `getSampleplayWaveformSnapshot`, que capturan la contribución de SoundFont antes de mezclarla con las voces procedurales. El callback de audio escribe en este buffer a partir del canal izquierdo de `SampleplaySynth::render` manteniendo el mismo índice de escritura que el resto de historiales de waveform.
- `MainComponent_Paint.cpp` consume ahora este snapshot específico para Sampleplay al dibujar las líneas radiales módulo→Master: cuando el módulo asociado es un `SampleplayModule` y el historial tiene energía suficiente, la línea se pinta con la forma de onda tomada de `sampleplayWaveformBuffer_` en lugar de intentar reutilizar los buffers por voz del oscilador (que no representan el audio de Sampleplay). Esto hace que la conexión entre Sampleplay y Master muestre un soundwave animado análogo al de los osciladores, pero basado en la señal real del SoundFont.

- Se ha añadido un control de ganancia global para la ruta de Sampleplay (SoundFont) en `AudioEngine` (`sampleplayOutputGain_` más el método `setSampleplayOutputGain`). El callback de audio multiplica los buffers `sampleplayLeft_`/`sampleplayRight_` por este valor antes de mezclarlos con las voces del oscilador, permitiendo silenciar inmediatamente todo el audio procedente del SoundFont sin afectar a las voces procedurales.
- `MainComponent_Audio.cpp` actualiza este gain en cada `timerCallback`: cuando el master está muteado o no existe ningún `SampleplayModule` dentro del área musical con su línea a Master sin mutear, fija `sampleplayOutputGain` a 0.0; en caso contrario lo iguala al `globalVolumeGain`. De esta forma, al mutear la línea de sonido de un Sampleplay (o el master), el audio de SoundFont se detiene en seco (stop), incluso si había muestras largas en reproducción, mientras que al reactivar la línea el volumen vuelve a seguir la curva del módulo `Volume`.
 - Para evitar que las notas disparadas sobre el motor de SoundFont se acumulen cuando el `SequencerModule` envía eventos repetidos a `Sampleplay`, se ha ajustado `SampleplaySynth::noteOn` en `core/src/core/SampleplaySynth.cpp` para que llame a `fluid_synth_all_notes_off(…, channel)` antes de seleccionar preset y disparar una nueva nota en el único canal de FluidSynth que usamos. Esto implementa un comportamiento monofónico sencillo: cada nueva nota enviada por el secuenciador marca el final de las notas previas (que pasan a su fase de release según el envelope del SF2), evitando el efecto de notas “infinitas” o colas superpuestas cuando se tocan varios pasos seguidos.

### Preparación del Sequencer para modos polifónicos
- La estructura `SequencerStep` en `core/src/core/AudioModules.h` se ha ampliado para incluir un contenedor `std::vector<int> pitches` además del campo escalar `pitch`. La implementación actual del runtime sigue siendo monofónica y consume únicamente `pitch`, pero el vector `pitches` permite adjuntar varias notas a un mismo paso sin cambiar el modelo de datos cuando se implementen los modos Polyphonic/Random descritos en `research/sequencer.md`.
- En el constructor de `SequencerModule` (`AudioModules.cpp`), el preset de demo que genera la escala de C mayor inicializa ahora también `step.pitches`, limpiando el vector y añadiendo el `step.pitch` como única entrada para los pasos activos; los pasos desactivados mantienen el vector vacío. Esto garantiza que cualquier código futuro que itere sobre `pitches` vea una representación coherente incluso cuando no hay datos procedentes de un `.rtp`.
- `SequencerModule::SyncPresetsFromTracks()` se ha actualizado para mantener sincronizados `pitch` y `pitches` al proyectar los `SequenceTrack` derivados del `.rtp`: después de calcular y clamplear el `pitch` por step, se vacía `step.pitches` y, si el paso está habilitado, se inserta ese `step.pitch` como único elemento. De esta forma, el loader de patches ya rellena una vista "poly-ready" (un vector por step) aunque el runtime que dispara notas desde `MainComponent_Audio` siga tratando cada step como estrictamente monofónico.

### Introducción de MidiNoteEvent en el runtime del Sequencer
- Se ha incluido `core/src/core/MidiTypes.h` en `MainComponent_Audio.cpp` y se ha introducido una estructura `MidiNoteEvent` real en el runtime del `SequencerModule`. La lambda `runSequencerStep` construye ahora, para cada paso activo, un `rectai::MidiNoteEvent` con `channel=0`, `note` igual al `pitch` del step (clamp a `[0,127]`), `velocity01` clampada a `[0,1]` y `timeBeats` tomado de un nuevo contador `transportBeats_` que se incrementa en cada beat del transporte global.
- En lugar de usar directamente `step.pitch`/`step.velocity01` al disparar módulos destino, el runtime pasa por este `MidiNoteEvent`: para `SampleplayModule`, el evento se combina con el nivel propio del módulo (`amp`, `base_level`, `level_range`) y el volumen global `globalVolumeGain` para obtener una `effectiveVelocity` que se usa al llamar a `audioEngine_.triggerSampleplayNote(bank, program, noteEvent.note, effectiveVelocity)`; cuando `sequencerControlsVolume_` es `false`, la velocidad del step se ignora y solo afectan el volumen global y el nivel del módulo.
- Para `OscillatorModule`, el runtime convierte `noteEvent.note` a frecuencia en Hz (`440 * 2^((note-69)/12)`) y actualiza el parámetro `freq` normalizado del oscilador como antes, pero ahora usa `noteEvent.velocity01` (clampado) para el parámetro `gain` cuando `sequencerControlsVolume_` está activado. De este modo, tanto Sampleplay como Oscillator consumen la misma descripción lógica de nota, y el paso a modos polifónicos o a un scheduler MIDI más rico podrá concentrarse en cómo se generan/encolan `MidiNoteEvent` sin cambiar la firma de los módulos destino.

### Ajuste de enumeración de bancos SF2 para presets de percusión
- Se ha ampliado el rango de bancos que recorre `EnumerateSoundfontPresets` en `core/src/core/SoundfontUtils.cpp`: antes solo se probaban combinaciones `bank 0..127`, ahora se exploran bancos `0..255` manteniendo el rango de programas en `0..127`. Esto permite detectar presets que algunos soundfonts colocan en bancos superiores (por ejemplo, bancos de percusión en `bank >= 128`) sin depender de APIs de iteración internas de FluidSynth.
- La herramienta de depuración `tools/list_sf2_presets.cpp` se ha actualizado en paralelo para listar también presets en bancos `0..255`, de forma que al inspeccionar el archivo `com.reactable/Soundfonts/default.sf2` desde línea de comandos se vean todos los presets relevantes, incluidos posibles kits de percusión o bancos extendidos que no aparecían cuando solo se iteraba hasta el banco 127.
 - `MainComponent::loadSampleplaySoundfonts` incorpora ahora una heurística específica para los bancos de drums definidos en los patches Reactable que se apoya principalmente en los bancos físicos del SoundFont: cuando un `<instrument>` del `.rtp` tiene un nombre que contiene `"Drumset"` o `"Drum"` y no existe ningún preset SF2 con ese nombre exacto, se intenta primero asignar un preset que viva en un banco distinto de 0 (priorizando bancos altos `>= 128`, típicamente usados para percusión en SoundFonts GM/GS). Si el soundfont sólo usa el banco 0, como ocurre con el `default.sf2` incluido en el repo, se hace un último intento genérico buscando presets cuyo nombre sugiera percusión (`"Percussion"`, `"Kit"` o `"Drum"`). Si aun así no hay candidato específico, se deja el índice sin asignar y la lógica de fallback posterior elige el primer preset válido disponible. De esta manera el banco lógico de drums suele acabar asociado a un kit percusivo real, pero sin depender de nombres hardcodeados de un SF2 concreto.
 