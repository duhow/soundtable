# Progreso de implementación

## 2025-12-19

### Importador de sesiones RTZ (.rtz) con soporte ZIP y extracción de Samples
- Se ha añadido un nuevo módulo de dominio `ReactableRtzLoader` en [core/src/core/ReactableRtzLoader.{h,cpp}](core/src/core/ReactableRtzLoader.h) que permite importar archivos `.rtz` (sesiones empaquetadas de Reactable) directamente en el modelo `Scene`. Los archivos `.rtz` se tratan como archivos ZIP que deben contener en la raíz exactamente un archivo `.rtp` (sesión XML) y, opcionalmente, una carpeta cuyo nombre coincide con el basename de ese `.rtp` (por ejemplo, `Loopdemo/` para `Loopdemo.rtp`) con Samples de audio.
- `ReactableRtzLoader` valida primero que la ruta recibida apunta a un archivo ZIP (comprueba la cabecera `PK` leyendo los primeros bytes y delega después en `libzip` para la apertura y el listado de entradas). A continuación recorre las entradas de la raíz del ZIP y exige que exista un único archivo con extensión `.rtp`; si encuentra más de uno, o ninguno, el importador devuelve error con un mensaje descriptivo.
- Durante la importación, el `.rtp` localizado en la raíz del ZIP se extrae siempre a la carpeta de sesiones canónica `com.reactable/Sessions/`, respetando el nombre de archivo original (`<com_reactable_root>/Sessions/<rtp_filename>`). La ruta base `com_reactable_root` se recibe como argumento y, en ausencia de valor, se asume `./com.reactable` como raíz relativa; el importador se asegura de crear los directorios necesarios mediante `std::filesystem::create_directories`.
- Si el ZIP contiene una carpeta cuyo nombre coincide con el basename del `.rtp` (por ejemplo, `Loopdemo/` dentro del archivo `Loopdemo.rtz`), todas las entradas bajo ese prefijo se extraen a `com.reactable/Samples/<basename>/...`, preservando la estructura relativa interna. Los archivos cuyo último componente de ruta empieza por punto (`.DS_Store`, archivos temporales ocultos, etc.) se descartan explícitamente y no se copian, de acuerdo con el esquema original de contenidos de Reactable.
- Al escribir cualquier archivo extraído (tanto el `.rtp` como los WAV de Samples), el importador compara primero el contenido con un posible archivo ya existente en disco: si el fichero de destino existe y es byte a byte idéntico al contenido del ZIP (mismo tamaño y comparación completa en bloques), no se sobrescribe. Si existe pero difiere, se sobrescribe con la versión del `.rtz`. Esta política cumple el requisito de “no sobrescribir si son idénticos” y sigue permitiendo actualizar sesiones o Samples cuando el contenido realmente cambia.
- Una vez completada la extracción, `ReactableRtzLoader` delega la validación de la sesión en el loader existente de `.rtp`: llama a `LoadReactablePatchFromFile` sobre la ruta final del archivo `.rtp` guardado en `com.reactable/Sessions/`, de forma que el modelo `Scene`, las conexiones y el `ReactablePatchMetadata` se rellenan reutilizando toda la lógica de parseo XML ya probada. Si el `.rtp` interno es inválido o no puede parsearse, el importador de `.rtz` devuelve error agregando el mensaje generado por el loader de `.rtp`.
- En CMake se ha integrado `libzip` como dependencia opcional de `rectai-core-lib` en entornos UNIX a través de `pkg-config` (`pkg_check_modules(LIBZIP REQUIRED libzip)` en [core/CMakeLists.txt](core/CMakeLists.txt)), añadiendo sus includes y librerías a `rectai-core-lib` y definiendo la macro de compilación `RECTAI_HAVE_LIBZIP` cuando está disponible. El propio `ReactableRtzLoader` compila la ruta principal de importación sólo cuando esta macro está definida; en caso contrario, expone un stub que informa de que el soporte RTZ no está disponible.
- Se han actualizado las dependencias de sistema en [DEPENDENCIES.md](DEPENDENCIES.md), el `Dockerfile` raíz y el `Earthfile` para instalar `libzip-dev` en las imágenes de build basadas en Ubuntu 22.04, garantizando que el loader `.rtz` está operativo tanto en el host como dentro de los contenedores usados por el proyecto.
- En la app principal JUCE (`MainComponent`), el lambda interno `loadPatchFromFile` ahora detecta la extensión del archivo de sesión: si es `.rtz` delega en `LoadReactableSessionFromRtz`, pasando como raíz de `com.reactable` el directorio derivado de `Resources/default.rtp` (si existe) o, en su defecto, `./com.reactable`. Para el resto de extensiones (incluida `.rtp`) se mantiene el camino previo vía `LoadReactablePatchFromFile`. El resto de lógica de inicialización tras la carga (color y mute del master, flags de mute por conexión, BPM global, carga de SoundFonts y loops, etc.) permanece idéntica y se aplica tanto a sesiones cargadas desde `.rtp` como importadas desde `.rtz`.

### Limpieza de metadatos específicos de macOS en RTZ
- El importador de sesiones RTZ en [core/src/core/ReactableRtzLoader.cpp](core/src/core/ReactableRtzLoader.cpp) ahora ignora explícitamente las entradas de carpeta `__MACOSX/` y los archivos de metadatos típicos de macOS (`.DS_Store` y `._.DS_Store`) tanto al escanear el contenido del ZIP en busca del `.rtp` principal como al extraer la carpeta de Samples asociada al basename del `.rtp`. Esto evita que los ficheros auxiliares generados por Finder se consideren candidatos a sesión o se copien a `com.reactable/Samples`, alineando el comportamiento del loader con la estructura real de contenidos de las sesiones Reactable.

### Metadata de autores y título en sesiones cargadas
- Se ha extendido el loader de patches RTP en [core/src/core/ReactableRtpLoader.cpp](core/src/core/ReactableRtpLoader.cpp) para que, además del esquema antiguo basado en atributos (`<author name="..." />`, `<patch name="..." />`), sea capaz de extraer la metadata de autor/es y título del esquema `reactablepatch` 0.2 que utiliza un bloque `<details>` anidado con `<authors><author>...</author></authors>` y `<title>...</title>`. El código recorre el contenido interno de `<authors>` y construye una cadena `author_name` uniendo todos los `<author>` no vacíos con `", "`, aplicando `Trim` a cada uno para eliminar espacios sobrantes; de forma análoga, extrae el texto de `<title>` y lo normaliza con `Trim` antes de asignarlo a `patch_name`.
- Tras esta ampliación, la estructura `ReactablePatchMetadata` sigue exponiendo los mismos campos (`author_name`, `patch_name`, color y mute del master), pero ahora se rellena correctamente tanto para sesiones antiguas como para patches 0.2 como `LoadedCubes.rtp`, donde el autor se declara como texto dentro de `<author>` y no como atributo. Si el esquema antiguo ya ha proporcionado un valor no vacío, la ruta de `<details>` actúa sólo como fallback y no lo sobreescribe.
- En el lambda `loadPatchFromFile` de `MainComponent` ([core/src/MainComponent.cpp](core/src/MainComponent.cpp)), justo después de aplicar el color y el estado de mute del master y antes de inicializar BPM y estados de mute por conexión, se registra ahora un log informativo con `juce::Logger::writeToLog`. El mensaje tiene el formato `"Loaded project: "` seguido, si existen, del autor/es y el título obtenidos de `ReactablePatchMetadata`, combinados como `"<autor1, autor2, ...> - <título>"` o utilizando sólo la parte disponible cuando uno de los dos campos está vacío. Tanto autores como título se recortan con `trim()` para evitar espacios sobrantes y soportar correctamente casos en los que los nodos `<author>` o `<title>` contenían únicamente espacios.

## 2025-12-18

### Alineación del pulso BPM central con Loops
- Se ha ajustado el cálculo del **strong beat** que alimenta tanto el pulso central de la mesa como el pequeño acento de velocidad en las notas Sampleplay disparadas en cada negra. Hasta ahora, la lógica consideraba como fuerte el beat con índice `0` dentro del compás de 4/4 (`beatInBar = b % 4; strong = (beatInBar == 0)`), lo que en práctica hacía que el pulso grande del centro de la mesa apareciera visualmente en el tercer tiempo percibido cuando se reproducían Loops basados en el reloj global.
- En `MainComponent_Audio::timerCallback` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L2585-L2615)) se mantiene la derivación de `wholeBeats` a partir de `audioEngine_.transportBeats()`, pero se cambia la condición de acento a `strong = (beatInBar == 2)`. Con este desplazamiento de **dos tiempos dentro del compás 4/4**, el pulso fuerte del centro y el pequeño realce de `velocity01` aplicado en `triggerSampleplayNotesOnBeat(strong)` pasan a coincidir con el primer tiempo percibido en la mayoría de loops de 4 beats usados en las sesiones actuales.
- El resto de elementos sincronizados con el transporte (barra de reproducción roja y trail blanco en los módulos Loop, secuenciador de 16 steps y conexiones visuales) siguen basándose en la misma posición global en beats (`transportBeats_ + beatPhase_`). El cambio se limita al criterio visual de qué beat dentro del compás se considera acentuado para el pulso central y para el acento de Sampleplay, de forma que la sensación de “beat grande” en el centro de la mesa quede alineada con la base rítmica de los Loops.

### Velocidad de expansión de los pulsos centrales
- Se ha acelerado la animación de los pulsos concéntricos del centro de la mesa reduciendo su vida útil visual. En `MainComponent_Audio::timerCallback` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L2195-L2210)) el envejecimiento de cada `Pulse` se basaba en un tiempo de vida fijo de 1.0 s (`pulseLifetimeSeconds = 1.0`), de modo que cada círculo se expandía desde el radio base hasta el máximo y se desvanecía a lo largo de aproximadamente un segundo real.
- Ahora el tiempo de vida se ha reducido a `pulseLifetimeSeconds = 0.5`, por lo que el incremento de `age` por tick (`ageStep = dt / pulseLifetimeSeconds`) es el doble de rápido. El código de pintado en [core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L430-L455) sigue mapeando `pulse.age` a un factor normalizado `t = clamp(age, 0, 1)`, de manera que el radio y la opacidad recorren el mismo rango que antes pero en aproximadamente medio segundo.
- Este ajuste hace que, a un mismo BPM, la sensación visual de “latido” en el centro de la mesa sea más ágil, con ondas que aparecen, se expanden y desaparecen con mayor rapidez, sin alterar el momento en que se generan los pulsos (que sigue anclado a los beats enteros del transporte global) ni la alineación previa con los Loops.

### Rejilla interna de 8 pulsos y compensación de fase del beat
- Se ha cambiado la generación de pulsos del centro de la mesa para que utilice una **rejilla interna de 8 subdivisiones por compás de 4/4** (dos pulsos por beat) en lugar de depender únicamente del contador entero de beats. En `MainComponent_Audio::timerCallback` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L2585-L2625)) se introduce un contador `lastPulseStep_` y se calcula `pulseStepNow = floor((engineBeats + kPulsePhaseOffsetBeats) * 2.0)`, donde `engineBeats` es la posición global de transporte en beats derivada del motor de audio.
- A partir de esa rejilla de 8 pasos (`stepInBar = step % 8`), sólo se generan realmente pulsos visuales y disparos de Sampleplay en los **pasos de negra** (`stepInBar` par), manteniendo así cuatro pulsos “visibles” por compás como antes. El acento fuerte se conserva en la última negra del compás (`stepInBar == 6`), equivalente al beat de índice 3 dentro del 4/4, de forma coherente con la alineación previa establecida para los Loops.
- Para corregir el desfase observado de aproximadamente **medio pulso** respecto a la base de los Loops, se aplica un pequeño desplazamiento de fase puramente visual `kPulsePhaseOffsetBeats = -0.5`, que adelanta los pulsos de la rejilla medio beat sin modificar la posición real del transporte de audio ni el cálculo de `transportBeats_`/`beatPhase_`. El motor de audio y el secuenciador siguen trabajando con `engineBeats` sin offset; sólo la generación de `pulses_` y de los acentos de Sampleplay se basa en la rejilla desplazada.
- Con este cambio, el número de pulsos visibles por compás sigue siendo el mismo (cuatro ondas concéntricas por 4/4), pero su fase se ajusta con resolución de 1/8 de compás gracias a la rejilla interna de 8 pasos, reduciendo la sensación de que el pulso central va “medio tiempo” retrasado respecto a la base rítmica de los Loops.

### Refactorización de módulos con Envelope: AudioModuleWithEnvelope
- Se ha introducido una nueva clase base `AudioModuleWithEnvelope` en [core/src/core/AudioModules.h](core/src/core/AudioModules.h) para unificar la gestión de envolventes ADSR en los módulos de audio que las utilizan. Esta clase hereda de `rectai::AudioModule` y expone un miembro protegido `Envelope envelope_` junto con dos accesores públicos: `[[nodiscard]] const Envelope& envelope() const` y `Envelope& mutable_envelope()`. El constructor de `AudioModuleWithEnvelope` se delega completamente al de `AudioModule` mediante `using AudioModule::AudioModule`, de modo que los módulos derivados pueden seguir inicializando la parte base con los mismos argumentos que antes.
- Los módulos que previamente mantenían su propia instancia de `Envelope` han pasado a heredar de `AudioModuleWithEnvelope` en lugar de `AudioModule` y han eliminado los campos y getters duplicados:
  - `OscillatorModule` ahora declara `class OscillatorModule : public AudioModuleWithEnvelope` y reutiliza los accesores de la base para su envolvente, manteniendo el resto de su API intacta.
  - `FilterModule` hereda también de `AudioModuleWithEnvelope`; sus métodos específicos `set_envelope_attack/decay/duration/release` siguen operando sobre `envelope_`, pero este miembro se declara ahora en la clase base. La inicialización por defecto de la envolvente (valores en ms y publicación como parámetros `attack/decay/duration/release`) permanece en [core/src/core/AudioModules.cpp](core/src/core/AudioModules.cpp#L80-L120).
  - Los módulos `DelayModule`, `ModulatorModule`, `WaveShaperModule`, `InputModule` y `LoopModule` se han actualizado para heredar de `AudioModuleWithEnvelope` y han eliminado sus campos locales `Envelope envelope_{}`. Sus getters `envelope()`/`mutable_envelope()` ahora provienen de la clase base sin necesidad de redefinirlos, manteniendo la misma interfaz pública para consumidores como `MainComponent_Audio` y los loaders de patches RTP.
- En las implementaciones de constructores de [core/src/core/AudioModules.cpp](core/src/core/AudioModules.cpp) se han actualizado las listas de inicialización para llamar a la nueva base intermedia en lugar de a `AudioModule` directamente:
  - `OscillatorModule`, `FilterModule`, `DelayModule`, `ModulatorModule`, `WaveShaperModule`, `InputModule` y `LoopModule` inicializan ahora con `AudioModuleWithEnvelope(id, ModuleType::..., /*produces_audio=*/..., /*consumes_audio=*/..., /*produces_midi=*/..., /*consumes_midi=*/...)`, preservando exactamente los mismos flags de capacidades de audio/MIDI que antes.
  - El resto de lógica en los constructores (colores, etiquetas, descripciones, configuración de puertos y parámetros por defecto) no se ha modificado.
- Las referencias a `envelope()` en la UI y en los tests siguen funcionando de forma transparente al apoyar ahora en la nueva clase base:
  - En [core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L1351-L1358 y core/src/MainComponent_Audio.cpp#L1985-L1999) se continúa accediendo a `loopModule->envelope()` y `oscModule->envelope()` para configurar las envolventes en el motor de audio sin cambios en la firma.
  - En los tests de dominio de [tests/scene_tests.cpp](tests/scene_tests.cpp#L932-L963) que validan la inicialización y los setters de `FilterModule` se sigue verificando el mismo comportamiento sobre `filter.envelope()` y los parámetros de escena asociados (`attack/decay/duration/release`), confirmando que la migración del miembro `envelope_` a la base no altera la API observada.
- Tras el refactor se ha recompilado todo el proyecto mediante CMake desde `build/` (target `rectai-core-lib` y binarios asociados) y se ha ejecutado la batería de tests con `ctest --output-on-failure`, obteniendo de nuevo que pasan los ejecutables `rectai-core-tests` y `rectai-tracker-tests` sin regresiones. Esto confirma que la introducción de `AudioModuleWithEnvelope` no ha cambiado el comportamiento observable de los módulos ni su integración con la UI o el motor de audio, y deja preparada una base común para futuros módulos que requieran envolventes.

### Alineación del selector de sample en LoopModule
- Se ha corregido la alineación del triángulo selector de sample en los módulos `Loop` dentro del control lateral izquierdo (Freq). Hasta ahora, la punta del triángulo se posicionaba mediante una interpolación lineal vertical entre `sliderBottom` y `sliderTop`, mientras que los cuatro segmentos de la barra se distribuían uniformemente en ángulo a lo largo del arco visible (que deja un margen de 3 px arriba y abajo respecto al semicírculo completo). Esta discrepancia provocaba que, al rotar el fiducial del Loop, el triángulo pareciera entrar en el siguiente segmento antes de que el slot activo cambiara realmente, generando una sensación de desalineación.
- En `MainComponent::paint` ([core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L1688-L1820)) el cálculo de la posición del triángulo se ha actualizado para reutilizar el mismo rango angular que ya usan los segmentos de la barra. En lugar de mapear `sampleParam` directamente a una coordenada Y lineal, ahora se obtiene un ángulo `triAngle` mediante `juce::jmap(sampleParam, 0.0f, 1.0f, angleBottom, angleTop)` y se proyecta la punta del triángulo sobre el mismo círculo de radio `ringRadius` (`barX = cx - ringRadius * cos(triAngle)`, `triY = cy + ringRadius * sin(triAngle)`). De este modo, el triángulo recorre exactamente el mismo arco visible que los cuatro segmentos, respetando el margen de 3 px en la parte superior e inferior.
- El índice de segmento activo (`activeIndex`) sigue derivándose de `sampleParam` cuantizado en cuatro slots (`int(sampleParam * 4.0f)`), de forma que el resaltado de segmento y la posición angular del triángulo permanecen sincronizados: cuando el usuario gira el fiducial, el triángulo cruza los límites entre segmentos en el mismo instante en que cambia el slot de sample reproducido. Esto elimina el efecto visual de “ya está en el otro segmento pero aún no cambia”.

### Barra de reproducción y trail para LoopModule
- Se ha añadido una barra de reproducción visual alrededor de los módulos `Loop` en la UI principal de `rectai-core`. Para cada `LoopModule` dentro del área musical se dibuja ahora una línea fina roja de 2 px que orbita entre el cuerpo circular del módulo y el anillo de controles laterales (Freq/Gain), siguiendo una trayectoria circular completa alrededor del nodo.
- La posición angular de la barra roja se calcula a partir del mismo reloj de transporte que usa el motor de audio: en `MainComponent_Audio::timerCallback` ya se sincroniza `transportBeats_` y `beatPhase_` con `audioEngine_.transportBeats()`, y en `MainComponent::paint` ([core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L1460-L1785)) se obtiene una fase normalizada de loop `phase01` aplicando un `fmod` de `transportBeats_ + beatPhase_` por el número de beats declarados en el `LoopDefinition` activo. Esto garantiza que la barra de reproducción está bloqueada en fase con la posición real del sample que se está reproduciendo en el motor de audio.
- Para cada `LoopModule` se mantiene ahora un pequeño historial de muestras de fase en `loopPlayTrails_` ([core/src/MainComponent.h](core/src/MainComponent.h#L120-L170)), donde cada entrada almacena `phase01` y un timestamp en segundos. En cada frame de pintado se inserta la muestra actual y se purgan las que superan una ventana de 300 ms o exceden un máximo de 15 segmentos, de forma que el coste de mantenimiento del trail permanece acotado.
- A partir de ese historial, el pintado dibuja primero la traza blanca (trail) y después la barra roja actual: para cada muestra reciente de `loopPlayTrails_` se calcula el ángulo correspondiente y se traza una pequeña barra radial blanca en el mismo anillo, con una opacidad que decae linealmente desde 1.0 a 0.0 a lo largo de los 300 ms de ventana. El resultado es una estela blanca que sigue a la barra roja y se desvanece rápidamente, reforzando visualmente el sentido de movimiento continuo del loop.
- La barra roja actual se dibuja siempre por encima del trail (plena opacidad, color `juce::Colours::red`) utilizando un radio interior `innerRadius = nodeRadius + 3.0f` y uno exterior `outerRadius = ringRadius - 3.0f`, de modo que queda claramente situada en el espacio entre el círculo del módulo y las barras de Freq/Gain sin solaparlas. Como todo el pintado del nodo se realiza dentro de una `AffineTransform::rotation` alrededor del centro del módulo, la barra de reproducción mantiene su órbita correctamente alineada con la orientación del nodo y con la radial de audio hacia el master.
- La lógica de la barra de reproducción sólo se activa cuando el loop activo tiene un metadato de beats válido (`LoopDefinition::beats > 0`); en ese caso el ángulo se deriva de la fase de beat global y el número de beats del loop, garantizando que los cambios de slot (cuando el usuario rota o hace scroll sobre el módulo Loop) mantienen los distintos samples perfectamente alineados con el transporte.

### Indicador visual de tráfico OSC/TUIO en rectai-core
- Se ha añadido un pequeño indicador de actividad de entrada en la UI principal de `rectai-core` para mostrar de forma discreta si la aplicación está recibiendo tráfico de tracking vía OSC propietario (`/rectai/*`) o vía TUIO estándar (`/tuio/*`). El indicador aparece como una etiqueta compacta `OSC` o `TUIO` en la esquina superior derecha de la mesa, justo a la izquierda del dock, y se oculta automáticamente si pasan 60 segundos sin recibir ningún mensaje de entrada.
- Para ello se ha extendido `TrackingOscReceiver` en [core/src/TrackingOscReceiver.h](core/src/TrackingOscReceiver.h) y [core/src/TrackingOscReceiver.cpp](core/src/TrackingOscReceiver.cpp) con un nuevo enum `ActivityKind { kOsc, kTuio }` y un callback opcional `setActivityCallback(std::function<void(ActivityKind)>)`. El receptor invoca este callback cada vez que clasifica un mensaje entrante como tráfico OSC propietario (`/rectai/object`, `/rectai/remove`) o como tráfico TUIO (`/tuio/hello`, `/tuio/2Dobj`, `/tuio/2Dcur)`; los mensajes en otras rutas siguen tratándose únicamente como logs de depuración y no disparan el indicador.
- `MainComponent` mantiene ahora un pequeño estado de actividad en [core/src/MainComponent.h](core/src/MainComponent.h): un enum interno `InputActivityKind { kNone, kOsc, kTuio }`, un timestamp `lastInputActivitySeconds_` y otro `inputActivityPulseSeconds_`. El callback registrado en el constructor ([core/src/MainComponent.cpp](core/src/MainComponent.cpp)) traduce `ActivityKind` a `InputActivityKind`, actualiza los timestamps con el reloj de alta resolución de JUCE y solicita un `repaintWithRateLimit()` para que la UI refleje el nuevo mensaje sin superar el límite global de FPS.
- En `MainComponent::paint` ([core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp)) se calcula siempre un rectángulo de referencia para el dock (`dockAreaUi`) a partir de `calculateDockWidth`, independientemente de que existan o no objetos docked. A partir de ese rectángulo se dibuja, si corresponde, una cápsula semitransparente alineada con la parte superior de la mesa y situada justo a la izquierda del dock, que contiene el texto `TUIO` o `OSC` y una pequeña bolita verde. El texto se muestra mientras `now - lastInputActivitySeconds_ <= 60` y cambia automáticamente de `OSC` a `TUIO` cuando el último mensaje procesado pertenece al flujo TUIO.
- La bolita verde funciona como un “parpadeo” de tráfico: cada vez que llega un mensaje válido el callback actualiza `inputActivityPulseSeconds_` y el bloque de pintado muestra el círculo durante un intervalo corto (≈250 ms) calculado como `now - inputActivityPulseSeconds_ <= 0.25`. De este modo, cada paquete entrante genera un destello visible sobre la etiqueta sin necesidad de mantener un contador explícito por tick.
- Para que el indicador pueda repintarse incluso en escenas sin audio activo ni animaciones, se ha ampliado la condición `hasVisualActivity` en `MainComponent_Audio::timerCallback` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp)) para considerar también la ventana de visibilidad del indicador: mientras `lastInputActivitySeconds_` esté dentro de los últimos 60 segundos o la ventana corta del pulso esté activa, `timerCallback` llamará a `repaintWithRateLimit()`. Esto garantiza que el texto del protocolo y los destellos verdes se actualicen sin reactivar otras animaciones innecesarias.

## 2025-12-17

### Diseño inicial de soporte TUIO 1.1 y anuncio OSC
- Se ha creado un nuevo documento de diseño en [research/tuio-protocol.md](research/tuio-protocol.md) que describe la estrategia inicial para integrar el protocolo TUIO en el proyecto, comenzando por TUIO 1.1 sobre transporte OSC/UDP y dejando preparada la evolución posterior hacia TUIO 2.0.
- El documento resume los perfiles relevantes de TUIO 1.1 para `rectai-table` (principalmente `tuio/2Dobj` para fiduciales y `tuio/2Dcur` para fingers), los tipos de mensajes (`set`, `alive`, `fseq`) y el mapeo conceptual de los atributos actuales de fiduciales del tracker (session id, symbol id, posición normalizada y ángulo) a los campos estándar de TUIO.
- Se definió un mensaje ligero de anuncio `/tuio/hello` que `rectai-tracker` envía una vez al arrancar en modo TUIO, incluyendo identificador de cliente, versión TUIO (`"1.1"`) y versión interna de tracker (`"0.1.0"`), sin esperar ninguna respuesta por parte del core. El core, al recibir este mensaje, simplemente lo registra en los logs (tracker id, versión de cliente y protocolo TUIO usado) y continúa recibiendo mensajes TUIO estándar.
- Se ha esbozado también el plan para integrar detección de fingers en el tracker y exponerlos al core mediante el perfil `tuio/2Dcur`, de forma que puedan traducirse en múltiples punteros lógicos (eventos equivalentes a ratón) y permitan interacciones multitouch. La adaptación interna del core para soportar múltiples punteros y el soporte de TUIO 2.0 quedan planificados para fases posteriores.

### Implementación inicial de soporte TUIO 1.1 entre rectai-tracker y rectai-core
- En el tracker se ha introducido un pequeño módulo de configuración en [tracker/src/TuioNegotiation.h](tracker/src/TuioNegotiation.h) que define el enum `rectai::tracker::TuioOutputMode` (`LegacyOsc` vs `Tuio11`). La lógica de negociación TUIO que existía en versiones anteriores se ha eliminado y el modo de salida se decide ahora directamente en `main.cpp` en función del flag `--osc` y de la disponibilidad del socket OSC.
- Para reutilizar la infraestructura de empaquetado OSC existente en el tracker, `OscSender` ([tracker/src/OscSender.h](tracker/src/OscSender.h#L1-L80), [tracker/src/OscSender.cpp](tracker/src/OscSender.cpp#L1-L240)) ha ganado un método público `sendHelloTuio11(const std::string& trackerId, const std::string& trackerVersion)`. Este método construye un mensaje OSC con dirección `/tuio/hello` y type tags `",sss"` que codifica tres strings: identificador del tracker, versión TUIO (`"1.1"`) y versión interna del tracker (`"0.1.0"` por ahora), y lo envía por el mismo socket UDP ya conectado hacia el core (host `127.0.0.1`, puerto 3333). En el flujo actual, `rectai-tracker` envía este mensaje una sola vez al arrancar en modo TUIO, sin esperar respuesta.
- En el arranque de `rectai-tracker` ([tracker/src/main.cpp](tracker/src/main.cpp#L1-L160)), justo después de crear el `OscSender`, se decide el modo de salida en función de un nuevo flag de línea de comandos `--osc`. Si se pasa `--osc` se fuerza `TuioOutputMode::LegacyOsc` y el tracker conserva el formato OSC propietario (`/rectai/object` y `/rectai/remove`). Si no se pasa el flag y el socket OSC se ha creado correctamente, se selecciona `TuioOutputMode::Tuio11` (modo TUIO) y se envía un `/tuio/hello` "best effort" sin depender de un ACK.
- En el core se ha extendido `TrackingOscReceiver` ([core/src/TrackingOscReceiver.h](core/src/TrackingOscReceiver.h#L1-L60), [core/src/TrackingOscReceiver.cpp](core/src/TrackingOscReceiver.cpp#L1-L180)) para escuchar también la dirección `/tuio/hello`. Además de registrar los listeners para `/rectai/object`, `/rectai/remove` y `/tuio/2Dobj`, el método privado `handleTuioHelloMessage` valida que el mensaje entrante contenga al menos dos strings (id de tracker y versión TUIO), extrae opcionalmente la versión de cliente si viene como tercer string, y registra en el log de JUCE una línea del tipo `[rectai-core] TUIO hello from rectai-tracker (client 0.1.0, TUIO 1.1, via localhost:3333)`. No se envía ninguna respuesta; el mensaje sirve únicamente como anuncio one-way.
- Cuando el modo activo es `TuioOutputMode::Tuio11`, el tracker emite mensajes TUIO estándar para objetos 2D (`/tuio/2Dobj` con los comandos `set`, `alive` y `fseq`) usando como `s_id` el id de tracking de cada fiducial y como `i_id` el **id lógico de módulo** obtenido a partir de una tabla interna de mapeo fiducial→módulo. En este modo TUIO el tracker **ya no envía** `/rectai/object`/`/rectai/remove`. Si se fuerza `LegacyOsc` con `--osc`, el tracker mantiene el protocolo OSC propietario actual como fallback.
- En el core, `TrackingOscReceiver` sigue soportando ambos formatos en paralelo (TUIO y `/rectai/*`) para que versiones antiguas del tracker sigan funcionando sin cambios. El manejador de `/tuio/2Dobj set` crea/actualiza instancias de `ObjectInstance` usando `sessionId` como `tracking_id`, `i_id` como `logical_id` y coordenadas normalizadas en el sistema de mesa, y ahora también almacena los campos de velocidad TUIO `X`, `Y` y `A` en los nuevos atributos `velocity_x`, `velocity_y` y `angular_velocity` de `ObjectInstance`.

### Integración de TUIO 2Dcur como cursor/touch principal en el core
- Se ha extendido `TrackingOscReceiver` para escuchar también mensajes TUIO de cursores 2D (`/tuio/2Dcur`) además de los objetos 2D. El receptor parsea los comandos estándar `set`, `alive` y `fseq`, manteniendo un conjunto de `sessionId` activos y la última posición normalizada de cada cursor.
- Para simplificar la integración con la UI, `TrackingOscReceiver` expone ahora callbacks opcionales `setTuioCursorCallbacks(onDown, onMove, onUp)` que reciben coordenadas en el sistema de mesa (origen en el centro, radio 1) y el `sessionId` del cursor. La implementación actual trata el **primer `set`** de un `sessionId` como un "pointer down", los siguientes `set` como "move" y la desaparición del id en el siguiente `alive` como "pointer up".
- `MainComponent` registra estos callbacks en su constructor ([core/src/MainComponent.cpp](core/src/MainComponent.cpp#L480-L505)), proyectando las coordenadas de mesa a píxeles de componente mediante el mismo radio y centro que `objectTableToScreen`. Sobre esa posición de pantalla, `MainComponent` reutiliza exactamente la misma lógica que el ratón real: se ha extraído el cuerpo de `mouseDown`, `mouseDrag` y `mouseUp` a helpers privados `handlePointerDown/handlePointerDrag/handlePointerUp` que operan sobre `juce::Point<float>` y `juce::ModifierKeys`.
- Se han añadido los métodos `handleTuioCursorDown/handleTuioCursorMove/handleTuioCursorUp` en `MainComponent` ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L1725-L1756)), que convierten coordenadas TUIO (`tableX`, `tableY`) a posición de pantalla y delegan en los helpers de puntero. De este modo, un cursor TUIO 2Dcur se comporta, desde el punto de vista de la lógica de interacción, como el "ratón principal": al aparecer genera un flujo equivalente a `mouseDown`, al moverse a `mouseDrag` y al desaparecer a `mouseUp`, reutilizando toda la semántica existente (arrastre de módulos, gestos de corte, hold-mute, etc.).

### Logs de depuración para TUIO en rectai-core
- Se ha ampliado `TrackingOscReceiver` para registrar en el log de JUCE la llegada de mensajes TUIO tanto de objetos (`/tuio/2Dobj`) como de cursores (`/tuio/2Dcur`). En concreto, cada comando `set` y `alive` genera ahora una línea `[rectai-core]` con el tipo de comando, número de argumentos y un resumen de ids y coordenadas normalizadas recibidas, lo que permite verificar desde la consola que los eventos TUIO están alcanzando el core y con el formato esperado.
- El handler genérico `oscMessageReceived` también escribe una traza cuando llega un mensaje OSC con una dirección no registrada (`/rectai/object`, `/rectai/remove`, `/tuio/hello`, `/tuio/2Dobj` o `/tuio/2Dcur`), incluyendo la dirección y el número de argumentos. Esto ayuda a diagnosticar rápidamente discrepancias de puerto o de ruta (por ejemplo, si un emisor está usando otra dirección TUIO o un puerto distinto de 3333).

### Corrección de type-tags TUIO 2Dobj en rectai-tracker
- Se ha corregido el mensaje `set` TUIO 2Dobj que emite el tracker en `OscSender::sendTuio2DobjSet` ([tracker/src/OscSender.cpp](tracker/src/OscSender.cpp#L40-L120)). El payload que se construía ya contenía los 10 campos estándar de TUIO 1.1 (`set`, `s_id`, `i_id`, `x`, `y`, `a`, `X`, `Y`, `A`, `m`, `r`), es decir, 2 enteros de 32 bits y 8 floats, pero la cadena de type-tags declarada era `",siiffffff"` (2 enteros y solo 7 floats).
- Esta discrepancia hacía que el receptor OSC de JUCE (`OSCReceiver`) leyera menos elementos de los realmente presentes y detectara bytes sobrantes al final del mensaje, emitiendo el error `OSC input stream format error: wrong element content size encountered while reading` y descartando el contenido de ese paquete.
- Ahora el tracker declara correctamente la firma del mensaje como `",siiffffffff"` (2 enteros y 8 floats), alineando la longitud efectiva del mensaje con los type-tags y evitando los `OSCFormatError` al recibir TUIO 2Dobj en el core.

### Soporte de OSC Bundles en el receptor TUIO de rectai-core
- `TrackingOscReceiver` se ha adaptado para recibir no sólo mensajes OSC planos, sino también bundles anidados como los que generan `reacTIVision` y TUIO Simulator. En lugar de usar `OSCReceiver::ListenerWithOSCAddress`, ahora implementa la interfaz genérica `OSCReceiver::Listener<MessageLoopCallback>` y se registra con `addListener(this)`.
- Se ha añadido una implementación de `oscBundleReceived(const juce::OSCBundle& bundle)` en [core/src/TrackingOscReceiver.cpp](core/src/TrackingOscReceiver.cpp#L20-L80) que recorre recursivamente cada elemento del bundle (mensaje u otro bundle) y, cuando encuentra un `OSCMessage`, llama a `oscMessageReceived` con él. De este modo, todos los mensajes `/tuio/2Dobj` y `/tuio/2Dcur` contenidos dentro de un `#bundle` pasan por el mismo flujo de dispatch que los mensajes enviados de forma independiente por `rectai-tracker`.
- Esto resuelve el problema observado con TUIO Simulator: antes, al enviar únicamente bundles (sin mensajes OSC planos), el receptor basado en `ListenerWithOSCAddress` nunca llegaba a ver los mensajes internos y no disparaba `handleTuio2DobjMessage` ni `handleTuio2DcurMessage`. Tras el cambio, los bundles se “aplanan” y el core procesa todas las actualizaciones TUIO estándar, permitiendo ver tanto objetos como cursores enviados por cualquier fuente TUIO 1.1 compatible.

## 2025-12-17

### Parámetro de resolución y control de downscale en línea de comandos para rectai-tracker
- Se ha añadido un parser sencillo de argumentos en [tracker/src/main.cpp](tracker/src/main.cpp#L20-L110) que reconoce un nuevo flag opcional `--resolution=WxH`. El valor se interpreta como dos enteros positivos separados por `x` (por ejemplo, `--resolution=1920x1080`); si el formato no es válido, contiene caracteres no numéricos o alguno de los dos valores es menor o igual que 0, el parser devuelve `std::nullopt` y el binario ignora silenciosamente el flag, manteniendo el comportamiento anterior.
- Para soportar este flag se ha introducido una pequeña estructura `Resolution { int width; int height; }` y la función `parseResolutionArg(int argc, char** argv)`, que recorre los argumentos de la línea de comandos, localiza el prefijo `--resolution=`, extrae la subcadena posterior y la separa por el primer carácter `'x'`. La conversión `std::stoi` de ambas partes está protegida con `try/catch` para devolver `std::nullopt` en caso de error en lugar de lanzar.
- Además, se ha incorporado un flag booleano `--no-downscale` parseado por `hasNoDownscaleFlag(int argc, char** argv)`, que simplemente comprueba la presencia literal del argumento en la línea de comandos.
- En la inicialización del modo en vivo de `rectai-tracker` ([tracker/src/main.cpp](tracker/src/main.cpp#L110-L170)), justo después de abrir la cámara, se obtiene la resolución nativa del dispositivo mediante `cv::CAP_PROP_FRAME_WIDTH` y `cv::CAP_PROP_FRAME_HEIGHT`. Si `parseResolutionArg` ha devuelto una resolución válida, estos valores se sobrescriben con los enteros indicados en el flag antes de llamar a `trackerEngine.initialise(0, width, height, initError, enableDownscale)`, donde `enableDownscale` es `!noDownscale`.
- La clase `TrackerEngine` ha extendido la firma de `initialise` en [tracker/src/TrackerEngine.h](tracker/src/TrackerEngine.h#L20-L55) y [tracker/src/TrackerEngine.cpp](tracker/src/TrackerEngine.cpp#L40-L90) para aceptar un parámetro opcional `bool enableDownscale = true`. El bloque que antes forzaba la reducción de resolución interna a `kMaxProcessingWidth x kMaxProcessingHeight` ahora sólo se ejecuta cuando `enableDownscale` es verdadero. De este modo, al lanzar el binario con `--no-downscale`, `TrackerEngine` trabaja directamente a la resolución de entrada solicitada (tanto si viene de la cámara como del flag `--resolution`) y deja de aplicar el tope interno, evitando que las imágenes procesadas por libfidtrack se reescalen por debajo de la resolución original.
- Si no se pasa `--resolution` o si el valor es inválido, el tracker continúa inicializándose con la resolución que expone la cámara. Si no se pasa `--no-downscale`, el comportamiento por defecto sigue siendo aplicar el clamp interno a `kMaxProcessingWidth/kMaxProcessingHeight` para limitar el coste de CPU de libfidtrack. Los tests de `tracker_tests.cpp` siguen compilando y funcionado como antes al usar la sobrecarga de `initialise` con el valor por defecto de `enableDownscale`.

### Optimización de CPU en rectai-tracker (libfidtrack + OpenCV)
- Se ha reducido la carga de CPU del servicio de tracking `rectai-tracker` actuando sobre las rutas calientes identificadas en perfiles de Callgrind (`reacTIVision/ext/libfidtrack/segment.c:build_regions`, `merge_regions`, `new_region`, así como `cv::threshold` y `cv::adaptiveThreshold`). La optimización se centra en dos frentes: limitar la resolución interna de procesado para libfidtrack y simplificar la estrategia de binarización previa.
- En `TrackerEngine` ([tracker/src/TrackerEngine.cpp](tracker/src/TrackerEngine.cpp#L10-L120)) se ha introducido un tope de resolución interna para el segmenter Amoeba: constantes `kMaxProcessingWidth = 640` y `kMaxProcessingHeight = 480`. Durante `initialise`, los valores `frameWidth_` y `frameHeight_` ya no se usan directamente como vienen de la cámara; si alguno de los dos excede el tope, se calcula un factor de escala `scale = min(640 / width, 480 / height)` y se reescala ambos manteniendo la relación de aspecto. El segmenter (`initialize_segmenter`) y toda la lógica de `detectAmoebaFiducials` pasan a trabajar siempre con esta resolución acotada, mientras que `processFrameInternal` reescala cada frame de cámara a `frameWidth_ x frameHeight_` antes de binarizar.
- Este cambio hace que el coste de CPU de las funciones más caras de libfidtrack (`build_regions`, `merge_regions`, `r1_adjacent_contains_r2`, etc.) sea proporcional a un área máxima fija (aprox. 640×480) en lugar de crecer con la resolución nativa del sensor (por ejemplo, 1920×1080). En escenarios donde la cámara opera en HD o superior, el número de píxeles que atraviesan el pipeline de segmentación se reduce en un factor aproximado de 3–4×, con impacto directo en el porcentaje de instrucciones atribuidas a `segment.c` en nuevos perfiles de Callgrind.
- Adicionalmente, se ha simplificado la estrategia de binarización en `TrackerEngine::processFrameInternal` ([tracker/src/TrackerEngine.cpp](tracker/src/TrackerEngine.cpp#L120-L210)). Antes se probaban hasta cuatro estrategias por frame: Otsu normal, Otsu invertido y dos variantes de `cv::adaptiveThreshold` (normal e invertida), cada una llamando a `detectAmoebaFiducials` y, por tanto, a `step_segmenter` y `find_fiducialsX`. Esto podía multiplicar por 3–4 el coste de segmentación en frames donde no se encontraban marcadores o donde sólo funcionaba una de las estrategias adaptativas.
- Ahora `processFrameInternal` mantiene únicamente las dos primeras estrategias (Otsu normal e invertido) y ha eliminado las dos llamadas a `cv::adaptiveThreshold`. El flujo es: se convierte a escala de grises, se reescala a la resolución interna fijada, se aplica `cv::threshold(..., THRESH_BINARY | THRESH_OTSU)` y, si no hay fiduciales válidos, se intenta una segunda vez con `THRESH_BINARY_INV | THRESH_OTSU`. Si ambas fallan, la función retorna una lista vacía sin seguir probando más umbrales. Esto reduce tanto el trabajo en OpenCV (ya no se ejecutan kernels costosos de `adaptiveThreshold` por frame) como el número máximo de ejecuciones de `step_segmenter`/`find_fiducialsX` por frame a dos.
- El cambio mantiene el comportamiento básico esperado en condiciones de iluminación normales (marcadores oscuros sobre fondo claro o viceversa), que ya cubre la mayoría de casos de uso actuales sobre la mesa Reactable. Para escenarios extremos de iluminación no uniforme donde la detección dependiera exclusivamente del threshold adaptativo, la precisión podría degradarse; en caso de ser necesario, se puede reintroducir una variante adaptativa condicionada (por ejemplo, sólo tras N frames consecutivos sin detecciones) sin perder la estructura de optimización actual.
- Tras estos ajustes, se han ejecutado todos los tests del proyecto vía `ctest` (targets de `tests/` incluidos) y continúan pasando, lo que confirma que la reducción de resolución interna y la simplificación de umbrales no han roto la API de `TrackerEngine` ni los casos de prueba de `tracker_tests.cpp`.

### Flags de optimización de CPU en CMake
- Se ha añadido una opción de CMake `RECTAI_ENABLE_CPU_OPTIMIZATIONS` (activada por defecto en toolchains no-MSVC) en [CMakeLists.txt](CMakeLists.txt#L1-L80) que inyecta flags específicos de CPU únicamente en configuraciones `Release` y `RelWithDebInfo`.
- Para compiladores GCC/Clang, si el toolchain soporta las flags, se añaden `-march=native` y `-mtune=native` mediante `check_cxx_compiler_flag` y `add_compile_options`, manteniendo intactos los niveles de optimización generales (`CMAKE_BUILD_TYPE`, flags recomendados de JUCE, etc.).
- Estas flags se aplican a todos los targets del proyecto (app principal, tracker, tests y librerías) pero quedan desactivadas en `Debug` para facilitar el debugging y evitar optimizaciones agresivas en builds de desarrollo.

### Flags de -ffast-math y frame pointer en CMake
- En el CMake raíz ([CMakeLists.txt](CMakeLists.txt#L20-L80)) se han añadido flags globales específicas para GCC/Clang que actúan según el tipo de configuración:
  - En builds `Release` y `RelWithDebInfo` se activa `-ffast-math` de forma global, permitiendo optimizaciones más agresivas sobre coma flotante en todos los targets (rectai-core, rectai-tracker, tests y librerías). Esto se suma a las flags de CPU (`-march/-mtune=native`) cuando `RECTAI_ENABLE_CPU_OPTIMIZATIONS` está habilitado.
  - En builds `Debug` se fuerza `-fno-omit-frame-pointer`, lo que mantiene el frame pointer incluso con optimizaciones bajas y mejora la calidad de los perfiles (perf, Callgrind) y de los backtraces al depurar, a cambio de un coste mínimo de rendimiento en entornos no críticos.
- Estas flags sólo se aplican en toolchains no-MSVC y se expresan con `add_compile_options` y `generator expressions` por configuración, de forma que no afectan a la semántica de compilación en otros entornos (Windows/MSVC seguirá usando su configuración por defecto más las flags recomendadas proporcionadas por JUCE).

### Gating de AudioEngine en escenas totalmente idle
- Se ha añadido un mecanismo explícito de **gating de procesado de audio** para reducir la carga de CPU cuando la mesa está completamente en reposo (sin módulos dentro del área musical ni rutas de audio activas). El objetivo es que, al abrir la aplicación sin colocar ningún módulo en la zona de música o en escenas donde ningún módulo transporte audio audible, el `AudioEngine` mantenga el dispositivo inicializado pero deje de generar/samplear audio de forma continua.
- En `AudioEngine` ([core/src/AudioEngine.h](core/src/AudioEngine.h#L260-L340) y [core/src/AudioEngine.cpp](core/src/AudioEngine.cpp#L120-L215)) se han introducido dos flags atómicos:
  - `processingRequested_`: indica si la capa de UI (MainComponent) considera que hay **audio activo** en la escena (módulos dentro del área musical con cadenas de audio no muteadas).
  - `hasPendingOutput_`: lo mantiene el propio hilo de audio y marca si el bloque de callback anterior ha producido alguna muestra no nula (incluyendo colas de release de envolventes, loops o notas Sampleplay).
  Además, se expone el método público `setProcessingActive(bool)` que actualiza `processingRequested_` desde el hilo de UI.
- El callback `audioDeviceIOCallbackWithContext` ahora aplica un **early-return barato** al inicio: si `sampleRate_` es válido, pero tanto `processingRequested_` es `false` como `hasPendingOutput_` es `false`, el motor simplemente rellena los buffers de salida con ceros y retorna sin ejecutar el camino pesado de síntesis/sampling (no se llama a `SampleplaySynth::render`, no se recorren voces de oscilador ni loops). Esto permite que, en escenas totalmente idle, el coste de CPU del hilo de audio se reduzca prácticamente al mínimo, cumpliendo el requisito de no generar ni samplear audio de forma continua cuando no hay módulos activos en la zona musical.
- Para que el motor sepa cuándo puede entrar en ese estado idle sin cortar colas de sonido, se añade un contador por bloque `blockHasNonZeroOutput` en el propio callback:
  - Se inicializa a `false` al principio del procesamiento de un bloque.
  - En ambos caminos (con voces de Oscillator activas y sin ellas, donde sólo se mezclan Sampleplay y Loop), tras limitar y escribir `leftOut/rightOut` para cada muestra se comprueba si `(leftOut != 0 || rightOut != 0)`; si es así, se marca `blockHasNonZeroOutput = true`.
  - Al final del bucle de muestras, `hasPendingOutput_` se actualiza con el valor de `blockHasNonZeroOutput`. De este modo, aunque la UI deje de solicitar procesado (por ejemplo, al sacar el último módulo del área musical), el motor sigue procesando bloques mientras exista salida no nula (colas de release o loops sonando) y sólo pasa a la ruta idle cuando un bloque completo ha resultado silencioso.
- En `MainComponent_Audio::timerCallback` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L1120-L1210 y core/src/MainComponent_Audio.cpp#L1960-L2105)) se reutiliza el set existente `modulesWithActiveAudio_` —que ya se poblaba con los ids de módulos que efectivamente transportan audio audible (Oscillator con nivel > 0, Loop con `loopGain > 0`, Sampleplay con notas disparadas y no muteadas hacia el master)— para informar al motor de audio del estado de actividad:
  - Al inicio del mapeo de escena a audio se limpian `modulesWithActiveAudio_` y `moduleVoiceIndex_`.
  - Durante el cálculo de niveles de generadores, loops y Sampleplay, cada módulo cuya cadena tiene ganancia efectiva > 0 e incluye una ruta no muteada hacia el master inserta su id en `modulesWithActiveAudio_`.
  - Tras configurar las voces de `AudioEngine`, los parámetros de filtros, los loops y las waveform taps por conexión, se llama a `audioEngine_.setProcessingActive(!modulesWithActiveAudio_.empty())`. De esta manera, si no queda ningún módulo con audio audible (por ejemplo, escena vacía, todos los módulos fuera del área musical, o todas las rutas muteadas), `processingRequested_` pasa a `false` y el callback podrá entrar en la ruta idle tan pronto como se agoten las colas existentes.
- Este enfoque garantiza dos cosas:
  - **Escena completamente vacía / sin módulos en el área musical**: `modulesWithActiveAudio_` permanece vacío desde el primer tick, `processingRequested_` es `false` y, como no se ha generado ningún audio, `hasPendingOutput_` sigue siendo `false`. El callback entra directamente en el camino rápido que sólo limpia buffers, cumpliendo el requisito de no ejecutar ninguna operación de generación o muestreo en idle completo.
  - **Escenas con audio transitorio (notas, loops, releases)**: mientras haya salida no nula en el bloque (por ejemplo, por colas de release de Oscillator o loops en curso), `blockHasNonZeroOutput` se mantiene en `true` y, por tanto, `hasPendingOutput_` también. Incluso si en un tick posterior la UI marca `processingActive=false` (por ejemplo, se mutean todas las rutas o se sacan módulos del área musical), el motor continuará procesando bloques hasta observar uno totalmente silencioso, momento en el que podrá dejar de ejecutar la ruta de síntesis sin cortar abruptamente el audio.
- En conjunto, estos cambios reducen sensiblemente la carga de CPU atribuible al hilo de audio cuando se abre la aplicación sin módulos en el área musical o cuando el patch cargado (por ejemplo, `default.rtp`) se encuentra en un instante en el que no hay módulos con audio efectivo. La carga residual de CPU en estos estados pasa a estar dominada por el bucle de `repaint()` y la lógica de UI, tal y como se pretende en el roadmap de optimización de rendimiento.

### Hardlinks por colisión física entre módulos (toggle dinámico ↔ hardlink)
- Se ha corregido la detección de colisiones entre módulos dentro del área musical que disparaba el toggle de hardlinks al chocar dos tangibles compatibles. Tras la migración del modelo de coordenadas de mesa a un sistema centrado en el origen (centro `(0,0)`, radio `1`), el código de colisiones en [core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L620-L700) seguía tratando `ObjectInstance::x/y` como offsets relativos a la esquina superior izquierda del componente (`bounds.getX()/getY()` y `bounds.getWidth()/getHeight()`), en lugar de utilizar el mismo mapeo centro+radio que el render. El resultado era que, visualmente, los módulos podían entrar en contacto, pero las coordenadas usadas para el cálculo de distancia nunca llegaban a estar dentro del umbral de colisión, por lo que no se generaban/toggleaban hardlinks.
- Ahora la detección de colisiones reutiliza la función de ayuda `MainComponent::objectTableToScreen` (definida en [core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L40-L60)), que mapea las coordenadas de mesa (origen en el centro, radio 1) a píxeles de componente usando el mismo centro de la mesa y `tableRadius = 0.45 * min(width, height)` que emplea el pintado. En el bucle de colisiones se sustituye el cálculo manual:
  - Antes: `ax = bounds.getX() + objA->x() * bounds.getWidth()` / `ay = bounds.getY() + objA->y() * bounds.getHeight()` (y análogo para `bx/by`).
  - Después: `posA = objectTableToScreen(*objA, bounds)` y `posB = objectTableToScreen(*objB, bounds)`, usando sus coordenadas `posA.x/posA.y` y `posB.x/posB.y` para calcular la distancia entre centros.
  De esta forma, el radio virtual de colisión (`collisionRadius = 30 px`, con solape mínimo de 4 px) se aplica sobre las mismas posiciones que se usan para dibujar los nodos, alineando el comportamiento lógico (cuándo se considera que han “chocado”) con lo que el usuario ve en pantalla.
- La lógica de toggle del hardlink (`toggleHardlinkBetweenObjects`) no se ha modificado, pero vuelve a ser ejercitada correctamente: cuando dos módulos compatibles se tocan dentro del área musical y no existía conexión previa entre ellos, se crea una conexión `Scene::Connection` marcada como `is_hardlink = true`. Si ya existía una conexión dinámica entre ambos (no hardlink), dicha conexión se promueve a hardlink recordando la pareja en `promotedHardlinkPairs_` para poder restaurar posteriormente la conexión dinámica original cuando el usuario vuelva a separar y hacer colisionar los módulos.
- Como parte de esta corrección se ha añadido un test de dominio en [tests/scene_tests.cpp](tests/scene_tests.cpp#L560-L620) que verifica el comportamiento de promoción/democión de conexiones en `Scene::AddConnection` y `Scene::RemoveConnection` sin depender de la UI:
  - Se crea una escena con un `OscillatorModule` (`osc1`) y un `FilterModule` (`filter1`), se inserta primero una conexión dinámica `osc1 -> filter1` (`is_hardlink = false`) y se comprueba que se acepta.
  - A continuación se simula la promoción a hardlink eliminando la conexión dinámica y añadiendo una nueva conexión con los mismos extremos marcada como `is_hardlink = true`. El test exige que `Scene::AddConnection` acepte esta nueva conexión (los hardlinks no cuentan para el límite de “una única salida dinámica” por módulo) y que la única conexión presente tenga `c.is_hardlink == true`.
  - Finalmente se elimina el hardlink y se reintroduce una conexión dinámica con los mismos extremos, comprobando que vuelve a aceptarse y que la conexión resultante tiene `c.is_hardlink == false`. Este flujo refleja la semántica esperada de la UI: al chocar dos módulos con una conexión dinámica previa, ésta se convierte en hardlink; al volver a togglear, se restablece la conexión dinámica original en lugar de dejar los módulos desconectados.
- Con este cambio, la interacción “chocar módulos para conectarlos” vuelve a funcionar como en versiones anteriores: dos módulos audio-compatibles que se mueven dentro de la zona musical y se hacen tocar generan un hardlink (o promueven la conexión dinámica a hardlink) respetando las reglas globales de ruteo definidas en `Scene` (una sola salida dinámica por módulo, múltiple hardlinks permitidos, exclusión de controladores globales y rutas implícitas al `MASTER_OUTPUT_ID`). Todos los tests (`ctest`) se han ejecutado tras la modificación y siguen pasando.

- Se ha reforzado la interacción con el módulo master invisible (`Output`, id lógico `MASTER_OUTPUT_ID`) para que funcione de forma coherente tanto al cargar sesiones como durante la sesión en vivo:
  - En el bucle de colisiones entre módulos de [core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L620-L700) se siguen excluyendo explícitamente los objetos cuya `logical_id()` es `MASTER_OUTPUT_ID` a la hora de considerar **pares módulo↔módulo**, de modo que los choques físicos entre un tangible y el master no se tratan como colisión entre dos módulos visibles.
  - A continuación, en el mismo bloque, se introduce una segunda pasada que detecta choques entre cada módulo dentro del área musical y el **centro geométrico de la mesa** (usando `bounds.getCentre()` y el mismo radio virtual `collisionRadius` que para los nodos). Cuando la distancia entre el centro de un módulo y el centro de la mesa es menor que el umbral de colisión, se considera un “choque módulo↔centro” y se llama a `toggleHardlinkBetweenObjects(objId, masterObjectId)` usando el `ObjectInstance` asociado al `MASTER_OUTPUT_ID`. Gracias a esto, al "empujar" un módulo contra el centro de la mesa se puede crear/eliminar un hardlink módulo→master en tiempo real:
    - Si el módulo tenía ya una conexión dinámica auto-wired a `MASTER_OUTPUT_ID`, la primera colisión la promueve a hardlink (recreando la conexión con `is_hardlink = true`).
    - Si venía de un `<hardlink to="-1" />` cargado desde el `.rtp`, la primera colisión elimina el hardlink (sin crear una conexión dinámica nueva), y la siguiente colisión vuelve a crearlo.
    - En todos los casos se reutiliza el mecanismo de `activeHardlinkCollisions_` y `makeObjectPairKey` para debouncing, de manera que mientras el módulo permanezca pegado al centro de la mesa no se producen toggles adicionales.
  - El test de carga de hardlinks desde RTP en [tests/scene_tests.cpp](tests/scene_tests.cpp#L340-L390) se ha reforzado para comprobar que, tras cargar un patch con `<hardlink to="-1" />` para `Delay(10)`, cualquier intento posterior de insertar otra conexión `10:out -> -1:in` (tanto marcada como hardlink como dinámica) mediante `Scene::AddConnection` es rechazado. Esto blinda la invariante de “una única conexión entre el mismo par de módulos y puertos” también en el caso especial del master, y garantiza que el toggle por colisión centro↔módulo siempre actúa sobre una única conexión Delay→-1 (alternando entre presente/ausente o dinámica/hardlink según el caso) en lugar de crear duplicados.

### Hardlinks desde sesiones RTP con mute por conexión y sin duplicados dinámicos
- Se ha extendido el modelo de dominio `rectai::Connection` en [core/src/core/Scene.h](core/src/core/Scene.h#L80-L115) para incluir un flag `muted` por conexión (`bool muted{false}`), manteniendo la semántica de igualdad basada únicamente en `from_module_id`, `from_port_name`, `to_module_id` y `to_port_name`. Esto permite representar en el modelo el estado de mute persistente de una conexión (por ejemplo, un hardlink muteado cargado desde una sesión Reactable) sin afectar a las reglas de unicidad de conexiones.
- `AudioGraph::Edge` en [core/src/core/AudioGraph.h](core/src/core/AudioGraph.h#L24-L40) ahora propaga también este flag (`Edge::muted`), y el rebuild del grafo en [core/src/core/AudioGraph.cpp](core/src/core/AudioGraph.cpp#L60-L80) copia el valor desde `Scene::Connection`. Aunque el motor de audio sigue utilizando `mutedConnections_` como capa de mute dinámica, esta información queda disponible para lógica y tooling futuros.
- El serializador de escenas de texto en [core/src/core/SceneSerialization.cpp](core/src/core/SceneSerialization.cpp#L32-L60) ahora emite la palabra clave opcional `muted` al final de cada línea `connection ...` cuando `connection.muted` es verdadero, además de la ya existente etiqueta `hardlink`. Esto facilita inspeccionar escenas serializadas y distinguir conexiones dinámicas, hardlinks y hardlinks muteados.
- El loader de patches Reactable (`LoadReactablePatchFromString`) se ha ajustado en [core/src/core/ReactableRtpLoader.cpp](core/src/core/ReactableRtpLoader.cpp#L286-L360 y core/src/core/ReactableRtpLoader.cpp#L920-L985) para:
  - Mantener una lista local `pending_hardlinks` con las hardlinks declaradas en los tangibles `Delay`: por cada `<hardlink to="..." muted="..." />` se guarda `{from_module_id, target_tangible_id, muted}` sin cambiar la API de `DelayModule` (los ids se siguen almacenando también en `DelayModule::hardlink_targets()` para compatibilidad).
  - Parsear el nuevo atributo opcional `muted="1"` en las etiquetas `<hardlink>` usando `ParseBool(hl_attrs, "muted", false)`; cuando el atributo falta, la conexión se considera no muteada (`muted=false`).
  - Derivar las `rectai::Connection` de estos `pending_hardlinks` al final del loader: por cada entrada se resuelve el `target_tangible_id` usando `tangible_to_module_id` y se crea una conexión `from_module_id -> target_module_id` con puertos estándar `"out" -> "in"`, marcada con `is_hardlink=true` y el flag `muted` correspondiente. Estas conexiones se insertan en la escena a través de `Scene::AddConnection`, que sigue aplicando las invariantes globales (no duplicar conexiones, máximo una salida dinámica, etc.).
- El bloque previo que reconstruía hardlinks recorriendo todos los `DelayModule` y sus `hardlink_targets()` se ha sustituido por este nuevo recorrido sobre `pending_hardlinks`, de manera que ahora el loader dispone de toda la información necesaria (id de tangible destino y estado de mute) en el momento de crear las conexiones del modelo.
- Dado que `Scene::Connection::operator==` y las comprobaciones de duplicados en `Scene::AddConnection` **no tienen en cuenta** ni `is_hardlink` ni `muted`, cualquier intento posterior de crear una conexión dinámica con los mismos extremos y puertos que un hardlink previamente insertado se considera duplicado y se rechaza. Esto garantiza la condición pedida: al cargar una sesión, primero se materializan las conexiones de hardlink y, a continuación, tanto el loader (auto-wiring a master y conexiones Oscillator→Filter) como el runtime dinámico de `MainComponent_Audio` respetan esas conexiones y **no crean segundas conexiones coincidentes**.
- En `MainComponent`, tras cargar una sesión RTP con `LoadReactablePatchFromFile`, se inicializa ahora el estado de mute por conexión de la UI en [core/src/MainComponent.cpp](core/src/MainComponent.cpp#L116-L146):
  - Se limpian las entradas previas de `mutedConnections_`.
  - Se recorre `scene_.connections()` y, para cada conexión con `conn.muted == true`, se genera la clave lógica con `rectai::ui::makeConnectionKey(conn)` y se inserta en `mutedConnections_`.
  De esta forma, un `<hardlink to="-1" muted="1" />` en el `.rtp` se traduce automáticamente en una conexión hardlink Delay→Output marcada como muteada tanto en el modelo como en la capa de interacción: la línea correspondiente aparece ya silenciada al cargar la sesión y las gesturas de hold/cut siguen actuando sobre el mismo `connection_key`.
- Los tests de dominio en [tests/scene_tests.cpp](tests/scene_tests.cpp#L340-L390) se han ampliado para cubrir este comportamiento:
  - El test original de "Hardlink-based connection creation" comprueba ahora además que, en ausencia de atributo `muted` en `<hardlink>`, la conexión resultante desde `Delay(10)` a `Output(-1)` tiene `c.muted == false`.
  - Se ha añadido un nuevo bloque de prueba que carga un patch embebido con `<hardlink to="-1" muted="1" />` y verifica que la única conexión creada es un hardlink con `c.is_hardlink == true` y `c.muted == true`. Esto asegura que el parser de `<hardlink>` reconoce correctamente el atributo `muted` y lo propaga al modelo.
- Con estas modificaciones, los hardlinks declarados en sesiones Reactable (por ejemplo, el `Delay` id="10" con `<hardlink to="-1" />` de `Loopdemo.rtp`) se cargan como conexiones únicas Delay→Output, marcadas como hardlinks, y pueden opcionalmente empezar muteadas. La lógica dinámica de conexiones de `MainComponent_Audio` (tanto auto-wiring como conexiones geométricas) respeta estas conexiones existentes al consultar `Scene::connections()` y `Scene::AddConnection`, por lo que ya no se generan rutas duplicadas hacia el master que impidan mutear correctamente la línea. Los tests (`ctest`) se han ejecutado tras el cambio y siguen pasando.

- Se ha corregido un caso específico de interacción al cortar líneas cerca de módulos con hardlink al master (por ejemplo, `Delay -> -1`):
  - Durante el gesto de corte, el segmento entre módulo y master se representaba tanto como línea objeto→centro (radial implícita) como como conexión explícita módulo→Output(-1). El trazado podía cruzar ambas geometrías a la vez.
  - En `mouseUp`, el código de corte de radiales (`touchCutObjects_`) y el de conexiones (`touchCutConnections_`) aplicaban sendos toggles sobre la misma ruta lógica módulo→master. El primero muteba la conexión, pero el segundo la volvía a desmutear inmediatamente, dejando el audio sin cambios aunque las dos líneas se iluminaran en amarillo.
  - Ahora, en la detección de intersecciones de "conexiones módulo a módulo" en [core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L1120-L1185), se omiten explícitamente las conexiones cuyo destino es el Output invisible (`to_module_id == MASTER_OUTPUT_ID`). Es decir, los cortes sobre la ruta hacia el master se modelan sólo a través de la radial objeto→centro, evitando el doble toggle sobre el mismo `connection_key`.
  - Resultado: al cortar la línea del Delay hacia el centro de la mesa, se mutea correctamente la ruta Delay→-1 (y por extensión su radial). El comportamiento cumple los requisitos: el Output lógico `-1` sigue sin representarse como módulo visible, sólo como bola central blanca, y es posible definir hardlinks explícitos hacia `-1` y silenciarlos mediante gestos de corte/hold.

### Caché de fondo estático de la mesa en rectai-core
- En la UI principal (`MainComponent`) se ha añadido una caché de imagen (`juce::Image tableBackgroundCache_`) para el fondo estático de la mesa (fondo negro, disco central azul/rojo y anillo de gradiente que se funde con el negro). Este fondo se renderiza ahora en un buffer off-screen únicamente cuando cambian el tamaño del componente o el color de la mesa, reutilizándose en todos los repaints posteriores mediante un simple `drawImageAt` en `paint()`.
- Para soportar esta caché se han introducido dos helpers privados en `MainComponent`:
  - `invalidateTableBackground()`, que marca la caché como sucia (se llama en el constructor y en `resized()`), y
  - `renderTableBackgroundIfNeeded(const juce::Rectangle<int>& bounds)`, que recrea la imagen si el tamaño ha cambiado o la caché está marcada como sucia y dibuja en ella el mismo fondo que antes se generaba directamente en `paint()` (incluyendo gradiente y disco sólido).
- El bloque de pintado del fondo en `MainComponent_Paint.cpp` se ha sustituido por una llamada a `renderTableBackgroundIfNeeded()` seguida de un blit de `tableBackgroundCache_`. El resto de la lógica de `paint` (waveforms, conexiones, pulsos, dock, etc.) permanece inalterada. Este cambio reduce sensiblemente el trabajo por frame en reposo, ya que las rutas calientes de JUCE (`EdgeTable`, `PixelARGB::set/getNativeARGB`, gradientes radiales) dejan de ejecutarse a 240 Hz y solo se recalculan cuando la geometría de la mesa cambia.

### Caché de iconos del atlas para módulos y dock
- Se ha añadido en `MainComponent` una caché de iconos del atlas (`atlasIconCache_`) que almacena imágenes `juce::Image` en formato `SingleChannel` ya reescaladas por sprite y tamaño de destino. La clave de caché combina el identificador lógico del icono (`icon_id()` de cada módulo) con las dimensiones enteras de destino (`"iconId#WxH"`), de modo que cada combinación sprite+tamaño se re-muestrea una sola vez desde el atlas original de 2048×2048 píxeles.
- El método privado `getCachedAtlasIcon(const std::string& iconId, int destWidth, int destHeight)` encapsula esta lógica: valida que el atlas está cargado, localiza el `AtlasSprite` correspondiente y, si aún no existe una entrada válida en `atlasIconCache_`, crea una nueva imagen `SingleChannel` del tamaño solicitado y copia en ella la máscara alfa del sprite usando `Graphics::drawImage`. El resultado se guarda en la caché y se devuelve como `juce::Image` (compartido por referencia), listo para ser tintado en `paint()` mediante `setColour`.
- En `MainComponent_Atlas.cpp`, todas las rutas de carga y fallo de `loadAtlasResources()` se han actualizado para limpiar `atlasIconCache_` junto con `atlasImage_` y `atlasSprites_`, garantizando que al recargar el atlas (o si falla la carga) no queden iconos desincronizados con la imagen de origen.
- En `MainComponent_Paint.cpp`, el pintado de iconos dentro del cuerpo de los nodos de la mesa se ha modificado para que, cuando exista `icon_id()` y sprite en el atlas, se utilice preferentemente la imagen preescalada de `getCachedAtlasIcon`. Una vez calculados los bounds destino (`destX/destY/destW/destH`) a partir de `iconBounds`, se obtiene la imagen cacheada y se dibuja con `drawImageAt` tras fijar el tinte dinámico según el brillo del `bodyColour`. Si el icono corresponde a un `TempoModule`, se mantiene el comportamiento de rotar la imagen alrededor del centro del nodo mediante `AffineTransform::rotation`, pero ahora aplicando la transformación a la imagen pequeña ya escalada en lugar de al atlas completo. Si por cualquier motivo la caché no devuelve una imagen válida, se conserva como fallback el `drawImage` directo desde `atlasImage_` recortando el rectángulo del sprite.
- El bloque de pintado de iconos del dock (tira derecha) se ha adaptado de forma análoga: para cada módulo presente en el dock se calcula `iconBounds` y, en lugar de reescalar cada frame el rectángulo del sprite desde `atlasImage_`, se intenta reutilizar una imagen preescalada desde `getCachedAtlasIcon`. Cuando ésta es válida, el icono se dibuja con `drawImageAt` usando la misma lógica de tinte por brillo de fondo; sólo en el caso de que la caché no tenga aún esa entrada se recurre al `drawImage` sobre el atlas grande. Como la geometría del dock (radio de nodo y, por tanto, tamaño de icono) es prácticamente estable, cada icono del dock se calcula una sola vez y se reutiliza en todos los repaints.
- Esta caché reduce de forma apreciable el trabajo de píxel que antes se hacía en caliente: en lugar de re-samplear el atlas de 2048×2048 para cada icono visible en mesa y dock en cada frame, la reescala se realiza únicamente la primera vez que se necesita un icono de un tamaño concreto; las repeticiones posteriores se limitan a blits de imágenes pequeñas en `SingleChannel` con tinte, que son mucho más baratas que las combinaciones de recorte+escalado+mezcla sobre el atlas completo observadas como hotspots (`PixelARGB::blend`, `ImageFill::copyRow`, etc.) en los perfiles de Callgrind.

### Manejo de ratón sin repaints extra (mouseMove/mouseWheelMove)
- Se ha añadido un override explícito de `mouseMove` en `MainComponent` que delega directamente en `juce::Component::mouseMove` y **no llama a `repaint()`**. Esto garantiza que los eventos de hover puro (movimiento de ratón sin botones pulsados) no añaden repaints adicionales a los ya generados por el timer de 240 Hz ni por los gestos de drag/click, acotando el coste de CPU de “mover el ratón por encima de la mesa” cuando no hay interacción activa.
- En `mouseWheelMove`, el bloque de scroll del dock derecho se ha ajustado para que sólo dispare un `repaint()` cuando `dockScrollOffset_` cambia realmente. Antes se recalculaba el offset y se repintaba incluso cuando el contenido ya estaba en el límite superior/inferior y el `jlimit` devolvía el mismo valor, lo que hacía que al insistir con la rueda en los extremos se generasen frames de más sin cambio visual. Ahora se compara `previousOffset` con el nuevo valor y sólo en caso de diferencia se solicita repintado.
- Los usos de la rueda sobre módulos Tempo y Loop ya estaban condicionados a cambios efectivos (por ejemplo, en Tempo no se repinta si el nuevo BPM es igual al actual), por lo que no se han tocado. Con estos ajustes, la combinación de hover + wheel sobre zonas sin cambios reales deja de provocar repaints innecesarios, reduciendo picos de CPU asociados a eventos de entrada que no alteran el estado visual.
### Mute-on-hold coherente para Loop, Sampleplay y Oscillator
- Se ha extendido la lógica de **mute temporal al mantener pulsado sobre una línea de audio (mute on hold)** para que afecte de forma coherente a todos los módulos que generan sonido, no sólo a `Oscillator`. Hasta ahora, al mantener el ratón sobre la radial de un módulo `Loop`, la línea se partía visualmente pero el audio del loop seguía sonando; con este cambio, la salida de audio también queda silenciada mientras dura el gesto.
- En `MainComponent_Audio.cpp` se ha añadido un chequeo explícito de `activeConnectionHold_` en dos puntos:
  - Para el camino global de `Sampleplay` (ganancia `sampleplayOutputGain`): si el hold está activo sobre la radial del módulo Sampleplay o sobre una de sus conexiones de audio (según `connection_key` de `activeConnectionHold_` y la lista de `audioEdges`), se fuerza `sampleplayOutputGain = 0.0F` mientras dure el gesto, independientemente del estado de mute persistente de las conexiones. Esto hace que el sonido de SoundFont se detenga de forma inmediata al mantener pulsado sobre la línea, igual que ocurre con los generadores procedurales.
  - Para cada módulo `Loop`: dentro del bucle que configura `setLoopModuleParams`, se calcula `isHeldForLoop` combinando el id de objeto (`object_id` de `activeConnectionHold_`) y la clave de conexión retenida (`connection_key`). Cuando `isHeldForLoop` es verdadero, el `loopGain` calculado a partir del parámetro `amp` y del volumen global se fuerza a `0.0F` antes de llamar a `setLoopModuleParams`. De este modo, los loops siguen avanzando internamente en fase (según el contador global de beats), pero su contribución a la mezcla pasa a ser silencio durante el hold.
- En `MainComponent_Paint.cpp` se ha generalizado el pintado de la radial en estado de hold para que la **primera mitad de la línea (módulo → punto de split)** muestre una waveform representativa del tipo de módulo, tal y como ocurre ya en el estado normal:
  - Para módulos `Sampleplay`, se resuelve la conexión lógica `Sampleplay → Output(-1)` y se usa `audioEngine_.getConnectionWaveformSnapshot` sobre esa clave para obtener la waveform que se dibuja desde el módulo hasta el punto de split. De este modo, al hacer mute-on-hold sobre la radial de Sampleplay se sigue viendo la forma de onda recortada hasta el punto exacto donde se ha hecho clic.
  - Para módulos `Loop`, se llama directamente a `audioEngine_.getLoopModuleWaveformSnapshot` con el id lógico del módulo, normalizando la señal y dibujando la waveform del loop unicamente en el tramo módulo → split. La amplitud visual se escala con el mismo `visualLevel` y el mismo grosor de línea usado en el modo normal, de forma que la mitad activa conserva exactamente el aspecto habitual de la radial de Loop.
  - Para el resto de generadores procedurales (Oscillator y similares) se mantiene la rama existente que usa los buffers `voiceWaveformsPost` y `voiceRmsPost` por voz. Si no hay waveform disponible para el módulo en cuestión, se cae a un fallback de línea blanca recta entre el módulo y el punto de split.
- En todos los casos, la **segunda mitad de la línea (split → centro)** se sigue dibujando como un segmento discontinuo (línea discontinua blanca semitransparente), indicando claramente que la salida hacia el master está temporalmente silenciada. La combinación de waveform parcial + tramo punteado da como resultado una UX consistente: el usuario ve hasta dónde llega la señal antes del corte y percibe visualmente que, a partir de ahí, el audio está siendo bloqueado.
- Los tests (`ctest`) se han ejecutado tras los cambios y siguen pasando, lo que confirma que la integración del estado de hold en el runtime de audio (Loop/Sampleplay) y en la capa de pintado no rompe el resto de rutas de audio ni la serialización de la escena.

### Hitbox circular invisible para interacción con el módulo (evitar colisiones con barras laterales)
- En `MainComponent_Input.cpp` se ha ajustado el hit-test de ratón para los módulos de la mesa de forma que exista un **círculo invisible de interacción** que coincide con el cuerpo circular del módulo (`nodeRadius = 26.0F`). Este círculo se utiliza para decidir si un click debe interpretarse como interacción directa con el módulo (por ejemplo, arrastrar para mover el tangible) o con los controles laterales.
- Dentro de `mouseDown`, justo antes de evaluar las barras laterales de Freq y Gain, se calcula para cada objeto la distancia del click (transformado a espacio local cuando el módulo está dentro del área musical) al centro del nodo. Si el punto de click cae dentro del radio del círculo del módulo (`insideModuleCircle`), las lambdas de hit-test de las barras laterales siguen funcionando pero sus resultados sólo se consideran válidos cuando `!insideModuleCircle`.
- En la práctica, esto significa que clicks realizados claramente "dentro" del círculo del módulo ya **no activan las barras laterales** aunque sus rectángulos de hit se solapen parcialmente con esa zona; en su lugar, esos clicks pasan al bloque posterior de selección de objeto, que marca `draggedObjectId_` y permite arrastrar el módulo como hasta ahora.
- La geometría de las barras laterales (izquierda Freq, derecha Gain) y su área de interacción permanece intacta hacia el exterior del nodo, por lo que el usuario sigue pudiendo hacer click y arrastrar sobre los arcos laterales cuando apunta a la zona que rodea al módulo. El cambio únicamente reserva el área del cuerpo circular para la interacción principal con el tangible, evitando la sensación de estar colisionando con los controles de volumen/frecuencia cuando se hace click aparentemente en el centro del módulo.

-### Selector de modos de módulo (botón inferior + menú radial interactivo)
- Se ha introducido un descriptor genérico de modos de ajuste `AudioModuleMode` y una pequeña API de modos en `rectai::AudioModule` en [core/src/core/Scene.h](core/src/core/Scene.h#L80-L190) y [core/src/core/Scene.cpp](core/src/core/Scene.cpp#L90-L150). Cada módulo puede exponer ahora una lista ordenada de modos soportados (`supported_modes()` devuelve un `AudioModuleModes`), donde cada modo incluye un id numérico estable (`id`), un identificador lógico corto (`type`, por ejemplo "sine"/"lowpass") y el `icon_id` del atlas. La UI dispone de un índice de modo activo (`current_mode_index()` y `set_mode(int)`) y helpers genéricos de ciclo (`cycle_mode_forward`/`cycle_mode_backward`) que permiten cambiar de modo sin conocer la implementación interna del módulo. Además, la implementación por defecto de `on_mode_changed(int, const AudioModuleMode&)` en `AudioModule` ahora sincroniza automáticamente el `icon_id` visual del módulo con el `icon_id` del modo seleccionado, de forma que cualquier módulo que sólo defina `supported_modes()` pero no sobreescriba `on_mode_changed` obtiene gratis el cambio de icono al cambiar de modo.
-### Selector de modos de módulo (botón inferior + menú radial interactivo)
- Se ha introducido un descriptor genérico de modos de ajuste `AudioModuleMode` y una pequeña API de modos en `rectai::AudioModule` en [core/src/core/Scene.h](core/src/core/Scene.h#L80-L190) y [core/src/core/Scene.cpp](core/src/core/Scene.cpp#L90-L150). Cada módulo puede exponer ahora una lista ordenada de modos soportados (`supported_modes()` devuelve un `AudioModuleModes`), donde cada modo incluye un id numérico estable (`id`), un identificador lógico corto (`type`, por ejemplo "sine"/"lowpass") y el `icon_id` del atlas. La UI dispone de un índice de modo activo (`current_mode_index()` y `set_mode(int)`) y helpers genéricos de ciclo (`cycle_mode_forward`/`cycle_mode_backward`) que permiten cambiar de modo sin conocer la implementación interna del módulo. Además, la implementación por defecto de `on_mode_changed(int, const AudioModuleMode&)` en `AudioModule` ahora sincroniza automáticamente el `icon_id` visual del módulo con el `icon_id` del modo seleccionado, de forma que cualquier módulo que sólo defina `supported_modes()` pero no sobreescriba `on_mode_changed` obtiene gratis el cambio de icono al cambiar de modo. Para los módulos que sí sobreescriben `on_mode_changed` (como `OscillatorModule` y `FilterModule`), la implementación concreta delega en la base (`AudioModule::on_mode_changed`) para reutilizar este comportamiento de icono por defecto.

- Internamente, `AudioModule` inicializa ahora su índice de modo a `-1` en lugar de `0` ([core/src/core/Scene.h](core/src/core/Scene.h#L230-L270)). Esto garantiza que la **primera** llamada a `set_mode(0)` (o `set_mode("sine")` en el constructor de `OscillatorModule`) no se trate como un no-op y siempre dispare `on_mode_changed`, fijando el icono inicial al del modo por defecto (`oscillator_sine` en el caso del Oscillator). Los módulos sin modos siguen devolviendo `-1` en `current_mode_index()`.

- Se ha añadido también un helper de conveniencia `current_mode()` en `AudioModule` ([core/src/core/Scene.h](core/src/core/Scene.h#L150-L190), [core/src/core/Scene.cpp](core/src/core/Scene.cpp#L110-L140)) que devuelve un puntero al `AudioModuleMode` activo (o `nullptr` si el módulo no expone modos o el índice es inválido). Esto simplifica el código de consumidores como `MainComponent_Audio`, que puede consultar directamente `current_mode()->id` para derivar el tipo de filtro o forma de onda sin volver a indexar sobre `supported_modes()`.
- Los módulos `Oscillator` y `Filter` implementan esta API de modos en [core/src/core/AudioModules.h](core/src/core/AudioModules.h#L90-L210) y [core/src/core/AudioModules.cpp](core/src/core/AudioModules.cpp#L60-L240): el Oscillator expone cuatro modos (`sine`, `saw`, `square`, `noise`) cuyos `icon_id` coinciden con los que ya usaba el módulo y mapean 1:1 con el enum `Waveform`, mientras que el Filter expone tres modos (`filter_lowpass`, `filter_bandpass`, `filter_hipass`) alineados con su enum interno `Mode`. En ambos casos `current_mode_index()` refleja el estado actual del módulo y `set_mode(int)` valida el índice y delega en los setters existentes (`set_waveform`, `set_mode`).
- Se han añadido aserciones de dominio en [tests/scene_tests.cpp](tests/scene_tests.cpp#L1-L260) que verifican el tamaño y contenido de `supported_modes()` para Oscillator y Filter, el valor inicial de `current_mode_index()` y el comportamiento ante cambios de modo tanto vía `cycle_waveform`/`cycle_mode` como vía `set_mode(int)`, incluyendo el tratamiento de índices fuera de rango (no cambian el modo actual).
- En la UI principal, cada módulo que expone modos soportados dibuja ahora un **botón de ajuste** en la ranura inferior entre las barras laterales Freq/Gain. Este botón se pinta en [core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L2130-L2185) como un pequeño rectángulo redondeado bajo el círculo del módulo que siempre muestra el `icon_id` principal del módulo (reutilizando la caché del atlas) y actúa como ancla del menú radial de modos.
- El controlador de entrada se ha ampliado en [core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L560-L640 y core/src/MainComponent_Input.cpp#L1180-L1280) con nuevo estado por-módulo (`modeControlObjectId_`, `modeDragStartLocal_`, `modeSelection_`) que detecta clicks sobre el botón inferior y gestos de arrastre hacia la izquierda en el espacio local del módulo (teniendo en cuenta su rotación en la mesa). Cuando el usuario arrastra suficientemente hacia el lado izquierdo local, se marca `modeSelection_.menuVisible = true` para ese módulo y se fuerza un repintado.
- Cuando el menú de modos está visible, `MainComponent::paint` dibuja una superposición semitransparente sobre las barras laterales para atenuarlas y, a continuación, un **anillo de iconos** con un sprite por cada modo soportado, distribuidos desde la parte inferior del nodo hasta el lado izquierdo local, en [core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L2185-L2245). El modo activo se resalta con un tamaño ligeramente mayor y mayor opacidad, reutilizando `supported_modes()[i].icon_id` y `current_mode_index()` para decidir icono y énfasis.
- Finalmente, el manejador de `handlePointerUp` se ha hecho interactivo para este menú radial en [core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L1537-L1815): se mantiene la última posición conocida del puntero en `lastPointerPosition_` y, si al soltar el botón el menú radial sigue visible para un módulo dado, se replica la misma geometría usada en el pintado (centro del módulo, radio del anillo, ángulos entre 270° y 180° y escalado del icono activo) pero en coordenadas locales del módulo. Si la posición de liberación cae dentro del radio de hit de alguno de los iconos, se llama a `set_mode(i)` sobre el `AudioModule` correspondiente, actualizando inmediatamente tanto el `icon_id` central como el resaltado del menú en el siguiente frame. El menú se cierra al finalizar el gesto, manteniendo la relación 1:1 entre selección visual y modo lógico del módulo.

### Ajuste geométrico del selector de modos (alineación con semicírculo Freq)
- Se ha afinado la geometría del menú de modos para que los iconos sigan con mayor precisión el semicírculo de la barra de Freq y el icono inferior quede razonablemente alineado con el botón de modo, desplazando además la columna completa 7 px hacia la izquierda (`extraLeft = 7.0f`) para despegar visualmente los iconos de la barra de Freq. En el pintado ([core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L2170-L2335)) se mantienen los ángulos derivados de `sliderTop/sliderBottom` pero se aplica ahora una ligera compresión del arco por la parte superior (`angleTop = angleBottom + (angleTop - angleBottom) * 0.85f`) para que los iconos altos no se salgan de la curva de Freq.
- La lógica de hit-test en `handlePointerUp` se ha actualizado para reutilizar exactamente la misma geometría angular que el pintado (misma compresión y mismos ángulos inferior/superior) y se ha reducido de 5 a 4 el número de “slots virtuales” (`maxSlots = 4`) tanto en pintado como en input ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L1840-L1995)). Esto aumenta ligeramente la separación vertical entre iconos (al repartir 3–4 iconos sobre un arco algo más corto) y mantiene las zonas clicables alineadas con la curva visible.

### Doble control de volumen en Oscillator: bola blanca (módulo) y bola gris (Sequencer)
- Se ha ajustado la interacción entre el `Sequencer` y los módulos `Oscillator` para que los mensajes de control de volumen (velocidad de nota) ya **no modifiquen directamente** el parámetro `gain` del Oscillator, que corresponde a la **bola blanca** en la barra lateral derecha y representa el volumen de salida del módulo fijado por el usuario.
- En `MainComponent` se introduce un mapa `oscillatorSequencerGain_` que almacena, por id de módulo, un factor de ganancia normalizado en `[0,1]` controlado exclusivamente por el `Sequencer` cuando `sequencerControlsVolume_` es `true`. Este factor se actualiza en `MainComponent_Audio::timerCallback`, dentro de `runSequencerStep`:
  - Cuando un paso activo del Sequencer dispara un Oscillator, se toma `step.velocity01` como valor de volumen del paso, se clampa a `[0,1]` y se guarda en `oscillatorSequencerGain_[oscId]`.
  - Cuando un paso está desactivado y el Sequencer está autorizado a controlar volumen, en lugar de forzar `gain = 0` sobre el módulo, se fija `oscillatorSequencerGain_[oscId] = 0.0F`, dejando intacto el valor de `gain` elegido por el usuario.
- La mezcla de audio de generadores en `MainComponent_Audio.cpp` se ha actualizado para que el nivel efectivo de cada cadena cuyo origen es un `OscillatorModule` se base en **dos componentes**:
  - `userGainParam`: el parámetro `gain` del módulo (bola blanca), leído y clampeado a `[0,1]`.
  - `seqGain`: el factor de ganancia controlado por el Sequencer, leído de `oscillatorSequencerGain_` cuando existe o asumido como `1.0F` en ausencia de modulaciones.
  El `gainParam` que alimenta el cálculo de `calculatedLevel` se define ahora como `min(userGainParam, seqGain)` cuando el módulo es un Oscillator y `sequencerControlsVolume_` está activo. De esta forma, el Sequencer **puede reducir el volumen** efectivo de una cadena de Oscillator pero **nunca aumentarlo** por encima del valor fijado en la bola blanca.
- Visualmente, la barra de volumen lateral derecha en `MainComponent_Paint.cpp` se ha extendido para representar **ambos niveles**:
  - La bola blanca sigue representando el valor del parámetro `gain` del módulo (controlado por clic/drag del usuario) y mantiene el mismo comportamiento de siempre.
  - Para módulos `OscillatorModule` y sólo cuando `sequencerControlsVolume_` es `true`, se dibuja una **segunda bola gris** en la misma barra, cuyo valor vertical corresponde al `seqGain` del mapa `oscillatorSequencerGain_`, clampeado con `cappedSeq = min(gainValue, seqGain)`.
  - La bola gris sólo se muestra cuando el Sequencer está intentando **bajar el volumen** respecto al nivel del módulo (es decir, cuando `cappedSeq < gainValue`), de modo que visualmente actúa como un “segundo cursor” que se mueve por debajo de la bola blanca siguiendo los pasos del Sequencer.
- La bola gris es puramente informativa y **no es interactiva**: la lógica de input en `MainComponent_Input.cpp` no se ha modificado y sigue utilizando únicamente la barra de `gain` como región clicable, mapeando los clics y drags al parámetro `gain` del módulo (bola blanca). Cualquier interacción del usuario con la barra sigue afectando exclusivamente a la bola blanca; la bola gris se limita a reflejar, en la misma barra, el volumen instantáneo que el Sequencer está imponiendo a ese Oscillator.
- A nivel de sonido, el resultado es que:
  - El volumen audible de un Oscillator conectado a un Sequencer está gobernado por la combinación `min(gain_módulo, factor_Sequencer)`.
  - El usuario ve siempre el volumen máximo permitido para ese módulo (bola blanca) y, cuando el Sequencer atenúa la señal, observa la bola gris moverse por debajo hasta donde llegue el paso actual, sin que ésta pueda **superar** nunca la altura de la bola blanca.

### Actualización incremental de inside_music_area en cada tick
- La función `MainComponent::refreshInsideMusicAreaFlags` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L40-L70)) se ejecuta en cada tick del timer para mantener sincronizado el flag `inside_music_area_` de cada `ObjectInstance` con la geometría actual de la mesa (coordenadas normalizadas en el disco de radio 1). Hasta ahora, el código tomaba un snapshot de `scene_.objects()`, recalculaba `computeInsideMusicArea` para cada objeto, asignaba el nuevo valor y llamaba a `scene_.UpsertObject(updated)` incondicionalmente en todos los casos.
- Para reducir trabajo innecesario en escenas estables (por ejemplo, módulos que permanecen docked o inmóviles durante largos periodos), se ha introducido una comprobación previa antes de hacer el upsert: se calcula `inside = computeInsideMusicArea(obj)` a partir del snapshot y, si `inside` coincide con el valor almacenado actualmente en `obj.inside_music_area()`, se omite cualquier actualización sobre la `Scene` para ese objeto.
- Sólo cuando el valor recién calculado difiere del flag almacenado (por ejemplo, cuando un módulo cruza por primera vez el borde del disco musical, deja de estar docked o se ha añadido nuevo dentro del área), se crea una copia `updated` del objeto, se llama a `updated.set_inside_music_area(inside)` y se invoca `scene_.UpsertObject(updated)`. Esto mantiene intacta la semántica original (el modelo siempre refleja correctamente qué objetos están dentro del área musical), pero evita tráfico de upserts redundantes en ticks donde la posición y el estado de dock de los objetos no han cambiado.
- Este cambio ayuda a rebajar el coste per-tick de la fase de “sincronización de flags de área musical”, especialmente en patches con muchos objetos estáticos, sin introducir nuevas estructuras de caché: se reutiliza el propio `inside_music_area_` como referencia de estado previo y se conserva el patrón de snapshot para no invalidar el iterador mientras se modifican objetos en la `Scene`.

### Desacoplo de frecuencia de timer y de repaints de UI
- El `MainComponent` usa un `Timer` para sincronizar la lógica de audio/UI con el transporte global. Tras los ajustes al Sequencer y al gating de audio, el timer se ejecuta a 240 Hz (`startTimerHz(240)`) para reducir el jitter en el disparo de pasos: `timerCallback` consulta `audioEngine_.transportBeats()`, avanza `sequencerAudioStepCounter_` y ejecuta todos los pasos intermedios necesarios para mantener el ritmo alineado con el hilo de audio.
- En versiones anteriores, cada `timerCallback` terminaba inevitablemente en un `repaint()`, lo que implicaba entrar en la ruta completa de `MainComponent::paint` hasta 240 veces por segundo. Dado que los perfiles de Callgrind mostraban que el coste dominante de CPU está en las funciones de rasterizado software de JUCE (`EdgeTableFillers::ImageFill::copyRow`, `EdgeTableFillers::SolidColour::handleEdgeTableRectangle`, `PixelARGB::blend/set`), este acoplamiento timer=repaint generaba una gran carga incluso en escenas con poca actividad visual.
- Para aliviar este cuello de botella sin empeorar la precisión temporal del Sequencer, se ha introducido un timestamp independiente `lastRepaintSeconds_` en `MainComponent` ([core/src/MainComponent.h](core/src/MainComponent.h#L120-L150)) inicializado junto con `lastTimerSeconds_` en el constructor ([core/src/MainComponent.cpp](core/src/MainComponent.cpp#L600-L640)).
- Al final de `MainComponent::timerCallback` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L2440-L2625)) ya no se llama siempre a `repaint()`. En su lugar, se calcula un intervalo mínimo entre repaints `minRepaintInterval = 1.0 / kMaxRepaintsPerSecond` con `kMaxRepaintsPerSecond = 120.0` y sólo se dispara `repaint()` cuando `nowSeconds - lastRepaintSeconds_ >= minRepaintInterval`. Tras cada repaint efectivo, `lastRepaintSeconds_` se actualiza al valor actual de `nowSeconds`.
- Con este cambio, la lógica de audio y de Sequencer (incluida la generación de pulsos BPM y el avance de steps de audio) sigue corriendo a 240 Hz, pero el pipeline de pintura de JUCE se ejecuta, como máximo, a ~120 fps. Para el usuario, las animaciones de waveforms y widgets siguen siendo fluidas, pero el número de veces que se invocan las funciones más costosas de JUCE por segundo (copias de imágenes grandes, rellenos de rectángulos con EdgeTable, mezclas de píxeles) se reduce aproximadamente a la mitad.

#### Ajustes adicionales de repintado y opacidad en MainComponent
- A partir de nuevos perfiles con Callgrind cargando la sesión `android_theme.rtp`, se ha constatado que, incluso con el gating de audio y el límite de repaints, una parte muy significativa de las instrucciones sigue concentrándose en las rutas software de JUCE asociadas a `PixelARGB::blend/set` y a los rellenos de paths (círculos de módulos, disco central y conexiones). Para seguir reduciendo la carga de CPU sin alterar la semántica del modelo de audio, se han aplicado dos optimizaciones adicionales en `MainComponent`:
  - En el constructor de `MainComponent` ([core/src/MainComponent.cpp](core/src/MainComponent.cpp#L90-L140)) se llama ahora explícitamente a `setOpaque(true)`. Dado que el componente cubre siempre todo su `getLocalBounds()` con un fondo totalmente opaco (negro + disco coloreado cacheado), esta indicación permite a JUCE omitir limpiezas y mezclas innecesarias con el contenido subyacente de la ventana al repintar, reduciendo trabajo por píxel en cada frame.
  - La caché de fondo de la mesa `tableBackgroundCache_` se crea ahora como imagen `juce::Image::RGB` sin canal alfa en lugar de `juce::Image::ARGB` transparente ([core/src/MainComponent.cpp](core/src/MainComponent.cpp#L20-L60)). Como el fondo se rellena por completo con negro sólido, disco de color y anillo de gradiente opacos, no se necesita información de transparencia y puede evitarse parte del coste de mezcla asociado a `PixelARGB` cuando se hace el `drawImageAt` en cada `paint`.
- Además, el límite de repintado máximo por segundo en `MainComponent_Audio::timerCallback` se mantiene en 60 fps (`kMaxRepaintsPerSecond = 60.0` en [core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L2520-L2620)), pero se ha añadido una compuerta simple de actividad visual: sólo se lanza `repaint()` cuando existe audio realmente activo (`!modulesWithActiveAudio_.empty()`), pulsos BPM en curso (`!pulses_.empty()`), una etiqueta de BPM aún visible (menos de 6 s desde `bpmLastChangeSeconds_`) o un gesto de hold/mute (`activeConnectionHold_`) en progreso. En estados completamente inactivos (sin audio ni animaciones ni interacción), el timer sigue ejecutando la lógica ligera de sincronía, pero deja de entrar en la ruta de pintura de JUCE, reduciendo de forma notable el consumo de CPU en reposo.
- Esta simple compuerta temporal sobre `repaint()` debería reflejarse en una caída directa del porcentaje de instrucciones atribuidas a `juce::RenderingHelpers::ImageFill::copyRow` y `EdgeTableFillers::SolidColour::handleEdgeTableRectangle` en nuevos perfiles de Callgrind, acercando la carga de CPU a los objetivos marcados (~<60% con foco en repaint) sin sacrificar la solidez temporal del transporte y del Sequencer.

##### Caché de fondo del dock derecho
- El dock derecho que agrupa los módulos `docked="1"` se dibujaba por completo en cada `paint`: panel de fondo (`fillRoundedRectangle` gris oscuro), contorno semitransparente, título "Dock" y, después, las burbujas e iconos de cada módulo. Aunque el área del dock es relativamente pequeña, el panel con esquinas redondeadas y texto suponía trabajo adicional de rasterizado y mezcla en cada frame.
- Para reducir este coste sin cambiar la apariencia, se ha introducido una **caché específica para el fondo del dock** en `MainComponent`:
  - Nuevos miembros `dockBackgroundCache_` y `dockBackgroundDirty_` en [core/src/MainComponent.h](core/src/MainComponent.h#L100-L140), paralelos a la caché de fondo de la mesa.
  - Nuevos helpers `invalidateDockBackground()` y `renderDockBackgroundIfNeeded(const juce::Rectangle<int>& dockBounds)` en [core/src/MainComponent.h](core/src/MainComponent.h#L270-L310) y su implementación en [core/src/MainComponent.cpp](core/src/MainComponent.cpp#L20-L80):
    - La función crea (cuando cambia el tamaño) una imagen `juce::Image::RGB` del tamaño exacto del área de dock y dibuja en ella el panel gris con esquinas redondeadas, su contorno blanco semitransparente y el texto estático "Dock" en la parte superior.
    - El resto del tiempo, `renderDockBackgroundIfNeeded` devuelve inmediatamente si el tamaño coincide y la caché no está sucia.
  - En `MainComponent::resized()` ([core/src/MainComponent.cpp](core/src/MainComponent.cpp#L520-L560)) se llama ahora también a `invalidateDockBackground()` junto con `invalidateTableBackground()` para asegurar que cualquier cambio de tamaño reprocesa ambos fondos en la siguiente pintura.
- En el bloque de pintado del dock en [core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L2388-L2445), se ha sustituido el dibujo directo del panel por un blit de la caché:
  - Antes: para cada `paint`, se calculaba `dockArea`, se llamaba a `fillRoundedRectangle + drawRoundedRectangle` y se pintaba el texto "Dock" sobre la marcha.
  - Ahora: se llama a `renderDockBackgroundIfNeeded(dockArea.toNearestInt())` y, si `dockBackgroundCache_` es válida, se hace un `drawImageAt` de la imagen cacheada en la posición `dockArea.getX()/getY()`. A continuación se recorta `dockArea.removeFromTop(titleHeight)` para que el layout de módulos reutilice exactamente el mismo espacio que antes.
- Las burbujas de cada módulo docked, sus iconos (ya optimizados con `atlasIconCache_`) y las etiquetas opcionales de BPM de Tempo se siguen dibujando cada frame como antes. La mejora se centra únicamente en el panel de fondo y el título estático, que pasan de ser paths y texto rasterizados en caliente a una imagen RGB opaca reutilizada, reduciendo unas cuantas llamadas a `PixelARGB::blend` y `EdgeTableFillers::SolidColour::handleEdgeTableRectangle` por frame cuando hay muchos repaints.

##### Gesto de corte más barato cuando la mesa está vacía
- En escenas donde no hay ningún módulo sobre el área musical (todos los tangibles están docked o fuera del círculo), hacer `mouseDown` y arrastrar sobre el fondo no aporta información visual útil, pero hasta ahora activaba igualmente el modo "cut" (cursor rojo + trail) y el pipeline completo de detección de intersecciones sobre radiales y conexiones en `mouseDrag`, generando repaints y trabajo extra aunque no hubiese líneas que cortar.
- En `MainComponent_Input::mouseDown` ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L860-L930)) se ha añadido una comprobación previa antes de activar `isCutModeActive_`:
  - Sólo se habilita el modo de corte si el punto inicial del gesto está dentro del círculo musical **y** existe al menos un `ObjectInstance` no docked con `inside_music_area == true` (es decir, al menos un módulo sobre la mesa).
  - Cuando el área musical está verdaderamente vacía, el gesto se sigue registrando como toque/touch (para el cursor blanco), pero no se entra en modo cut, de manera que los drags subsiguientes no intentan evaluar intersecciones con líneas inexistentes.
- En `MainComponent_Input::mouseDrag` ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L930-L1040)) se ha introducido además un early-return barato:
  - Al inicio del handler se calcula un flag `hasActiveGesture` que sólo es verdadero cuando hay realmente una interacción visual en curso: modo cut activo, scroll del dock, ajuste de barras laterales o drag de un módulo (`draggedObjectId_ != 0`).
  - Si `hasActiveGesture` es falso, la función retorna inmediatamente después de actualizar `isTouchHeld_` y `currentTouchPosition_`, evitando por completo la lógica de trail, búsqueda de intersecciones y llamadas a `repaint()` mientras el usuario simplemente arrastra el ratón sobre una mesa vacía.
- El registro de puntos de trail (`touchTrail_`) también se ha restringido a los casos en los que `isCutModeActive_` es verdadero; de este modo, los drags que sólo afectan a dock scroll, side controls o movimiento de módulos no acumulan puntos de trail innecesarios.
- En conjunto, estos cambios hacen que, con el área musical vacía, mover o incluso arrastrar el ratón sobre el fondo no dispare el pipeline de corte ni repaints adicionales: la carga de CPU en ese estado vuelve a estar dominada por el timer y las animaciones realmente visibles (por ejemplo, los pulsos BPM), sin picos extra debidos a interacción de ratón sin objetivos.
-
##### Helper de rate-limit de repaints compartido entre timer e input
- Para evitar que distintas fuentes de repintado (timer de 240 Hz, gestos de ratón, cambios en controles laterales o acciones sobre el dock) puedan forzar a `MainComponent` a repintar por encima de 60 fps, se ha extraído la lógica de limitación de repaints a un helper privado reutilizable: `MainComponent::repaintWithRateLimit()` en [core/src/MainComponent.cpp](core/src/MainComponent.cpp#L90-L120), declarado en [core/src/MainComponent.h](core/src/MainComponent.h#L280-L310).
- `repaintWithRateLimit()` calcula el tiempo actual con `juce::Time::getMillisecondCounterHiRes()`, impone un intervalo mínimo de `1.0 / 60.0` segundos entre repaints efectivos y sólo llama a `repaint()` cuando `nowSeconds - lastRepaintSeconds_ >= minRepaintInterval`, actualizando `lastRepaintSeconds_` tras cada repintado. De este modo, cualquier código que solicite un repaint a través de este helper queda automáticamente acotado a un máximo de 60 fps sin necesidad de duplicar lógica en cada llamada.
- En `MainComponent_Audio::timerCallback` ([core/src/MainComponent_Audio.cpp](core/src/MainComponent_Audio.cpp#L2600-L2625)) se ha sustituido el bloque inline que combinaba `hasVisualActivity` con el cálculo local de `kMaxRepaintsPerSecond` por una llamada a `repaintWithRateLimit()` cuando `hasVisualActivity` es verdadero. El timer sigue ejecutándose a 240 Hz y evaluando la lógica de audio/Sequencer en cada tick, pero los repaints de UI se agrupan de forma que nunca superen los 60 por segundo.
- En `MainComponent_Input.cpp` ([core/src/MainComponent_Input.cpp](core/src/MainComponent_Input.cpp#L200-L1200)) se han reemplazado varias llamadas directas a `repaint()` por `repaintWithRateLimit()`, incluyendo:
  - El `mouseDown` general sobre la mesa (activación de cursor blanco o rojo, selección de objeto/touch).
  - Los gestos sobre controles laterales (por ejemplo, arrastre de barras de Freq/Gain) que actualizan visualmente el estado del módulo.
  - El final de `mouseDrag`, que antes siempre terminaba en un `repaint()` para actualizar el cursor rojo y el trail de corte, y ahora delega en el helper compartido para que esos repaints no rompan el límite global de 60 fps.
- Estas llamadas conviven con el gating previo de `hasVisualActivity` en el timer, de forma que incluso en escenas con mucha interacción de ratón sobre una mesa compleja (muchos módulos y conexiones visibles), la tasa combinada de repaints de UI no supera el objetivo de 60 fps. Visualmente, el usuario sigue percibiendo animaciones y feedback de input fluidos, pero los perfiles de CPU muestran menos tiempo en las rutas de rasterizado software de JUCE al evitar ráfagas de repaints redundantes disparadas desde múltiples sitios.

### Optimización de waveforms en conexiones y radiales en `paint`
- A partir de un perfil de Callgrind sobre la app principal (`RectaiTable`) se confirmó que, tras introducir el gating de audio, la mayor parte de las instrucciones de CPU se concentran en el subsistema de gráficos de JUCE (`PixelARGB::blend`, `ImageFill::copyRow`, `SolidColour::replaceLine`, etc.) invocado desde `MainComponent::paint`. El coste dominante procede de la rasterización de paths complejos (radiales con waveform y conexiones módulo→módulo) más que del código de dominio en sí.
- En `MainComponent_Paint.cpp` ([core/src/MainComponent_Paint.cpp](core/src/MainComponent_Paint.cpp#L420-L1180)) se han aplicado varias optimizaciones específicas a la representación de **waveforms en conexiones y radiales** para reducir este coste sin alterar la semántica visual básica:
  - En las waveforms de **conexión continua** (`module → module`, tanto hardlink como dinámica) se ha eliminado la estimación de periodo por autocorrelación (`estimateWaveformPeriod`) a partir de los taps por conexión. Antes se llamaba a `estimateWaveformPeriod(tempWave, kWaveformPoints)` para cada conexión visible en cada `paint`, lo que añadía un coste O(N²) por conexión (N ≈ 512 muestras) además del propio stroke del path. Ahora estas conexiones utilizan simplemente `periodSamples = kWaveformPoints` con un número fijo moderado de segmentos (72) y `tiled = !involvesSampleplay`, de modo que se sigue repitiendo el buffer a lo largo de la línea sin necesidad de detectar su periodo exacto. En los segmentos de línea en estado de hold (`activeConnectionHold_`) se mantiene deliberadamente la estimación de periodo por autocorrelación para priorizar la precisión visual de ese gesto puntual, aun a costa de más CPU.
  - Se ha introducido un **umbral de nivel visual** (`connectionLevel > 0.05f`) para decidir si merece la pena dibujar una waveform sobre una conexión audio-carrying. Cuando la amplitud efectiva de la conexión es muy baja (por debajo del umbral), ahora se omite por completo la llamada a `drawWaveformOnLine` y se dibuja únicamente una línea recta fina con el color activo. Visualmente, la diferencia es mínima para señales casi silenciosas, pero se evita el coste de construir y recorrer paths con muchos segmentos y de rasterizar su waveform en cada repaint.
- Estas optimizaciones se limitan a las waveforms de **conexión** (incluidas las asociadas a estados de hold); las radiales principales de Oscillator, Sampleplay y Loop siguen usando sus buffers y normas de amplitud existentes para conservar la expresividad visual. El objetivo es reducir el trabajo de rasterización en los casos donde el usuario apenas puede distinguir detalles de waveform (conexiones de nivel muy bajo o segmentos duplicados) y eliminar cálculos de periodo innecesarios en rutas que no dependen visualmente de la periodicidad precisa de la señal.
- Conceptualmente, el impacto esperado es:
  - Menos instrucciones dedicadas a preparación de paths y a autocorrelaciones por conexión, lo que alivia parcialmente el coste de CPU en `paint` observado en Callgrind.
  - Menos invocaciones de `g.strokePath` para waveforms en conexiones de nivel casi nulo, que pasaban inadvertidas al ojo pero generaban trabajo de píxel innecesario.
  Estas mejoras deben contribuir a mantener la carga de CPU del hilo de UI por debajo del objetivo (~60%) en escenas como `default.rtp`, especialmente cuando hay muchas conexiones visibles pero con niveles de audio modestos.

### Opción de AVX/AVX2 específica para rectai-tracker
- Se ha añadido una opción de CMake `RECTAI_TRACKER_ENABLE_AVX` en [tracker/CMakeLists.txt](tracker/CMakeLists.txt#L1-L80) para habilitar flags de vectorización avanzada (AVX, AVX2 y FMA) **sólo** en el binario `rectai-tracker` y únicamente en toolchains no-MSVC.
- Cuando `RECTAI_TRACKER_ENABLE_AVX` está activada, el script comprueba de forma independiente el soporte de `-mavx`, `-mavx2` y `-mfma` mediante `check_cxx_compiler_flag` y añade cada flag soportada al target `rectai-tracker` con `target_compile_options`, restringiéndolas a configuraciones `Release` y `RelWithDebInfo` mediante `generator expressions`. Esto evita afectar a los builds de `Debug` usados para depuración y perfiles de desarrollo.
- La opción queda desactivada por defecto (`OFF`) para mantener la máxima compatibilidad de CPU en binarios distribuidos (por ejemplo, contenedores Docker o builds compartidos). En entornos controlados donde se conoce de antemano que la CPU de destino soporta AVX2/FMA, se puede forzar desde la configuración de CMake con `-DRECTAI_TRACKER_ENABLE_AVX=ON` junto con `-DCMAKE_BUILD_TYPE=Release` para obtener kernels de OpenCV y libfidtrack compilados con estas extensiones, sumándose a las optimizaciones ya aplicadas de `-march=native` cuando `RECTAI_ENABLE_CPU_OPTIMIZATIONS` está activo.

## 2025-12-17

### Unificación de BPM global y helpers en TempoModule
- Se ha introducido en `TempoModule` un rango canónico de BPM (`kMinBpm=40`, `kMaxBpm=400`) junto con helpers estáticos `ClampBpm`, `BpmFromNormalised` y `NormalisedFromBpm` que encapsulan el mapeo entre valores normalizados [0,1] y BPM reales. Estos helpers usan `std::clamp` y viven en el header de `AudioModules`, evitando dependencias directas de JUCE en los headers de dominio.
- `MainComponent` pasa a almacenar el BPM global como `float bpm_` en lugar de `double`, ya que no se necesita más precisión para la sesión en marcha. Al cargar un patch (`LoadReactablePatchFromFile`), el valor inicial de `bpm_` se toma del parámetro lógico `tempo` del `TempoModule` (si existe) y se normaliza mediante `TempoModule::ClampBpm`.
- Toda la interacción de UI que modifica el tempo (rueda de ratón sobre el nodo de Tempo, clicks y drags en la barra lateral izquierda interpretada como control de tempo, y la rotación del tangible de Tempo en el bucle de audio) reutiliza ahora los helpers de `TempoModule`:
  - En `MainComponent_Input.cpp`, los gestos de rueda sobre el `TempoModule` ajustan `bpm_` en pasos de ±1 BPM (o ±5 BPM con Shift) usando `ClampBpm`, y sincronizan el parámetro `tempo` del módulo asignando directamente el `float bpm_` sin conversiones intermedias a `double`.
  - En los clicks y drags sobre la barra lateral de Tempo, la posición vertical se mapea a BPM utilizando `BpmFromNormalised` y se muestra la barra leyendo `NormalisedFromBpm(bpm_)`, eliminando la lógica duplicada de límites [40,400] y normalización que había repartida por varios archivos.
  - En `MainComponent_Audio.cpp`, la rotación del tangible Tempo convierte el delta angular en `deltaBpm` `float` y aplica `TempoModule::ClampBpm` para obtener el nuevo `bpm_`, actualizando a continuación el parámetro lógico `tempo` del módulo.
   - En el mismo `timerCallback` de `MainComponent_Audio` se ha afinado también la animación de los pulsos BPM centrales: el lifetime visual de cada pulso se ha reducido de ~0.3 s a ~0.2 s para que la expansión del círculo y su desvanecimiento ocurran más deprisa dentro de cada beat, manteniendo la generación de pulsos bloqueada al transporte global (`audioEngine_.transportBeats()`). Esto hace que el efecto de dibujo resulte más “rápido” y acorde a la percepción musical sin tocar el tempo real.
   - En la capa de pintura (`MainComponent_Paint.cpp`), el grosor del trazo de cada círculo pasa de ser constante (4 px para pulsos fuertes, 2 px para débiles) a crecer de forma suave a lo largo de la vida del pulso: se parte de ese grosor base y se añade hasta ~3 px extra en función de una edad normalizada `tRadius` (resultado de una curva cúbica tipo Bezier). De este modo, a medida que la onda se expande hacia fuera, el contorno se hace ligeramente más grueso, reforzando la sensación de avance del pulso sin introducir nuevos cálculos costosos ni ramas en el render.
   - Para la propia expansión radial y el desvanecimiento se han sustituido las rampas lineales originales por curvas de easing simples: el radio usa una `ease-out` cúbica (equivalente a una Bezier con aceleración inicial) que hace que el círculo crezca rápido al inicio y se frene hacia el final del pulso, mientras que la opacidad usa una caída cuadrática sobre `1 - t` que mantiene el pulso visible más tiempo antes de suavizar el fade-out en la cola. Estas curvas suavizan tanto la “entrada” como la desaparición del pulso sin afectar al bloqueo de fase respecto al transporte.
- El pintado de la barra lateral de Tempo y de la etiqueta numérica de BPM (`MainComponent_Paint.cpp`) utiliza ahora `TempoModule::NormalisedFromBpm(bpm_)` para derivar la posición de la barra y sigue mostrando el valor entero de BPM a partir del `float bpm_`, con el mismo comportamiento de fade basado en `bpmLastChangeSeconds_`.
- En `AudioEngine`, el tempo global de loops (`loopGlobalBpm_`) se ha cambiado de `std::atomic<double>` a `std::atomic<float>` y el setter `setLoopGlobalTempo` ahora recibe un `float`. El motor de audio sigue convirtiendo este valor a `double` solo en el cálculo intermedio de `beatsPerSecond`, pero el almacenamiento y la API expuesta se mantienen en `float` para alinearse con `MainComponent::bpm_`. `MainComponent_Audio` continúa llamando a `audioEngine_.setLoopGlobalTempo(bpm_)` en cada tick del timer para mantener los loops sincronizados con el tempo global.

## 2025-12-16

### Suavizado de ataque en la envolvente de Oscillator para evitar clicks
- Tras ajustar la lógica de duración/decay de la envolvente por voz en `AudioEngine` para respetar `duration` (modo one-shot), se detectaron pequeños "clicks" audibles al inicio de cada nota del Oscillator cuando el `attack` del `<envelope>` era 0 ms (caso típico del Oscillator 47 en `Loopdemo.rtp`).
- El origen del artefacto es el salto brusco de amplitud cuando una nueva nota reinicia la envolvente desde 0 a un nivel alto en un solo sample: aunque la fase de la onda del oscilador es continua, la rampa de ataque instantánea genera un escalón en la envolvente que se percibe como un transitorio de banda ancha.
- Para mitigarlo sin cambiar perceptiblemente la sensación de ataque instantáneo, se ha introducido en `AudioEngine` un **ataque mínimo** para las envolventes de voz de Oscillator: al calcular `attackSeconds` a partir de `attackMs`, si el resultado es `<= 0` se sustituye por un pequeño valor fijo `kMinAttackSeconds = 0.0005` (≈0.5 ms). Esto se aplica tanto al modo one-shot (governado por `duration`) como al modo AR clásico.
- Con este ajuste, los patches que declaran `attack="0"` siguen sonando con un ataque prácticamente inmediato desde el punto de vista musical, pero el primer puñado de samples de la envolvente se suaviza lo suficiente como para eliminar los clicks al inicio de cada nota cuando el `Sequencer` dispara pasos densos sobre el Oscillator.

### Reducción de jitter en el disparo de pasos del Sequencer
- Aunque el índice de step de audio del `Sequencer` ya se calculaba a partir del transporte continuo en beats del motor de audio (`audioEngine_.transportBeats()`), los cambios de step se detectaban únicamente en `MainComponent::timerCallback`, que se ejecutaba a 120 Hz. Esto introduce una cuantización temporal de hasta ≈8.3 ms entre el instante ideal del beat y el tick del timer en el que realmente se llama a `runSequencerStep`, produciendo una ligera sensación de notas adelantadas/atrasadas.
- Para reducir este jitter sin mover todavía la lógica del Sequencer al hilo de audio, se ha incrementado la frecuencia del timer de `MainComponent` de 120 Hz a 240 Hz (`startTimerHz(240)`), manteniendo la misma integración de beats (`transportBeats_ + beatPhase_`) pero consultándola con el doble de resolución.
- A 240 Hz, el error máximo entre el instante real del beat en el motor de audio y el tick de `timerCallback` que dispara el siguiente step se reduce a ≈4.2 ms, lo que hace que el patrón de notas de los Oscillators conectados al Sequencer suene más estable en el tiempo y con menor sensación de acelerones/frenazos puntuales.
- Además, el avance de steps dentro de `MainComponent_Audio::timerCallback` dejaba caer pasos cuando el timer se retrasaba más de una semicorchea: el índice de step se derivaba directamente como `newAudioStep = floor(stepPhase) % NumSteps` y sólo se ejecutaba `runSequencerStep` cuando `newAudioStep != sequencerAudioStep_`, de modo que, si el transporte cruzaba dos o más límites de step entre dos ticks del timer, sólo se disparaba el último y los intermedios se perdían, produciendo irregularidades audibles (patrones que a veces suenan más “lentos” o “rápidos” de lo esperado).
- Para corregirlo, se ha introducido en `MainComponent` un contador absoluto de steps de audio (`sequencerAudioStepCounter_`, `int64_t`) que representa cuántas semicorcheas han transcurrido desde el inicio del transporte. En cada `timerCallback` se calcula el nuevo contador ideal como `newStepCounter = floor( (transportBeats_ + beatPhase_) / beatsPerStep )` y, si `newStepCounter > sequencerAudioStepCounter_`, se ejecuta un bucle `for` que llama a `runSequencerStep(stepIndex)` para **cada** step intermedio en el rango `[old+1, new]`, usando `stepIndex = counter % NumSteps`.
- Con este cambio, incluso si el hilo de UI/timer se retrasa puntualmente y deja pasar varios steps ideales entre dos callbacks, todos los pasos se ejecutan en orden (compactados en el tiempo) en lugar de saltarse silenciosamente, estabilizando el groove percibido sin necesidad de mover aún la lógica del Sequencer al hilo de audio.

### Sincronía del Sequencer con el transporte global (beats, Loops y pulsos)
- La lógica de avance del `Sequencer` en `MainComponent_Audio::timerCallback` se ha ajustado para que el índice de step de audio ya no dependa de un acumulador interno específico (`sequencerAudioPhase_`), sino de la **misma posición global en beats** que utilizan el motor de Loops y los pulsos visuales centrales.
- En lugar de incrementar una fase propia por frame (`sequencerAudioPhase_ += beatsThisFrame`) y derivar de ella el índice de step, ahora se calcula explícitamente la posición de transporte continua en beats como `transportPositionBeats = transportBeats_ + beatPhase_` y, a partir de ahí, se obtiene el step activo con:
  - `beatsPerStep = 1.0 / 4.0` (16 steps por compás de 4/4, semicorcheas),
  - `stepPhase = transportPositionBeats / beatsPerStep`,
  - `newAudioStep = floor(stepPhase) % SequencerPreset::kNumSteps`.
- Esto garantiza que:
  - El `Sequencer` recorre **exactamente 16 steps en 4 beats** para el caso típico `speed=1` (semicorchea) documentado en `research/sequencer.md`,
  - Los pasos del `Sequencer` quedan **fase-bloqueados** con los Loops (que ya usan `loopGlobalBeatCounter_` + `loopBeatPhase_`) y con los pulsos visuales de BPM, evitando pequeños desfases acumulados entre relojes independientes.
- La firma externa del runtime no cambia (se mantiene un `runSequencerStep(stepIndex)` que se ejecuta únicamente cuando el índice de step cambia), pero internamente el cálculo de `newAudioStep` pasa a compartir la misma noción de “beat” que el resto de la sesión, reforzando la coherencia entre Loops de audio, notas de `Oscillator` disparadas por `Sequencer` y el beat central que se dibuja en la UI.

#### Limpieza de gating extra y mapeo Decay/Release en Oscillator
- El runtime anterior introducía un gating adicional basado en `SequenceTrack::speed` y `speed_type="binary"` para módulos `Oscillator` conectados a un `Sequencer`: al disparar un paso se calculaba una duración en beats (`binarySpeedToBeats`) y se programaba un “note-off” extra en `moduleNoteOffBeats_` que forzaba el parámetro `gain` del Oscillator a 0 cuando el transporte alcanzaba ese beat. Esta lógica se ha eliminado por completo de `MainComponent`.
- A partir de ahora, la duración audible de las notas que salen de un `Sequencer` hacia un `Oscillator` se gobierna únicamente por:
  - Los pasos activos/inactivos del propio `Sequencer` (cuando un paso está deshabilitado y `sequencerControlsVolume_` es verdadero, el runtime fija explícitamente `gain=0` en los Oscillators aguas abajo en ese beat), y
  - La envolvente AR de cada voz en `AudioEngine` (tiempos de ataque y release) configurada a partir del `<envelope>` del Oscillator cargado desde el `.rtp`.
- Para que el parámetro `decay` de los Oscillators tenga un efecto audible aun cuando `release` es 0 en el patch (caso típico de `Loopdemo.rtp`), el mapeo de envelope en `MainComponent_Audio` se ha ajustado de forma que el **release efectivo** en el motor de audio sea `env.release` si es > 0, o en su defecto `env.decay`. Es decir:
  - `audioEngine_.setVoiceEnvelope(voice, env.attack, env.decay, env.duration, effectiveReleaseMs)`,
  - donde `effectiveReleaseMs = (env.release > 0 ? env.release : env.decay)`.
- Dado que `AudioEngine` implementa por ahora una envolvente simple tipo AR (Attack/Release), este cambio hace que el “Decay” definido en el `.rtp` se traduzca en la cola de release cuando el release original era 0, evitando que las notas disparadas por el Sequencer caigan inmediatamente a volumen 0 nada más terminar el paso activo.

### Sequencer v1 basado en pulsos (steps/volumes) y versionado
- Se ha introducido un campo de versión en `rectai::SequencerModule` (`core/src/core/AudioModules.h`), expuesto mediante `version()` y `set_version(int)`. El valor se interpreta como la versión del tangible Sequencer en el `.rtp`; cuando el atributo `version` no está presente en la etiqueta `<tangible type="Sequencer" ...>`, el módulo se inicializa por defecto con versión 1 (modo legado de pulsos), reservando versiones ≥2 para futuros modos melódicos/avanzados.
- En el loader de sesiones Reactable (`core/src/core/ReactableRtpLoader.cpp`), el bloque que trata `type == "Sequencer"` ahora lee el atributo opcional `version` usando `ParseInt(attrs, "version", 1)` y lo pasa al módulo mediante `seq->set_version(sequencer_version)`. El atributo `version` ya no se vuelca como parámetro numérico genérico del módulo. El resto de atributos numéricos del tangible (`current_track`, `autoseq_on`, `noteedit_on`, `duration`, `num_tracks`, `offset`, etc.) siguen copiándose en parámetros internos del `SequencerModule` como antes.
- La estructura `SequenceTrack` ya contenía todos los campos relevantes de los `<sequence>` del `.rtp` (`rows`, `speed`, `speed_type`, `step_frequencies`, `steps`, `tenoriX`, `volumes`) y el loader sigue poblando estos vectores a partir de los atributos CSV. Sobre esta base, se ha ajustado la lógica de `SequencerModule::SyncPresetsFromTracks()` (`core/src/core/AudioModules.cpp`) para que el comportamiento dependa de la versión:
  - En **versión 1** (modo pulsos), el sequencer **no codifica información melódica** en los presets: cada `SequencerStep` se considera un disparo (trigger) binario definido únicamente por `steps` (0/1) y `volumes` (amplitud en [0,1]). La función mantiene la semántica ya existente para estos dos campos: `step.enabled` se deriva de `track.steps` y `step.velocity01` se toma de `track.volumes`, clampeando a [0,1] y forzando `0.0` cuando el paso está deshabilitado. La altura/energía de cada pulso queda predeterminada por el volumen correspondiente.
  - Para **versión 1**, el campo `pitch` de cada `SequencerStep` se fija explícitamente a una nota constante (C4, MIDI 60) y no se consulta `track.step_frequencies`, pero esta nota **no** se usa en el runtime de audio: actúa como placeholder interno para mantener la estructura de datos homogénea con versiones melódicas futuras. En ejecución, los módulos destino (`Oscillator`/`Sampleplay`) siguen determinando la nota audible a partir de su propia configuración (`midifreq`/`freq`); el Sequencer v1 sólo aporta el trigger (paso activo/inactivo) y la intensidad (`velocity01` derivada de `volumes`). El vector `pitches` de cada step sigue conteniendo un único valor igual a `pitch` cuando `enabled` es verdadero, preservando la estructura pensada para modos polifónicos futuros.
  - En **versiones ≥2**, se conserva el comportamiento actual de `SyncPresetsFromTracks`: los `step_frequencies` del `.rtp` se convierten a notas MIDI usando la relación estándar entre frecuencia y `69/440 Hz` (`midi = 69 + 12*log2(freq/440)`), se clampean al rango [0,127] y se asignan a `step.pitch`. Esto permite que un Sequencer v2 se use como secuenciador melódico real con pitches por paso cuando el runtime de audio implemente esta variante.
- A nivel de tiempo musical, la información de tempo sigue residiendo en los módulos `Tempo` (tempo en BPM, metro, swing) y en los campos `speed` y `steps` de `SequenceTrack`. Para **version 1** se formaliza la interpretación: cuando `speed=1` en un `<sequence>`, el patrón completo de `N` pasos ocupa exactamente **4 beats**; el índice de paso activo $i$ en un tiempo global $t$ medido en beats puede obtenerse como $i = \lfloor ( (t \bmod 4) / 4 ) \cdot N \rfloor$. Esta relación aún no se aplica en un motor de secuenciación en tiempo real, pero queda documentada para futuras fases de implementación del runtime que a partir de `tracks`, `speed` y `TempoModule` deberán decidir en qué beat se disparan los pulsos.
- Se ha añadido un test mínimo en `tests/scene_tests.cpp` que carga un patch `.rtp` embebido con un único `<tangible type="Sequencer" id="6" ...>` sin atributo `version` y un solo `<sequence>` con `steps` y `volumes` similares al ejemplo `Loopdemo.rtp`. El test comprueba que:
  - El loader crea exactamente un módulo `Sequencer` y un `ObjectInstance` asociado.
  - `seqModule->version()` es `1` al no declararse el atributo `version`.
  - Al llamar a `SyncPresetsFromTracks()` (invocado desde el loader) el preset 0 refleja correctamente los pasos habilitados/inhabilitados según el vector `steps` y las velocidades en [0,1] según `volumes`, con `velocity01 == 0.0` cuando el paso está deshabilitado.
  - Todos los pasos del preset (habilitados o no) comparten `step.pitch == 60`, verificando que en versión 1 se ignora `step_frequencies` y el sequencer se comporta como generador de pulsos sin codificar melodía.

### Priorización por ventana de 30 frames y filtro ganador en TrackerEngine
- Se ha rediseñado la lógica de selección de filtros en [tracker/src/TrackerEngine.cpp](tracker/src/TrackerEngine.cpp#L80-L260) para que, cuando se detecta por primera vez un fiducial, el tracker abra una **ventana de evaluación de 30 frames** en la que ejecuta todos los filtros de umbral disponibles sobre cada frame y cuenta cuántas veces cada filtro consigue ver **ese mismo fiducial**.
- `TrackerEngine` sigue modelando cuatro filtros concretos sobre la imagen en escala de grises reescalada: `OtsuBinary`, `OtsuBinaryInv`, `AdaptiveBinary` y `AdaptiveBinaryInv`. En la clase ([tracker/src/TrackerEngine.h](tracker/src/TrackerEngine.h#L20-L80)) se ha introducido un pequeño estado asociado a un "fiducial principal":
  - `primaryFiducialId_`: id del fiducial que se toma como referencia cuando aparece el primero en escena.
  - `trainingFramesRemaining_`: número de frames que quedan en la ventana de 30 frames sobre la que se evalúa qué filtro ve más veces ese fiducial.
  - `hasActiveFilter_` y `activeFilter_`: indican si ya hay un filtro ganador fijado y cuál es.
  - `primaryLostLastFrame_`: marca si en el frame anterior el filtro activo dejó de ver al fiducial principal, para activar la lógica de recuperación descrita más abajo.
  - `framesSincePrimarySeen_`: cuenta cuántos frames consecutivos llevamos sin ver al fiducial principal con ningún filtro.
  - `filterSuccessCount_[4]`: acumula, durante la ventana de entrenamiento, en cuántos frames cada filtro ha sido capaz de detectar el fiducial principal.
  - `filterSeenIds_[4]`: almacena, para cada filtro, el conjunto de IDs distintos que ha visto durante la ventana de entrenamiento.
- Durante la ventana de entrenamiento (`trainingFramesRemaining_ > 0`), `processFrameInternal` ejecuta los cuatro filtros en cada frame, acumula la unión de todos los fiduciales detectados como resultado y, para cada filtro, añade todos los IDs vistos a su conjunto en `filterSeenIds_`. Si el resultado de un filtro contiene el `primaryFiducialId_`, se incrementa también su contador en `filterSuccessCount_`. Al agotar los 30 frames (`kTrainingWindowFrames = 30`), se selecciona como **filtro ganador** aquel que cumpla dos criterios: (1) haber visto el fiducial principal al menos una vez (contador > 0), y (2) tener el número más bajo de IDs distintos acumulados; en caso de empate en (2), se usa como desempate el contador de éxitos.
- Mientras exista filtro ganador activo y el fiducial principal siga viéndose, el tracker entra en un modo de **uso exclusivo del filtro ganador**: en cada frame sólo se ejecuta `activeFilter_` para binarizar y detectar fiduciales, reduciendo el coste de CPU respecto a probar todos los filtros en cada paso.
- Si en algún frame el filtro activo deja de ver al fiducial principal, `primaryLostLastFrame_` pasa a `true` y, en el frame siguiente, el tracker **ejecuta de nuevo los cuatro filtros**: si alguno de ellos vuelve a detectar el `primaryFiducialId_`, se considera que el fiducial ha reaparecido y se reinicia una nueva ventana completa de 30 frames de evaluación (empezando a contar desde ese mismo frame); si ninguno lo ve, se interpreta que el fiducial realmente ha desaparecido y se limpia todo el estado adaptativo (`hasActiveFilter_ = false`, `primaryFiducialId_ = -1`, contadores y conjuntos de IDs a cero), volviendo al modo base.
- En el modo base (sin fiducial principal ni filtro activo), `processFrameInternal` ejecuta todos los filtros, devuelve la unión de todas las detecciones y, en el primer frame donde aparezca algún fiducial, escoge el id del primer objeto como `primaryFiducialId_`, inicializa contadores y conjuntos (`filterSuccessCount_`, `filterSeenIds_`) y arranca la ventana de entrenamiento de 30 frames descrita arriba.
- Además, se ha introducido un umbral duro de desaparición: si el fiducial principal lleva más de 4 frames consecutivos sin aparecer en los resultados (ni siquiera al ejecutar todos los filtros), se descarta inmediatamente (`primaryFiducialId_ = -1`) y se resetea todo el estado adaptativo (`hasActiveFilter_`, contadores por filtro y conjuntos de IDs vistos). De este modo, el tracker no mantiene durante demasiado tiempo un filtro "aprendido" basándose en un fiducial que ya no está presente en escena.
- El helper estático `filterIndex(ThresholdFilter)` en [tracker/src/TrackerEngine.cpp](tracker/src/TrackerEngine.cpp#L260-L300) sigue proporcionando el índice `[0,3]` asociado a cada valor del enum para indexar los arrays internos cuando es necesario.
- En builds de depuración (`NDEBUG` desactivado), al finalizar cada ventana de entrenamiento se escribe una traza a stderr con el resumen de resultados por filtro: número de frames de entrenamiento, aciertos por filtro y número de IDs distintos vistos por cada uno, junto con el nombre del filtro ganador. Esto facilita inspeccionar rápidamente qué estrategias de umbral están resultando más robustas bajo las condiciones de iluminación actuales.
- Tras estos cambios, se ha vuelto a ejecutar el test de tracker vía CTest (`ctest -R tracker`) y `rectai-tracker-tests` sigue pasando: las imágenes de prueba `fiducial_30.jpg` y `fiducial_55.jpg` se detectan correctamente con sus IDs esperados, aunque en las imágenes de prueba también se observan algunos IDs adicionales secundarios (activados por la mejora en la lógica de unión de detecciones por filtro), lo que sirve de caso realista para ajustar esta heurística de selección de filtro.

### Extensión rango Oscillator y carga de sesiones RTP (Loopdemo)
- Se ha ampliado el mapeo de frecuencia del `OscillatorModule` para que el
  parámetro normalizado `freq` cubra aproximadamente el rango de notas
  MIDI 0–127 (≈8 Hz–12.5 kHz). Esto alinea el comportamiento con los
  patches originales de Reactable donde `midifreq` puede estar en todo
  el rango MIDI.
- El loader de sesiones RTP (`ReactableRtpLoader`) ahora, al cargar un
  `Oscillator` con atributo `midifreq`, calcula la frecuencia en Hz
  usando la fórmula estándar MIDI→Hz y la convierte a valor normalizado
  `freq` usando `base_frequency_hz` y `frequency_range_hz` del módulo.
  De este modo la afinación por defecto del oscilador en la escena
  coincide con la nota indicada en el `.rtp`.
- Para los módulos `Loop` y `Oscillator`, el `<envelope>` definido en
  el archivo `.rtp` se parsea a la estructura `Envelope` y, además, se
  vuelca en los parámetros del módulo (`attack`, `decay`, `duration`,
  `release`). Esto facilita que la UI y el motor de audio puedan
  consultar/aplicar el ADSR de forma consistente.
- Se han ampliado los tests en `tests/scene_tests.cpp` para comprobar
  que:
  - `midifreq` se expone como parámetro del `Oscillator` tras cargar
    una sesión RTP.
  - El parámetro normalizado `freq` queda inicializado de forma que la
    frecuencia efectiva en Hz sea coherente con la nota `midifreq`.
  - Los valores ADSR del `<envelope>` de un `Oscillator` se almacenan
    tanto en la estructura `Envelope` interna como en los parámetros del
    módulo.

### ADSR aplicado en runtime a Oscillator y Loop
- Se ha añadido soporte de envolvente simple tipo AR en `AudioEngine`
  para las voces de `Oscillator`: el motor detecta transiciones del
  nivel de voz (0→>0 como note-on, >0→0 como note-off) y aplica una
  rampa de ataque y una de release en tiempo de muestra usando los
  tiempos `attack` y `release` cargados desde el `<envelope>` del
  módulo. `decay` y `duration` se reservan para una futura
  implementación de ADSR completo, pero ya se propagan hasta el motor.
- `MainComponent_Audio` ahora pasa la envolvente de cada
  `OscillatorModule` a través de `AudioEngine::setVoiceEnvelope`, de
  modo que cada voz conoce los tiempos de ataque/decaimiento/duración/
  release configurados en la sesión RTP.
- Para los módulos `Loop`, `AudioEngine::LoopInstance` mantiene ahora
  un pequeño estado de envolvente (fase, valor actual y tiempos
  attack/release). `MainComponent_Audio` llama a
  `setLoopModuleParams` incluyendo los cuatro tiempos del
  `<envelope>` del Loop; en el callback de audio el motor suaviza los
  cambios de ganancia del loop (por mute/desmute o cambios de `amp`)
  aplicando la misma envolvente AR basada en los tiempos de ataque y
  release.
- Esta primera fase garantiza que los parámetros de envelope definidos
  en `.rtp` tienen un efecto audible: los osciladores y loops ya no
  reaccionan con saltos bruscos de nivel, sino que respetan rampas de
  entrada/salida según los tiempos de ataque y release de la sesión.

#### Extensión: retrigger de envelope por paso de Sequencer
- Se ha ampliado la lógica de envolvente por voz en `AudioEngine` para
  que, además de las transiciones de nivel 0↔>0, pueda reaccionar a
  **disparos explícitos** procedentes del runtime del `Sequencer`.
  Cada voz mantiene ahora un flag atómico `voiceEnvRetrigger_[v]` que
  se marca desde el hilo de UI y se consume en el callback de audio;
  cuando está activo, la envolvente de esa voz reinicia la fase de
  `attack` independientemente de si el nivel actual era ya > 0.
- Se ha añadido el método público `AudioEngine::triggerVoiceEnvelope(int)
 `, que marca el flag de retrigger para una voz concreta. Este método
  se utiliza desde `MainComponent_Audio` cuando un módulo
  `SequencerModule` avanza un paso activo hacia un `OscillatorModule`
  conectado.
- En `MainComponent_Audio::timerCallback`, dentro del lambda
  `runSequencerStep`, la rama que trata destinos `OscillatorModule`
  mantiene el comportamiento previo (v2: puede sobreescribir `freq`
  a partir de `step.pitch`; cuando `sequencerControlsVolume_` está
  activo, mapea `velocity01` a `gain`), pero ahora además localiza el
  índice de voz asignado al oscilador en `moduleVoiceIndex_` y llama a
  `audioEngine_.triggerVoiceEnvelope(voiceIndex)` para cada paso
  habilitado.
- Con este cambio, incluso cuando una secuencia mantiene varios pasos
  consecutivos con `velocity01 > 0` (es decir, el nivel del oscilador
  no llega a caer a cero entre beats), cada beat activo del Sequencer
  **reinicia la envolvente** del Oscillator. En la práctica, los
  módulos de tipo Oscillator conectados a un Sequencer pasan a seguir
  las notas del secuenciador mediante pulsos de envolvente por paso,
  respetando los tiempos de ataque/release definidos en el `<envelope>`
  del módulo, en lugar de mantener una envolvente en sustain continuo.

### Normalización y límites para ADSR y `midifreq`
- El parser de `<envelope>` en `ReactableRtpLoader.cpp` ahora aplica
  límites razonables a los tiempos en milisegundos: `attack`, `decay`
  y `release` se clampean al rango `[0, 2000]` ms y `duration` al
  rango `[0, 7500]` ms. Valores negativos, no finitos o con formato
  inválido se normalizan primero a `0.0F` antes de aplicar el clamping
  superior. Los arrays `points_x` y `points_y` siguen leyéndose como
  CSV de flotantes (`SplitFloats`), por lo que valores decimales en el
  `.rtp` (como los de `Loopdemo.rtp`) se conservan tal cual en
  `Envelope::points_x/points_y`.
- En `MainComponent_Audio.cpp`, el cálculo de la nota MIDI para
  `SampleplayModule` dentro de `triggerSampleplayNotesOnBeat` pasa de
  usar `lround` a `std::floor` sobre el parámetro `midifreq`. Esto
  respeta la semántica acordada: `midifreq` puede ser entero o decimal
  en el `.rtp`, pero en Sampleplay siempre se trunca hacia abajo a un
  número de nota MIDI entero en `[0, 127]` antes de disparar la nota.
- Para `OscillatorModule`, el loader sigue usando el valor de
  `midifreq` como `float` completo al convertir de MIDI→Hz y
  normalizar el parámetro `freq`, de forma que ajustes finos (por
  ejemplo, microafinación expresada como decimales) en el `.rtp` se
  trasladan directamente a la frecuencia base del oscilador dentro del
  rango expandido (~8–12.5 kHz).

### Próximos pasos relacionados

- Extender el mapeo de envelope en tiempo de ejecución para cubrir
  casos más avanzados (por ejemplo, shapes no lineales a partir de
  `points_x`/`points_y` o modulación de otros parámetros distintos de
  la amplitud) tanto en `Oscillator` como en `Loop`.
- Revisar el flujo de `Sampleplay` para decidir cómo usar `midifreq`
  como afinación por defecto al cargar sesiones RTP, manteniendo la
  compatibilidad con el disparo actual por beat.

### Implementación de sustain ADSR para Oscillator

- Se ha implementado un envelope ADSR completo para las voces de
  Oscillator en `AudioEngine`, utilizando los tiempos de
  `attack/decay/release` y derivando el nivel de `sustain` a partir
  de los puntos de control `Envelope::points_y` cargados desde el
  `.rtp`.
- La estructura `AudioEngine::Voice` incorpora ahora un campo atómico
  `sustainLevel`, configurado a través de la nueva firma de
  `AudioEngine::setVoiceEnvelope(int index, float attackMs,
  float decayMs, float durationMs, float releaseMs, float
  sustainLevel)`. El sustain se limita al rango [0,1] dentro del
  callback de audio.
- En `audioDeviceIOCallbackWithContext`, la rama de envolvente por voz
  sin `duration` (antes modo "AR clásico") pasa a implementar un
  ADSR completo gobernado por note-on/note-off:
  - `Attack`: rampa de 0→1 usando `attackMs` (con mínimo de 0.5 ms
    para evitar clics).
  - `Decay`: nuevo tramo opcional que interpola linealmente de 1.0 al
    `sustainLevel` en `decayMs`.
  - `Sustain`: mantiene `sustainLevel` mientras la nota siga activa.
  - `Release`: rampa lineal desde el valor de envelope en el momento
    del note-off hasta 0 en `releaseMs`, usando un nuevo buffer
    interno `voiceEnvReleaseStart_` para recordar el nivel de partida.
- El modo one-shot basado en `durationMs` se mantiene para futuros
  usos, pero los Oscillator existentes dejan de entrar en esa rama al
  forzar `durationMs=0` en la capa de UI.
- En `MainComponent_Audio.cpp`, la configuración de la envolvente para
  módulos `OscillatorModule` se actualiza para:
  - Forzar `durationMs` a 0 cuando se llama a
    `audioEngine_.setVoiceEnvelope`, de forma que los osciladores se
    comporten como fuentes sostenidas gobernadas por note-on/note-off
    (tangible activo) en lugar de envelopes one-shot cortos.
  - Calcular el `sustainLevel` a partir de `Envelope::points_y` con la
    heurística siguiente: buscar el tramo "plano" interno más largo de
    puntos consecutivos con `y > 0` (ignorando primer/último punto) y
    usar ese nivel como sustain; si no existe, usar el máximo `y`
    previo al último punto o 1.0 como fallback.
  - Mantener el comportamiento previo de `release` efectivo: si el
    `.rtp` define `release > 0` se usa su valor; si no, se cae a
    `decay` para garantizar una cola suave.
- Con este cambio, el Oscillator de onda seno de la mesa por defecto
  mantiene ahora un sustain continuo mientras el módulo esté activo:
  la línea de sonido en la UI coincide con el audio real, eliminando
  el corte brusco que se producía al tratar su envelope como
  one-shot basado en `duration`.

### Ajuste visual de mute pendiente en líneas de audio
- Se ha modificado el pintado de las líneas radiales de audio en `MainComponent_Paint.cpp` para que, cuando una línea está marcada como "pendiente de silenciar" (estado de cut/mute en hover sobre la conexión), se mantenga la waveform existente y sólo cambie el color de la línea de sonido de blanco a amarillo. Anteriormente, al marcar una línea para mute, se sustituía la waveform por una línea recta amarilla, dando la sensación de que se dibujaba una nueva línea plana sin información de audio.
- Para conseguirlo, las ramas de pintado de waveform de radiales asociadas a `SampleplayModule`, `LoopModule` y módulos con voces procedurales dejan de descartar el caso `isMarkedForCut`; ahora siguen obteniendo su snapshot de waveform (por conexión o global) y llaman a `drawWaveformOnLine` con el mismo patrón espacial, pero seleccionando el color en función del estado: blanco cuando la línea está activa normalmente y amarillo cuando está marcada para mute pendiente, de forma uniforme en todos los tipos de módulo.
- La rama de fallback que antes dibujaba explícitamente una línea recta amarilla de mayor grosor cuando `isMarkedForCut` se ha simplificado para actuar sólo cuando no hay waveform disponible (líneas sin audio o en silencio): en ese caso se sigue resaltando la conexión con una línea amarilla fina, pero nunca se reemplaza una waveform existente por una línea plana. Esto alinea el comportamiento visual con la expectativa de que el gesto de hover/mute pendiente "colorea" la línea de audio sin alterar su forma.

### Contador global de beats para LoopModule y continuidad al cambiar de sample
- Se ha introducido en `AudioEngine` un contador global de beats específico para los módulos `Loop`, implementado como un `std::atomic<unsigned int> loopGlobalBeatCounter_` junto con los métodos públicos `resetLoopBeatCounter(unsigned int)`, `advanceLoopBeatCounter()` y `loopBeatCounter()`. Este contador se incrementa exactamente una vez por cada beat de tempo y se inicializa a 0 al cargar una sesión en `MainComponent` mediante `audioEngine_.resetLoopBeatCounter(0U)`, cumpliendo el requisito de disponer de una variable global de "beats marcados" que avanza con el transporte.
- Además del contador entero, el motor mantiene ahora una fase fraccional de beat en `std::atomic<double> loopBeatPhase_` que se actualiza desde `MainComponent_Audio.cpp` en cada `timerCallback()` usando el mismo `beatPhase_` que alimenta las animaciones de pulsos (`audioEngine_.setLoopBeatPhase(beatPhase_)`). De esta forma, el motor dispone de una posición global de beat **continua** calculada como `loopBeats = loopGlobalBeatCounter_ + loopBeatPhase_`, compartida por todos los módulos Loop.
- La estructura interna `LoopInstance` en `AudioEngine.h` se ha ampliado con un campo `int lastSelectedIndexForPlayback{-1};` que solo se utiliza en el hilo de audio. Este campo recuerda qué índice de slot se alineó por última vez para reproducción y permite detectar cuándo el usuario cambia de sample activo en un `LoopModule` sin necesidad de escribir sobre `readPositions` desde el hilo de UI, evitando condiciones de carrera.
- En el callback de audio `audioDeviceIOCallbackWithContext`, tanto en la rama con voces de oscilador activas como en la rama sin voces, la mezcla de loops se ha modificado para que, justo antes de calcular el `step` de avance, cuando hay un slot válido con `slot.beats > 0` y `totalFrames > 0`, se compruebe si `lastSelectedIndexForPlayback != slotIndex`. Si el índice ha cambiado, se calcula una nueva posición de reproducción basada en la posición global de beat **continua**:
  - Se toma `loopBeats` al inicio del callback como `double` a partir de `loopGlobalBeatCounter_` y `loopBeatPhase_`.
  - Para el slot actual se calcula `beatsPerLoop = static_cast<unsigned int>(slot.beats)` y `loopBeatsMod = fmod(loopBeats, beatsPerLoop)`.
  - La fracción dentro del loop se obtiene como `fracBeat = loopBeatsMod / beatsPerLoop` y se traduce a frames mediante `targetFrame = fracBeat * totalFrames`, clampando el resultado al rango `[0, totalFrames-1]`.
  - Esta posición se escribe en `instance.readPositions[slotIndex]` y se actualiza `lastSelectedIndexForPlayback = slotIndex`.
  Con ello, cada vez que se cambia de sample activo en un módulo Loop, el nuevo sample comienza a reproducirse en la posición coherente con el **tiempo continuo de transporte**, incluso cuando el cambio se hace en mitad de un beat, como si todos los loops estuvieran sonando en paralelo y simplemente se cambiase cuál se escucha.
- La lógica existente de avance de fase por muestra (`step` basado en `sourceSampleRate`, `sampleRate_` y la sincronía opcional a BPM/`beats`) se mantiene intacta. La posición global de beat se usa únicamente como referencia para fijar la posición inicial del slot cuando cambia la selección; a partir de ahí, el avance se realiza de forma continua por muestra. Esto respeta el comportamiento anterior de loops que siguen sonando aunque se mutee su radial (la fase interna nunca se resetea por mute), añadiendo sólo el requisito extra de que cambiar de sample preserve la alineación temporal con el transporte.
- En `MainComponent.cpp`, justo después de `loadLoopSamples()`, se llama explícitamente a `audioEngine_.resetLoopBeatCounter(0U)` para garantizar que cada sesión carga con el contador de beats de loop en un origen bien definido. Este reset no afecta a `transportBeats_`, que sigue siendo un `double` usado para etiquetar eventos MIDI, pero asegura que los cálculos de posición de los loops (basados en el entero global de beats más la fase fraccional) empiezan desde 0 en cada mesa/carga de sesión.

### Rotación del LoopModule con parámetro continuo y scroll infinito
- Se ha ajustado la lógica de control por rotación para los módulos de tipo `Loop` en `MainComponent_Audio.cpp` de modo que el parámetro normalizado `"sample"` se actualiza de forma **continua** con la rotación del fiducial, manteniéndose siempre en el rango `[0,1]` mediante wrap sin clamp duro. Un giro completo de 360º sigue recorriendo los cuatro segmentos de loop (≈90º por segmento), pero ahora el valor subyacente conserva la fracción decimal necesaria para un movimiento suave en la UI.
- El índice de slot activo se sigue derivando cuantizando `"sample"` a cuatro tramos (`0..3`) en `timerCallback`, por lo que el cambio efectivo de sample se mantiene discreto cada ~90º de rotación. Sin embargo, al no forzar el parámetro a los centros de segmento, es posible seguir acumulando rotación más allá de una vuelta completa y el parámetro hace **scroll infinito**, volviendo al primer/último sample al cruzar los extremos `[0,1]` sin “atascarse” en los bordes.
- En `MainComponent_Paint.cpp`, el triángulo indicador de la barra izquierda de los módulos Loop usa directamente el valor continuo de `"sample"` para su posición vertical a lo largo de toda la barra, sin sesgos adicionales por segmento. Esto garantiza que el movimiento del triángulo sea totalmente continuo y proporcional a la rotación del fiducial, y que no haya saltos visibles al cruzar los límites entre segmentos; la selección de slot sigue siendo discreta vía el índice entero derivado de `"sample"`, de modo que el cambio de sample ocurre cada ~90º aunque la animación del marcador sea suave.
 - La geometría de los segmentos de la barra izquierda del Loop se ha invertido para que el índice `0` corresponda a la parte baja de la barra y el índice `3` a la parte alta, en coherencia con el nuevo mapeo vertical del triángulo (que se desplaza de abajo hacia arriba al aumentar `"sample"`). Con ello, el segmento resaltado y la posición del triángulo dejan de estar “en espejo” y ambos representan el mismo orden lógico de slots en la UI.
- Con este cambio, la interacción cumple el comportamiento esperado: cada 90º de rotación se avanza al siguiente segmento de loop (con wrap alrededor de toda la vuelta), y el triángulo refleja visualmente la posición decimal exacta del parámetro sobre la barra, moviéndose de forma continua y coherente con la rotación física del objeto.

### Extensión de los arcos laterales Freq/Gain casi hasta el semi-círculo completo
- Se ha ajustado el recorrido vertical de las barras laterales de frecuencia y volumen en `MainComponent_Paint.cpp` para que los arcos izquierdo (Freq) y derecho (Gain) abracen casi todo el semi-círculo alrededor del nodo, dejando solo un pequeño hueco en la parte superior. Esto se consigue reduciendo el margen vertical `sliderMargin` de `6.0F` a `3.0F`, de modo que las barras comienzan y terminan más cerca de los puntos extremos del círculo sin llegar a cerrarse del todo.
- El hueco superior está pensado específicamente para que la línea radial de audio (y su waveform animada) pueda atravesar el nodo sin quedar tapada por las barras laterales: el módulo se sigue rotando de forma que su "arriba" local se alinee con la línea al centro, y el pequeño gap en la parte superior del anillo queda exactamente en esa dirección radial.
- En `MainComponent_Input.cpp` se ha actualizado la geometría de hit-test de los controles laterales (cálculo de `sliderTop`/`sliderBottom` y lambdas `isOnFreqControlBar`/`isOnGainControlBar`) para usar el mismo `sliderMargin = 3.0F`. Con ello, el área clicable de las barras coincide con el nuevo recorrido visual casi completo del semi-círculo, evitando desajustes entre lo que se ve y dónde responde el control al hacer click o arrastrar.

### Ajuste de grosor en barras laterales de frecuencia y volumen
- Se ha refinado la representación visual de los controles laterales en los módulos con `uses_frequency_control()` y/o `uses_gain_control()` para que resulten más finos y discretos. En `MainComponent_Paint.cpp` el trazo de la barra de frecuencia (arco izquierdo) pasa de un grosor de `7.0F` a `5.0F` tanto para el fondo atenuado como para la parte rellena que indica el valor actual, haciendo la barra 2 píxeles más delgada sin cambiar su recorrido geométrico.
- La barra de volumen/ganancia (arco derecho) reduce su grosor de trazo de `2.0F` a `1.0F`, de modo que el control lateral de nivel se percibe menos pesado visualmente y no compite con el cuerpo del módulo ni con la forma de onda que se dibuja sobre las líneas de audio.
- El handle circular del control de volumen (el "punto" que se dibuja sobre el arco derecho) se ha hecho más pequeño para reforzar esta sensación de ligereza: el diámetro pasa de `12x12` píxeles a `8x8`, manteniendo el mismo color blanco pero con un radio más contenido. Esto hace que el punto de control parezca más fino y alineado con el nuevo grosor de la barra, sin modificar en absoluto la lógica de interacción (click/drag) ni el mapeo del parámetro de ganancia.

### Corrección de artefactos visuales en extremos de la barra de frecuencia
- Se ha ajustado el pintado de la barra de frecuencia lateral para eliminar el pequeño “hueco” que aparecía en los extremos cuando el valor era exactamente 0% o 100%. El efecto se producía porque la parte rellena de la barra se calcula recortando el arco con un rectángulo vertical y, en los extremos, quedaba una franja pintada solo con el color de fondo.
- En `MainComponent_Paint.cpp` se detectan ahora explícitamente los casos `freqValue <= 0.001F` (barra vacía) y `freqValue >= 0.999F` (barra llena) y se tratan de forma distinta: si la barra está al 0%, se dibuja únicamente el arco de fondo sin ninguna pasada adicional recortada, evitando que el clipping vertical genere pequeños triángulos o fragmentos visibles; si la barra está al 100%, el arco de fondo se dibuja ya con el mismo color que la parte rellena, de modo que cualquier desajuste entre ambas capas resulte invisible.
- Con este cambio, la transición entre 0%, valores intermedios y 100% mantiene el mismo esquema de “fondo tenue + tramo relleno brillante” en los valores intermedios, pero en los extremos desaparecen los artefactos visuales producidos por la geometría de recorte vertical frente al arco curvo y por el anti-aliasing en el borde del recorte.

### Ajuste de la barra de frecuencia lateral en módulos con control de `freq`
- Se ha simplificado el control visual de frecuencia en los módulos que usan `uses_frequency_control()` (por ejemplo, Oscillator y Filter) eliminando la "bola" o handle circular que se dibujaba sobre la barra izquierda. En `MainComponent_Paint.cpp` la barra de frecuencia sigue representándose como un arco curvo pegado al lado izquierdo del nodo, pero ahora sin indicador puntual: el valor se comunica exclusivamente a través de la posición relativa sobre la barra y su waveform asociada.
- Para mejorar la legibilidad de este control y preparar su reutilización en más módulos, se ha incrementado el grosor del trazo de la barra de frecuencia: el `PathStrokeType` usado para el arco izquierdo pasa de `3.0F` a `7.0F`, manteniendo el mismo recorrido geométrico pero haciendo la barra más ancha y visible incluso sin el handle, especialmente en escenas con mucho contenido.
- Además, la barra ahora muestra explícitamente qué porcentaje está "lleno" o "vacío": se dibuja primero un arco de fondo más oscuro a lo largo de todo el recorrido y, sobre él, un tramo más brillante desde la parte inferior de la barra hasta la posición correspondiente al valor normalizado de `freq`. De este modo, el usuario puede leer de un vistazo cuánta barra está activa sin necesidad de un handle independiente.
- La lógica de input en `MainComponent_Input.cpp` se ha ajustado para que el área clicable de la barra de frecuencia crezca **solo hacia el exterior del nodo** (lado izquierdo en pantalla) y no hacia el centro del módulo. Se han separado dos lambdas de hit-test: `isOnFreqControlBar` amplía la zona de click 7 píxeles adicionales hacia la izquierda, manteniendo el margen interior igual para no invadir el área del cuerpo circular que se usa para arrastrar el módulo; `isOnGainControlBar` conserva una zona simétrica alrededor de la barra de ganancia derecha.
- El gesto de usuario sigue siendo el mismo: hacer click en cualquier punto de la barra de frecuencia mueve instantáneamente el valor a esa posición y comienza un drag continuo. Con el nuevo hit-test asimétrico, es más fácil acertar en la barra de `freq` desde el exterior de la mesa sin interferir con los clicks destinados a seleccionar y mover el módulo por su zona central. Este patrón visual y de interacción está pensado para reutilizarse en futuros módulos que compartan control lateral de frecuencia.

### LookAndFeel personalizada con fuente embebida opcional para evitar escaneo masivo de fuentes del sistema
- Se ha introducido una clase `RectaiLookAndFeel` en `core/src/RectaiLookAndFeel.{h,cpp}` que hereda de `juce::LookAndFeel_V4` y, de forma opcional, carga una tipografía TTF embebida desde disco para usarla como fuente sans-serif por defecto en toda la aplicación.
- La clase intenta localizar un archivo `rectai-default.ttf` en rutas estables relativas al binario (pensadas para el layout actual del repo): `com.reactable/Resources/rectai-default.ttf` y `resources/rectai-default.ttf`. Si encuentra el fichero, lo lee completo en memoria y crea un `juce::Typeface` con `juce::Typeface::createSystemTypefaceFor(...)`, que se instala como tipo de letra sans-serif por defecto mediante `setDefaultSansSerifTypeface(embeddedTypeface_)`.
- Este diseño permite que el binario sólo tenga que abrir un único archivo de fuente conocido en tiempo de ejecución, evitando que JUCE/fontconfig recorran todas las fuentes de `/usr/share/fonts/...` durante la inicialización para resolver la fuente por defecto. La fuente TTF concreta **no** se versiona en el repositorio (para respetar licencias externas); el usuario puede copiar la tipografía que desee a una de esas rutas con el nombre `rectai-default.ttf` para activar el comportamiento embebido.
- En `core/src/Main.cpp` se ha añadido un miembro `RectaiLookAndFeel lookAndFeel_` a `RectaiApplication`. En `initialise` se llama a `juce::LookAndFeel::setDefaultLookAndFeel(&lookAndFeel_)` antes de crear la `MainWindow`, y en `shutdown` se restaura el estado llamando a `setDefaultLookAndFeel(nullptr)` antes de destruir la ventana. De este modo, toda la UI pasa a usar la fuente embebida (cuando existe) sin cambios adicionales en el código de pintado (`MainComponent_Paint.cpp` sigue usando `g.setFont(size)` y se beneficia automáticamente de la tipografía fija).
- Si no se encuentra `rectai-default.ttf` en las rutas esperadas, `RectaiLookAndFeel` ahora fija explícitamente `"DejaVu Sans"` como nombre de fuente sans-serif por defecto mediante `setDefaultSansSerifTypefaceName("DejaVu Sans")`. Esto hace que JUCE/fontconfig resuelvan directamente esa familia ampliamente disponible en Linux a partir de las cachés del sistema, reduciendo la necesidad de escanear todo `/usr/share/fonts`. Si la creación de la `Typeface` embebida falla por cualquier motivo, también se recurre a este mismo fallback, de modo que el comportamiento resulta determinista tanto con como sin TTF embebido.

## 2025-12-15

### Centralizar la forma de onda de Oscillator en AudioModules
- La selección de la forma de onda de `OscillatorModule` se expone ahora exclusivamente a través del sistema genérico de modos (`supported_modes()` + `current_mode_index()`/`set_mode(int)`), manteniendo internamente un enum `Waveform` para el runtime de audio.
- En `MainComponent_Audio.cpp`, dentro de `timerCallback`, el índice de forma de onda que se pasa al motor (`AudioEngine::setVoiceWaveform`) se obtiene directamente de `AudioModule::current_mode_index()`, con `0` como fallback cuando el módulo no expone modos. Esto evita tener helpers específicos como `waveform_index()` y mantiene toda la información pública (id, tipo, icono, índice) centralizada en `AudioModuleMode`.

### Sincronía de transporte basada en el motor de audio

- Se introdujo un reloj global de transporte en beats dentro de `AudioEngine` (`transportBeatsInternal_` + `transportBeatsAudio_`) que se actualiza en el callback de audio a partir del BPM (`loopGlobalBpm_`) y de la `sampleRate_`. Este valor se expone al UI mediante `AudioEngine::transportBeats()`.
- `MainComponent::timerCallback` dejó de integrar los beats a partir de `dt` del `juce::Timer` y ahora deriva `transportBeats_` (parte entera) y `beatPhase_` (fracción) a partir de `audioEngine_.transportBeats()`. Los pulsos centrales (estructura `pulses_`), el índice de beat en el compás (`beatIndex_`) y el disparo de notas de Sampleplay en cada beat (`triggerSampleplayNotesOnBeat`) se basan ahora en este reloj de audio, evitando drift entre audio y visuales/sequencer.
- El runtime del Sequencer sigue calculando el índice de step de audio como `floor((transportBeats_ + beatPhase_) / (1.0/4.0)) % 16`, pero como `transportBeats_ + beatPhase_` proviene ahora del reloj del motor de audio, los steps se mantienen alineados a largo plazo con loops y pulsos.
- Los módulos de Loop pasan a usar también el transporte del motor como fuente para el cálculo de `loopBeats` (usado al realinear la posición de reproducción al cambiar de slot), manteniendo la fase de los loops acoplada al mismo reloj que el Sequencer.

### Mejora de la cola de decay en Oscillators

- El `AudioEngine` utilizaba una envolvente simple AR por voz donde, hasta ahora, el nivel de salida era `targetLevel * envAmp` y el `targetLevel` se leía directamente de `voices_[v].level` (lo que se mapea desde los parámetros `gain`/`amp` de los módulos). Cuando el Sequencer desactivaba un step y ponía `gain=0`, `targetLevel` pasaba a 0 inmediatamente, provocando que incluso en fase de release el producto fuera 0 y la cola de decay no se oyera.
- Se añadió un buffer de nivel base por voz (`voiceEnvBaseLevel_`) que captura el nivel objetivo en el momento del note-on (inicio de ataque). La envolvente avanza en base a este nivel fijo y el output se calcula ahora como `baseLevel * envAmp`. Cuando la envolvente entra en estado `Idle`, el `baseLevel` se resetea a 0.
- Con este cambio, cuando un step del Sequencer se apaga (el Oscillator pasa a `gain=0`), el motor detecta el note-off, entra en fase de release y la cola de decay se reproduce sobre el nivel capturado en el note-on, en lugar de cortarse de forma brusca.

#### Ajuste posterior: respetar el volumen en tiempo real

- El uso directo de `baseLevel * envAmp` para todas las fases de la envolvente provocaba que los cambios de volumen realizados por el usuario en la barra de volumen del Oscillator dejaran de afectar al nivel audible una vez disparada la nota (el `baseLevel` se fijaba en el note-on y no seguía a `voices_[v].level`). Visualmente las líneas de conexión seguían reflejando el volumen correcto, pero el audio permanecía a un nivel casi constante o "congelado" tras haber bajado y subido el volumen.
- En `AudioEngine::audioDeviceIOCallbackWithContext`, en la sección donde se mezcla cada voz de Oscillator, se ha cambiado el cálculo final de ganancia para combinar el nivel actual y el nivel base: ahora se lee `voices_[v].level` en cada muestra y se usa como `targetLevelNow` para la mezcla en fases de ataque/decay/sustain, de modo que el sonido sigue a la barra de volumen del usuario en tiempo real.
- Solo cuando la envolvente está en fase de `Release` y el nivel objetivo ha caído prácticamente a cero (caso típico cuando el Sequencer fuerza silencio en un step) se usa `voiceEnvBaseLevel_` como `levelForMix`. Así, las colas de decay siguen siendo audibles aunque el Sequencer haya llevado el nivel instantáneo a 0, pero el control de volumen del usuario vuelve a funcionar con normalidad durante el resto del ciclo.

### Waveforms de conexiones alineadas con el audio real

- Hasta ahora, los buffers de waveform por voz (`voicePreFilterWaveformBuffer_` y `voicePostFilterWaveformBuffer_`) y los taps de conexión (`connectionWaveformBuffers_` con `ConnectionTapSourceKind::kVoicePre/kVoicePost`) almacenaban la forma de onda cruda del oscilador (pre y post filtro) sin aplicar ni la envolvente ni el nivel de salida. Esto hacía que, visualmente, las líneas de audio (Oscillator, conexiones hacia Filter, etc.) mostrasen una señal con amplitud constante incluso cuando, en términos de audio, la envolvente había entrado en decay/release o el sustain era cero, es decir, cuando ya no debería haber sonido.
- En `AudioEngine::audioDeviceIOCallbackWithContext`, tras evaluar la envolvente y calcular el `levelForMix` efectivo (combinando el valor actual de volumen y, en caso necesario, el `voiceEnvBaseLevel_` durante la fase de release), se calculan ahora muestras por voz ya escaladas: `voiceSamplePre` (antes del filtro) y `voiceSamplePost` (después del filtro), ambos como `levelForMix * envAmp * raw`/`s`.
- Los buffers `voicePreFilterWaveformBuffer_` y `voicePostFilterWaveformBuffer_` pasan a almacenar estas señales ya moldeadas, y los taps de conexión de tipo `kVoicePre`/`kVoicePost` escriben en `connectionWaveformBuffers_` usando igualmente `voiceSamplePre`/`voiceSamplePost`. De este modo, las waveforms que se dibujan en las líneas de conexión y en los radiales de módulos reflejan la señal de audio real (incluyendo envolvente y volumen) que circula por cada conexión.
- Como consecuencia, cuando un Oscillator deja de emitir sonido (por ejemplo, tras el decay con sustain cero o cuando el Sequencer fuerza silencio y la envolvente entra en `Idle`), las waveforms asociadas a sus conexiones se aplanan y los módulos aguas abajo (p.ej. Filter) sólo muestran/suman el audio que realmente les llega, respetando también la suma de entradas múltiples.

### Radiales de módulos consumidores con suma de entradas

- Hasta este punto, los radiales de módulos consumidores de audio sin barra de volumen propia (como `FilterModule`) se basaban en un único índice de voz (`moduleVoiceIndex_`) y en los buffers `voiceWaveformsPost`, de modo que, si un módulo recibía varias entradas de audio (por ejemplo varios Oscillators y/o Sampleplay), su radial sólo reflejaba una de ellas.
- En `MainComponent_Paint.cpp`, dentro del pintado de radiales, se ha introducido un helper local `computeAggregatedIncomingWaveform` que recorre todas las `Scene::Connection` de tipo audio cuyo `to_module_id` coincide con el módulo actual, aplicando los mismos filtros que el ruteo visual (mutes, área musical y geometría activa) y usando `audioEngine_.getConnectionWaveformSnapshot` para obtener la waveform de cada conexión con tap configurado.
- Para módulos de audio sin barra de volumen explícita (p.ej. filtros y futuros FX), tanto en el modo de “hold-mute” como en el radial normal, se intenta primero dibujar la waveform agregada sumando todas las entradas activas y calculando su normalización y RMS a partir de esa suma. Sólo si no hay entradas activas o la suma resulta prácticamente silenciosa se cae de nuevo al comportamiento anterior basado en una única voz.
- De esta manera, el radial de un módulo consumidor representa ahora la **suma real** de todas las señales de audio que le llegan (Oscillator, Sampleplay, Loop, etc.), y cuando una fuente deja de emitir sonido su contribución desaparece automáticamente de la curva agregada, manteniendo la coherencia entre la propagación visual y el audio que efectivamente circula por el grafo.
 - Para que la envolvente sea realmente la que gobierna el final de la nota (y no el gating de voces en `MainComponent`), se eliminó la condición que sólo asignaba voces de generador cuando `calculatedLevel > 0`. Ahora cada cadena de generador mantiene una voz activa (dentro del presupuesto de `kMaxVoices`) incluso cuando su nivel instantáneo o el `gain` controlado por el Sequencer son 0; la voz genera señal y la envolvente AR aplica el fade-out hasta llegar a `Idle`.

### Desacoplar la resonancia (Q) del Filter de la altura visual de la waveform
- Se ha ajustado la lógica de pintado en `core/src/MainComponent_Paint.cpp` para que el parámetro de resonancia `q` del `FilterModule` deje de influir en la altura de las formas de onda que se dibujan sobre las líneas de audio. Hasta ahora, el helper local `getModuleVisualLevel` usaba `q` como factor de escala visual, de modo que al aumentar la resonancia la waveform se hacía más alta o baja independientemente del volumen real percibido, dando la sensación de que la barra de Q actuaba como un control de volumen.
- En `getModuleVisualLevel` se ha eliminado el caso específico `FilterModule` que devolvía `q` normalizado como nivel visual. A partir de este cambio, los filtros se tratan como módulos sin control de volumen dedicado a efectos de visualización: la altura de la waveform en sus líneas radiales y conexiones se determina únicamente por la señal de audio normalizada procedente del motor (`voiceWaveformBuffer_` y `sampleplayWaveformBuffer_`), sin ningún escalado extra ligado a la resonancia.
- El resto de módulos mantienen su comportamiento anterior: `VolumeModule` sigue usando el parámetro `volume`, los módulos `Sampleplay`, `Loop` e `Input` usan `amp` como nivel principal, los osciladores (`OscillatorModule`) usan `gain`, y el fallback genérico para módulos con `uses_gain_control()` verdadero continúa leyendo `gain` cuando existe. Con ello, solo las barras laterales que representan realmente un volumen (volume/amp/gain) afectan a la altura de la waveform; las barras reutilizadas para otros parámetros (como Q en filtros) ya no alteran la percepción visual de loudness en las líneas de audio.

### Altura de waveform basada en RMS para módulos sin barra de volumen
- Se ha incorporado un cálculo de RMS real sobre los snapshots de audio que ya se obtenían del `AudioEngine` en `core/src/MainComponent_Paint.cpp`. Para cada voz procedimental (`getVoiceWaveformSnapshot`) se calcula ahora la media cuadrática de los últimos `kWaveformPoints` samples (`voiceRms[]`), y de forma análoga se calcula un `sampleplayRms` a partir del buffer dedicado a Sampleplay (`getSampleplayWaveformSnapshot`). Ambos valores se derivan directamente de la señal de audio renderizada, sin depender de parámetros de módulo.
- En la sección de pintado de líneas radiales módulo→centro, se distingue entre módulos con barra de volumen explícita (Volume, Oscillator, Sampleplay, Loop, Input) y el resto. Para los primeros, la altura de la waveform sigue escalándose únicamente con su parámetro de nivel (`volume`, `gain`, `amp`), manteniendo la semántica de que la barra derecha controla visualmente el “volumen” del módulo.
- Para módulos que no tienen una barra de volumen real (por ejemplo, Filter, Delay, Modulator, WaveShaper, Output), la altura de la waveform radial se deriva ahora de la RMS del audio asociado a su voz (`voiceRms[voiceIndex]`). El valor RMS se normaliza frente a una senoide a nivel máximo (~0.707) y se clampa a `[0,1]`, de modo que cuando el módulo atenúa o realza la señal, la línea de sonido se hace más baja o más alta en proporción a la energía real que está saliendo por esa voz.
- Con esta combinación, los módulos con control de volumen dedicado siguen comunicando su nivel principalmente a través de la barra lateral y de la escala de waveform basada en parámetros, mientras que los módulos “sin barra de volumen” ajustan la altura de su waveform automáticamente según el nivel RMS del audio que procesan, cumpliendo el requisito de que la altura refleje el sonido correspondiente cuando no hay un control de volumen explícito.

### Límite de una conexión dinámica por módulo y priorización de filtros cercanos
- Se ha extendido el modelo de escena en `core/src/core/Scene.{h,cpp}` para imponer que cada módulo solo pueda tener **una conexión saliente dinámica (no-hardlink) hacia otros módulos**, permitiendo a la vez una conexión adicional no-hardlink hacia el master `Output` (-1). La estructura `Connection` ya distinguía conexiones marcadas como `is_hardlink`; ahora, en `Scene::AddConnection`, antes de insertar una nueva conexión no-hardlink **con `to_module_id != "-1"`** se comprueba si ya existe otra conexión saliente no-hardlink desde el mismo `from_module_id` hacia un destino distinto de `-1`. Si la hay, la petición se rechaza. Las conexiones de tipo hardlink no cuentan para este límite, y las rutas implícitas módulo→Output(-1) tampoco consumen ese “slot” dinámico, de modo que un Oscillator puede tener simultáneamente `Osc → FilterMásCercano` y `Osc → Output(-1)`.
- Los módulos de tipo `OutputModule` no se ven afectados en la práctica por esta restricción, ya que el modelo actual solo crea conexiones **hacia** Output (como destino) y nunca lo usa como origen de conexiones salientes dinámicas. En particular, las auto-conexiones `Delay → Output` generadas a partir de `<hardlink to="-1" />` en el loader siguen funcionando ya que son hardlinks y no consumen el único “slot” dinámico.
- En `tests/scene_tests.cpp` se ha añadido un caso de prueba que construye un `Scene` con un `OscillatorModule` y dos `FilterModule` y verifica que:
  - La primera conexión dinámica `osc1/out → filter1/in` se acepta correctamente.
  - Una segunda conexión dinámica `osc1/out → filter2/in` se rechaza por el límite de **una conexión no-hardlink saliente**.
  - Aun así, se pueden añadir dos conexiones adicionales marcadas como hardlink desde `osc1` a ambos filtros, coexistiendo sin problema con la conexión dinámica única.

### Auto-wiring de Oscillator al Filter más cercano y compatibilidad con Output
- Se ha modificado el loader de patches Reactable en `core/src/core/ReactableRtpLoader.cpp` para que, tras crear módulos y objetos y derivar las conexiones de tipo hardlink, recorra la escena buscando parejas `OscillatorModule`–`FilterModule` y auto-conecte cada oscilador al filtro **geométricamente más cercano**.
- Para ello se construye un mapa auxiliar `module_to_object` que asocia `module_id` con su `ObjectInstance` correspondiente (usando `logical_id`), y se recopilan todos los filtros presentes en la escena. Para cada osc se localiza su objeto en la mesa y se calcula la distancia al cuadrado a cada filtro mediante las coordenadas normalizadas `(x, y)` de `ObjectInstance`. Entre todos los filtros que además cumplen `osc->CanConnectTo(*filter)` se escoge el de menor distancia y se intenta crear una conexión `osc/out → filter/in` no-hardlink a través de `Scene::AddConnection`.
- El uso de `Scene::AddConnection` garantiza que se respeten automáticamente tanto el límite de **una conexión dinámica saliente por módulo** como la prohibición de conexiones con controladores globales (`is_global_controller`). Si un Oscillator ya tiene una conexión dinámica (por ejemplo por una futura interacción de UI), el auto-wiring al filtro más cercano se descartará, y viceversa.
- Después de este nuevo paso de auto-wiring Osc→Filter, se ejecuta la lógica existente que conecta automáticamente todos los módulos de audio compatibles con el master `Output` (-1). Gracias al nuevo límite per-módulo, la topología resultante en un patch con `Oscillator + 2 Filter + Output` es:
  - `Oscillator → FilterMásCercano` como única conexión dinámica saliente del oscilador.
  - Cada `FilterModule` se auto-conecta a `Output` con su propia conexión dinámica `Filter → -1`, ya que no tiene conexiones salientes previas.
  - El `Oscillator` ya no se conecta directamente a Output cuando existe al menos un filtro elegible, de forma que su ruta hacia el master pasa siempre por el filtro más cercano.

### Ajuste de tests para topologías más flexibles en default.rtp
- El test de `tests/scene_tests.cpp` que validaba la carga del patch por defecto `default.rtp` asumía que, tras el auto-wiring, existía siempre una conexión directa `Oscillator (46) → Output (-1)` y lo comprobaba de forma explícita. Dado que la nueva lógica puede preferir auto-conectar el Oscillator a un Filter intermedio (cuando estén presentes en el patch) y dejar que sea ese filtro quien se conecte al master, el test se ha relajado.
- Ahora el caso de prueba sigue comprobando la presencia de los módulos esperados (Output, Volume, Tempo, Oscillator) y la normalización correcta del parámetro `volume` del módulo `Volume`, pero en lugar de exigir una conexión **directa** `46 → -1`, simplemente verifica que `Scene::connections()` no esté vacío tras cargar `default.rtp`. Esto permite que el ruteo real se materialice como `Oscillator → Filter → Output` o como `Oscillator → Output` según el contenido del patch, sin romper la suite de tests al introducir nuevas heurísticas de auto-wiring.

### Activación del módulo Output (-1) como Master conectable
- Se ha extendido el loader de patches Reactable en `core/src/core/ReactableRtpLoader.cpp` para que, tras crear módulos y objetos a partir de los `<tangible>`, busque el tangible `Output` con id `-1` (master de la mesa) y lo trate como un módulo de salida real en el modelo de dominio (`OutputModule` con id "-1").
- Después de derivar las conexiones a partir de los `<hardlink>` de los `DelayModule`, el loader recorre todos los módulos de la escena y, para cada módulo de audio que pueda conectar hacia `Output` según `AudioModule::CanConnectTo` (es decir, que produzca audio y no sea un controlador global como `Volume`, `Tempo` o `Tonalizer`), intenta crear una `Connection` estándar `from=module_id/out` → `to="-1"/in` marcada como no-hardlink. `Scene::AddConnection` filtra duplicados, por lo que si ya existía un hardlink explícito hacia `-1` no se añade una segunda conexión redundante.
- De este modo, en cualquier patch `.rtp` que incluya el tangible `Output` con id `-1`, todos los módulos que emiten audio quedan explícitamente conectados al master en `Scene::connections`, preparando el grafo de ruteo para futuras fases del motor de audio sin exigir que el usuario manipule un tangible de Output visible.

### Preservación del comportamiento visual de la línea centro→módulo
- Para evitar que estas nuevas conexiones automáticas hacia `Output` alteren la lógica de las líneas radiales centro→módulo, se han ajustado los recorridos de conexiones en `MainComponent_Paint.cpp` y `MainComponent_Input.cpp` que calculan `objectsWithOutgoingActiveConnection` y detectan si un generador está "alimentando" otro módulo. Ahora se ignoran explícitamente las conexiones cuyo `to_module_id` es "-1" al construir ese conjunto.
- Gracias a este filtro, las líneas radiales desde los generadores al centro de la mesa siguen ocultándose únicamente cuando el generador está enviando señal a otro módulo visible (por ejemplo, `Oscillator → Filter`), pero no cuando solo existe la conexión implícita `Oscillator → Output`. Las auto-conexiones al master quedan, por tanto, invisibles a efectos de esta heurística y la UI conserva exactamente el mismo comportamiento visual que antes en lo referente a qué módulos muestran línea directa hacia el centro.
- La lógica de input que replica estas reglas para hit-testing y gestos de corte sobre las líneas centro→módulo también se ha actualizado para ignorar las conexiones con destino "-1", de forma que las auto-conexiones al master no se puedan seleccionar ni mutear por accidente a través de los gestos de corte pensados para líneas entre módulos visibles.

### Test de auto-conexión a Output en el modelo de escena
- En `tests/scene_tests.cpp` se ha añadido un caso de prueba que carga un patch mínimo con dos tangibles: un `Output` de id `-1` y un `Oscillator` de id `46`. Tras invocar `LoadReactablePatchFromString`, el test comprueba que la escena resultante contiene exactamente dos módulos, dos objetos y **una** conexión no-hardlink de `46/out` hacia `-1/in`.
- Este test complementa el ya existente que valida la creación de conexiones de tipo hardlink desde un `Delay` hacia `Output` a partir de etiquetas `<hardlink to="-1" />`, asegurando que ambos mecanismos coexisten correctamente (el loader no duplica conexiones cuando ya hay un hardlink y la auto-conexión solo añade rutas cuando no existían previamente).

### Redefinición del modelo de mute sólo a nivel de conexión
- Se ha simplificado el modelo de mute eliminando por completo el estado de mute por objeto y por módulo (`mutedObjects_` y `modulesWithPersistentMute_`) de `MainComponent`. A partir de ahora, `mutedConnections_` es la **única** fuente de verdad sobre qué rutas están silenciadas.
- La ruta al master se modela explícitamente como la conexión implícita módulo → Output (-1) que el loader crea para todos los módulos de audio no globales. Mutear la radial centro→módulo en la UI equivale a mutear esa conexión módulo→`-1` concreta dentro de `mutedConnections_`.
- En `MainComponent_Audio.cpp`:
  - El cálculo de `sampleplayOutputGain` ya no consulta `mutedObjects_`; en su lugar, considera silenciado el path global de Sampleplay cuando **todas** las conexiones Sampleplay → `-1` están muteadas en `mutedConnections_`. Si existe al menos un Sampleplay con ruta al master no muteada, el gain sigue al volumen global.
  - Para generadores, `srcMuted` se deriva ahora comprobando si todas las conexiones desde el módulo a Output (-1) están muteadas. Esto hace que mutear la radial sea exactamente lo mismo que cortar la salida de ese generador hacia el master.
  - El flag `connectionMuted` para la cadena generador → módulo aguas abajo se calcula únicamente a partir de `mutedConnections_` (se ha eliminado cualquier dependencia de mute persistente por módulo). El `chainMuted` final combina sólo el mute de origen (`srcMuted`) y el mute de la conexión a ese downstream.
  - `modulesWithActiveAudio_` se actualiza sin consultar estado de mute persistente: si la cadena genera audio (aunque acabe silenciada al master) se sigue usando para poder dibujar waveform, y sólo se omite la marca de “activo” en el módulo destino cuando la conexión está muteada.
- En `MainComponent_Paint.cpp`:
  - Las líneas radiales ya no consultan `mutedObjects_` ni `modulesWithPersistentMute_`. El estado visual de mute (línea continua vs discontinua, presencia de waveform) se deduce sólo de si la conexión implícita módulo → `-1` correspondiente está en `mutedConnections_`.
  - Las conexiones módulo→módulo usan exclusivamente `mutedConnections_` para decidir si se dibujan como activas (con waveform) o muteadas (línea discontinua / sin waveform), tanto en la parte central de la mesa como en gestos de hold/cut.
  - El color del cuerpo de los módulos (en la mesa y en el dock) se calcula ahora comprobando si su conexión módulo → `-1` está muteada: si todas las rutas al master están muteadas, el nodo se pinta con el esquema de “muteado”; si al menos una ruta al master está activa, se usa el esquema normal.
- En `MainComponent_Input.cpp`:
  - Los gestos de click-and-hold en líneas sólo mantienen un estado visual temporal (`activeConnectionHold_`) sin tocar el estado de mute persistente; al soltar el ratón se limpia el hold sin modificar `mutedConnections_`. Para líneas módulo→módulo, el mute efectivo durante el hold se aplica exclusivamente en `timerCallback()` comprobando `activeConnectionHold_`, sin insertar ni borrar claves en `mutedConnections_`.
  - Cortar una radial centro→módulo se interpreta como “toggle” sobre la conexión implícita módulo → `-1`: se localiza dicha conexión en `Scene::connections()` y se añade o elimina su clave en `mutedConnections_`.
  - Cortar una línea módulo→módulo sólo hace toggle del estado de mute de **esa** conexión (`makeConnectionKey(conn)`), sin marcar ni recordar mute a nivel de módulo aunque sea la única conexión saliente.
- Con este cambio, todas las decisiones de audio y UI relacionadas con mute se pueden razonar exclusivamente en términos de conexiones concretas (`Connection { from, to, ... }`), y el comportamiento se mantiene coherente entre cadena de audio (silencio) y representación visual (líneas y cuerpos atenuados / con waveform).

### Sincronización del estado de mute al des-silenciar la radial
- Se ha ajustado el manejo de gestos de corte sobre la radial centro→módulo en `MainComponent_Input.cpp` para cubrir un caso sutil en el que el estado de mute “persistente” de una única conexión módulo→módulo podía reaparecer de forma inesperada al reconectar módulos.
- Cuando el usuario corta una línea módulo→módulo que es la **única** conexión saliente activa de un módulo (ignorando la auto-conexión implícita al master), la lógica ya existente espelaba ese mute sobre la conexión módulo→Output (-1), de forma que, si más tarde se desconectaba el módulo destino (sacándolo del cono/área musical), el módulo seguía efectivamente silenciado al quedar solo la ruta al master.
- El nuevo comportamiento define que, si más tarde el usuario des-silencia explícitamente la radial (toggle sobre módulo→`-1`) en una situación en la que **no queda ninguna conexión módulo→módulo activa** desde ese módulo, entonces se interpreta que el usuario quiere restablecer el estado “no muteado” global del módulo como fuente.
- Para implementarlo, tras des-silenciar la conexión implícita módulo→`-1` se recorren todas las claves actualmente almacenadas en `mutedConnections_` y se eliminan aquellas cuyo prefijo coincide con `moduleId + ":"` (es decir, todas las rutas cuyo `from_module_id` es ese módulo, tanto al master como a otros módulos). Esto garantiza que cualquier estado de mute previo asociado al generador queda completamente borrado, incluso si las conexiones que lo originaron ya no están presentes en `Scene::connections()`.
- Con este ajuste, el flujo
  - Osc→Master,
  - Osc→Filter,
  - mute de Osc→Filter (que también mutea Osc→Master al ser la única conexión activa),
  - desplazamiento de Filter fuera del cono (queda sólo Osc→Master),
  - des-silenciado de Osc→Master,
  - reconexión Osc→Filter,
  vuelve a producir una línea Osc→Filter **no muteada**, ya que el des-silenciado explícito de la radial limpia todo el historial de mute asociado a ese Oscillator.

### Mute aguas abajo: Filter silenciado bloquea todos los generadores conectados
- Se ha corregido el caso en el que varios `OscillatorModule` alimentan un mismo `FilterModule` y el usuario silencia la radial de ese filtro (conexión `Filter -> "-1"`), pero se seguía escuchando el sonido directo de los osciladores.
- En el bucle de ruteo de generadores de `MainComponent_Audio.cpp`, tras seleccionar un `downstreamModule` (por ejemplo, un Filter), se calcula ahora explícitamente si ese módulo aguas abajo está completamente muteado hacia el master (`downstreamMutedToMaster`) comprobando sus conexiones `from=downstream.id()` → `to="-1"` en `mutedConnections_`.
- El flag `chainMuted` pasa a ser la disyunción de tres condiciones: `srcMuted` (mute en la radial del generador), `connectionMuted` (mute explícito en la conexión generador→módulo) y `downstreamMutedToMaster` (mute en la radial del módulo aguas abajo). Si cualquiera de ellas es cierta, el nivel de salida de la voz se fuerza a 0.
- Esto garantiza que en una configuración como `Osc1 → Filter`, `Osc2 → Filter`, `Filter → Master`, al silenciar la radial de Filter toda la cadena queda efectivamente en silencio: no se escucha ningún oscilador aunque sus propias radiales no estén muteadas individualmente, porque todo el audio debe atravesar el Filter para llegar al master.
- Para la capa visual, en cambio, se introduce un flag `visualChainMuted = srcMuted || connectionMuted` y se usa exclusivamente éste para rellenar `modulesWithActiveAudio_` y `moduleVoiceIndex_`. De este modo, un mute sólo en la radial del módulo aguas abajo (Filter→Master) **no** impide que la conexión Osc→Filter se dibuje con waveform: el usuario sigue viendo que los Oscillators envían audio al Filter, aunque el corte de la cadena se produzca en la salida del propio Filter hacia el master.

### Selección dinámica del Filter más cercano en runtime y audio por múltiples rutas (incluyendo hardlinks)
- En `MainComponent_Audio.cpp` se ha especializado la creación de conexiones dinámicas para los módulos de tipo generador (`ModuleType::kGenerator`). El bloque genérico de "Dynamic connection creation" sigue creando conexiones espaciales para el resto de módulos, pero ahora omite explícitamente cualquier par donde intervenga un generador. A continuación, una pasada específica recorre cada generador dentro del área musical, examina todos los módulos vecinos compatibles según `AudioModule::CanConnectTo`, respeta el cono geométrico `isConnectionGeometricallyActive` y selecciona como destino dinámico el módulo más cercano, **priorizando siempre los `FilterModule` frente a otros tipos**. Antes de añadir la nueva conexión `gen/out → dst/in` se eliminan las conexiones dinámicas previas salientes de ese generador (no-hardlink y distintas de `to="-1"`), de forma que se mantiene el invariante de "una sola conexión dinámica saliente" mientras el grafo se reconfigura automáticamente cuando el usuario mueve los tangibles.
- Esta misma lógica de selección dinámica se aplica tanto a las conexiones auto-generadas desde el loader (`ReactableRtpLoader`, que crea inicialmente `Osc → FilterMásCercano`) como a las conexiones creadas en runtime por disposición espacial: cuando un Filter sale del área musical o abandonan el cono del Oscillator, su conexión dinámica deja de ser candidata y en el siguiente tick el generador se reconecta, si es posible, al siguiente módulo compatible más cercano (típicamente otro `FilterModule`). Las conexiones de tipo hardlink (`is_hardlink=true`) nunca se tocan en esta pasada y pueden coexistir libremente con la ruta dinámica única.
- El ruteo de audio por generador en `MainComponent_Audio.cpp` también se ha reestructurado para recorrer **todas** las conexiones salientes desde cada generador (ignorando sólo las implícitas a Output `to="-1"`) y construir un vector de rutas `GeneratorRoute`. Cada ruta representa un módulo aguas abajo concreto (Filter, Sampleplay, Delay, etc.), respeta área musical, cono geométrico para dinámicas y estado de mute por conexión, y se traduce a una voz independiente en el `AudioEngine`. De este modo, si un Oscillator tiene a la vez una conexión dinámica `Osc → Filter1` y un hardlink `Osc → Filter2`, el audio se envía en paralelo por ambas cadenas (dos voces con su propio filtro/Q), cumpliendo el requisito de que "si existe conexión (dinámica o hardlink), el audio se envía por ella". El cálculo de mute por cadena (`srcMuted`, mute de conexión y mute en la radial del módulo destino) y la configuración de filtros por voz se aplican ahora por ruta individual, manteniendo la semántica previa pero extendida a múltiples destinos simultáneos.
 - El ruteo de audio por generador en `MainComponent_Audio.cpp` también se ha reestructurado para recorrer **todas** las conexiones salientes desde cada generador (ignorando sólo las implícitas a Output `to="-1"`) y construir un vector de rutas `GeneratorRoute`. Cada ruta representa un módulo aguas abajo concreto (Filter, Sampleplay, Delay, etc.), respeta área musical, cono geométrico para dinámicas y estado de mute por conexión, y se traduce a una voz independiente en el `AudioEngine`. De este modo, si un Oscillator tiene a la vez una conexión dinámica `Osc → Filter1` y uno o varios hardlinks `Osc → Filter2`, el audio se envía en paralelo por todas las cadenas (una voz por ruta con su propio filtro/Q), cumpliendo el requisito de que "si existe conexión (dinámica o hardlink), el audio se envía por ella". El cálculo de mute por cadena (`srcMuted`, mute de conexión y mute en la radial del módulo destino) y la configuración de filtros por voz se aplican ahora por ruta individual, manteniendo la semántica previa pero extendida a múltiples destinos simultáneos.
 - Para el resto de módulos no generadores, la heurística genérica de "Dynamic connection creation" ya no crea conexiones dinámicas de forma codiciosa para **todas** las parejas posibles. En su lugar, construye una tabla interna de puntuación (`bestByFrom`) donde cada módulo origen acumula sólo su candidato mejor valorado: para cada par de objetos dentro del área musical que cumpla `CanConnectTo` y pase el cono geométrico, se asigna una puntuación inversamente proporcional a la distancia entre ambos tangibles (módulos más cercanos → puntuación más alta). Tras evaluar todas las parejas, únicamente se materializa la conexión con mejor puntuación por módulo origen llamando a `Scene::AddConnection`, dejando que esta última aplique las invariantes globales (máx. una conexión dinámica saliente, no duplicar conexiones, exclusión explícita de rutas hacia el Output `-1`, etc.). Esto hace que, en escenas con varios módulos elegibles alrededor de un mismo origen, la conexión dinámica resultante siempre favorezca al vecino más cercano dentro del cono.

### Fuentes de ruteo dinámico ampliadas (no solo generadores)
- En `MainComponent_Audio.cpp`, la pasada específica de "Generator dynamic connections" que reescritía la única conexión dinámica saliente de cada generador para apuntar siempre al módulo compatible más cercano (priorizando `FilterModule`) se ha generalizado para que pueda actuar sobre **cualquier módulo que no sea de tipo `ModuleType::kSettings`**.
- En lugar de comprobar explícitamente `srcModule->type() == ModuleType::kGenerator` o casos especiales como `SampleplayModule`, la condición de entrada de esta pasada filtra únicamente los módulos de ajustes globales (`kSettings`) y deja que el resto de tipos (generadores, módulos de audio, FX, etc.) puedan participar en el ruteo dinámico siempre que `AudioModule::CanConnectTo` lo permita.
- El bucle sigue calculando, para cada módulo origen con tangible dentro del área musical, el mejor destino aguas abajo (`bestModule`) entre todos los objetos vecinos que cumplan: estar dentro del área musical, no ser el Output `"-1"` ni un controlador global (`is_global_controller()`), respetar `CanConnectTo` y el cono geométrico `isConnectionGeometricallyActive`. Entre varios candidatos, se priorizan primero los de tipo `kFilter` y, a igualdad de tipo, el de menor distancia.
- Una vez elegido `bestModule`, se consultan las conexiones no-hardlink existentes desde ese origen (excluyendo rutas a `"-1"`) a través de `dynamicByFrom`. Si ya existe una conexión dinámica estándar `out → in` hacia `bestModule`, se conserva tal cual; en caso contrario, se eliminan todas las conexiones dinámicas salientes previas de ese módulo origen y se crea una nueva `Connection { from = srcModule->id(), from_port_name = "out", to = bestModuleId, to_port_name = "in", is_hardlink = false }` usando `Scene::AddConnection`.
- Al actuar solo sobre conexiones no-hardlink y dejar intactas las hardlinks, esta ampliación mantiene el invariante de "una sola conexión dinámica saliente" por módulo (más la posible ruta extra hacia Output `-1`) pero permite que módulos como `Sampleplay` o ciertos FX sigan las mismas reglas de ruteo espacial que los generadores clásicos, siempre que sus políticas de conexión las consideren válidas.

### Ocultar la radial de Sampleplay cuando alimenta otros módulos
- En `MainComponent_Paint.cpp` se ha ajustado la heurística que decide cuándo dibujar la línea radial centro→módulo para que `SampleplayModule` se comporte igual que los generadores clásicos (`ModuleType::kGenerator`) a efectos visuales.
- Antes, solo los módulos de tipo generador ocultaban su radial cuando tenían una conexión saliente activa hacia otro módulo (por ejemplo, `Oscillator → Filter`); los módulos de tipo audio como `Sampleplay` seguían mostrando siempre su línea directa al master incluso cuando alimentaban un `Filter`, lo que producía dos líneas de audio visibles desde el mismo módulo: `Sampleplay → Master` y `Sampleplay → Filter`.
- Ahora se introduce un flag `isGeneratorLike` que es verdadero tanto para módulos `ModuleType::kGenerator` como para `SampleplayModule`. Cuando `isGeneratorLike` es cierto y el objeto correspondiente aparece en `objectsWithOutgoingActiveConnection` (es decir, existe al menos una conexión de audio activa hacia otro módulo dentro del área musical), la radial centro→módulo se omite en el pintado.
- El resultado es que, en configuraciones `Sampleplay → Filter → Master`, la UI muestra una única ruta visual desde Sampleplay: la conexión `Sampleplay → Filter` con waveform propio (alimentada desde el buffer global de Sampleplay) y la radial `Filter → Master`. La línea directa `Sampleplay → Master` deja de dibujarse mientras exista la conexión activa al filtro, cumpliendo la regla de "una sola conexión dinámica visible" y evitando la confusión de ver dos soundwaves simultáneos saliendo del mismo Sampleplay.

### Filtro aplicado al path global de Sampleplay y visuales coherentes con Filter
- Se ha extendido `AudioEngine` (`AudioEngine.h/.cpp`) para que el path estéreo de Sampleplay (SoundFont) pueda pasar por un filtro dedicado basado en `juce::dsp::StateVariableTPTFilter`. Se añaden dos instancias mono `sampleplayFilterL_`/`sampleplayFilterR_` y un pequeño estado atómico (`sampleplayFilterMode_`, `sampleplayFilterCutoffHz_`, `sampleplayFilterQ_`) que controlan tipo, frecuencia de corte y resonancia de este filtro global.
- El callback `audioDeviceIOCallbackWithContext` ahora, tras aplicar el `sampleplayOutputGain`, puede procesar los buffers `sampleplayLeft_`/`sampleplayRight_` a través de estos filtros cuando `sampleplayFilterMode_ != 0`, de manera que el audio de Sampleplay se ve afectado por el filtro antes de mezclarse con las voces de oscilador y antes de actualizar los historiales de waveform y los taps por conexión de tipo `kSampleplay`.
- Se ha añadido el método público `AudioEngine::setSampleplayFilter(int mode, double cutoffHz, float q)` que clampa los parámetros, respeta Nyquist (cutoff < fs/2) y configura tipo/cutoff/Q en ambos filtros de Sampleplay. La API refleja la de `setVoiceFilter` para generadores: modo 0 = bypass, 1 = low-pass, 2 = band-pass, 3 = high-pass.
- En `MainComponent_Audio.cpp`, dentro de `timerCallback`, tras calcular `sampleplayOutputGain` y reconstruir el grafo de audio, se escanean los `audio_edges()` en busca de conexiones `Sampleplay → Filter` activas (módulos dentro del área musical, respeta cono geométrico para dinámicas y sin mute de conexión). Entre todas las parejas Sampleplay–Filter elegibles se elige el filtro más cercano en términos de distancia en la mesa y se mapean sus parámetros (`freq`, `q`, `mode`) a una llamada a `audioEngine_.setSampleplayFilter(...)`. Si no hay ningún filtro elegible, el modo se deja en 0 (bypass).
- Con este cambio, siempre que exista una conexión `Sampleplay → Filter` activa, el audio del SoundFont se procesa a través del filtro correspondiente antes de llegar al master, cumpliendo la regla de que "el efecto Filtro debe aplicarse siempre que el módulo esté conectado" incluso en escenas sin osciladores.
- En la capa de pintado (`MainComponent_Paint.cpp`), las conexiones que implican Sampleplay dejan de depender de `modulesWithActiveAudio_` para decidir si llevan audio: `audioConn` se considera verdadero para conexiones Sampleplay siempre que no estén muteadas, lo que garantiza que la línea `Sampleplay → Filter` muestre waveform mientras haya señal en el buffer de Sampleplay.
- Además, para las radiales de módulos `Filter`, se detecta si el filtro está siendo alimentado directamente por un Sampleplay mediante una conexión de audio activa `Sampleplay → Filter` (dentro del área musical, respetando cono y no muteada). En ese caso, y cuando hay energía en `sampleplayWaveform`, la radial `Filter → Master` reutiliza la waveform de Sampleplay para dibujar su soundwave, de modo que en una cadena `Sampleplay → Filter → Master` sin osciladores se ven ondas tanto en la conexión Sampleplay→Filter como en la radial del Filter hacia el master, alineadas con el audio realmente procesado por el filtro.

### Waveform de Sampleplay unificada vía taps por conexión
- Se ha simplificado la gestión de historiales de waveform de Sampleplay en `AudioEngine` eliminando los buffers globales `sampleplayWaveformBuffer_` y `sampleplayFilteredWaveformBuffer_` y sus helpers `getSampleplayWaveformSnapshot(...)` / `getSampleplayFilteredWaveformSnapshot(...)`. A partir de ahora, la única fuente de verdad para las waveforms de Sampleplay son los taps por conexión (`connectionWaveformBuffers_` con `ConnectionTapSourceKind::kSampleplay`), alimentados directamente desde la señal mono pre‑filtro (`rawSampleplayL`).
- El callback de audio sigue escribiendo en los taps de tipo `kSampleplay` para todas las conexiones de audio que involucren a Sampleplay (por ejemplo `Sampleplay → Master` y `Sampleplay → Filter`), pero deja de mantener un segundo historial global duplicado. Esto reduce complejidad en el motor y evita divergencias entre buffers al depurar problemas visuales.
- En `MainComponent_Paint.cpp`, tanto las conexiones que involucran Sampleplay como las radiales afectadas pasan a leer **siempre** desde `audioEngine_.getConnectionWaveformSnapshot(connKey, ...)`. En las ramas de pintado de conexiones se ha eliminado el camino especial que copiaba `sampleplayWaveformRaw` a un buffer temporal: ahora todas las conexiones de audio, incluidas las de Sampleplay, normalizan su waveform a partir del snapshot por conexión y solo cambian el modo `tiled` (no periodo repetido para Sampleplay).
- Para las radiales se ha alineado la lógica con estas taps: las radiales `Sampleplay → Master` buscan la conexión de audio `Sampleplay → "-1"` no muteada y usan su snapshot como waveform; las radiales de `Filter` con Sampleplay aguas arriba reutilizan la misma tap de la conexión `Sampleplay → Filter`. De este modo, en una cadena `Sampleplay → Master` y `Sampleplay → Filter → Master` todas las líneas que representan la señal de Sampleplay comparten la misma waveform subyacente (pre‑filtro), eliminando el efecto anterior de ver dos soundwaves distintas para rutas lógicamente equivalentes.
- Esta unificación deja el filtro global de Sampleplay (`setSampleplayFilter`) actuando solo sobre el audio real mezclado (a través de `sampleplayFilterL_/R_`), sin mantener un historial de waveform separado para la señal ya filtrada. Si en el futuro se necesita visualizar explícitamente la salida filtrada, se hará añadiendo taps específicos a las conexiones relevantes en lugar de introducir buffers globales adicionales.

### Grafo lógico de audio (`AudioGraph`) – Fase 2 (parcial)
- Se ha introducido la clase `rectai::AudioGraph` en `core/src/core/AudioGraph.{h,cpp}` como representación lógica del grafo de audio derivado de `Scene`. El grafo modela cada `AudioModule` como un nodo (`Node` con `id`, `ModuleType` y flags de capacidades `produces_audio`/`consumes_audio`/`produces_midi`/`consumes_midi`/`is_global_controller`) y cada `Connection` como una arista dirigida (`Edge` con ids de módulo y nombres de puerto, flag `is_hardlink` y un `PortSignalKind` efectivo).
- La función `AudioGraph::RebuildFromScene(const Scene&)` recorre `Scene::modules()` para poblar el mapa interno de nodos (`nodes_`) y `Scene::connections()` para poblar el vector de aristas (`edges_`). El tipo de señal (`signal_kind`) se infiere en primer lugar a partir de los puertos del módulo origen (buscando coincidencia de `from_port_name` en `output_ports()`), y en segundo lugar de los puertos del módulo destino (`to_port_name` en `input_ports()`). Si no se encuentra coincidencia pero el módulo origen produce audio (`produces_audio()`), se asume `PortSignalKind::kAudio` como valor por defecto conservador.
- Se ha añadido el helper `std::vector<Edge> AudioGraph::audio_edges() const` que filtra `edges_` devolviendo solo las aristas cuyo `signal_kind == PortSignalKind::kAudio`. Este método servirá como base para futuras fases donde se necesiten recorridos rápidos sólo sobre el subgrafo de audio (por ejemplo, para crear taps o buffers por conexión en el motor de audio).
- `MainComponent` incluye ahora un miembro `rectai::AudioGraph audioGraph_` y llama a `audioGraph_.RebuildFromScene(scene_)` al inicio de `timerCallback()`. Con ello se mantiene un grafo lógico de audio siempre sincronizado con la `Scene`, listo para ser consultado por capas posteriores (motor de audio y/o lógica de visualización) sin necesidad de re-derivar nodos y aristas a partir de los módulos y conexiones crudos.
- Como parte de este cambio se han traducido al inglés todos los comentarios de los nuevos archivos de grafo (`AudioGraph.h/.cpp`) y se han unificado también algunos comentarios existentes en `MainComponent.h` relacionados con mute por conexión y fuentes visuales, manteniendo la convención del proyecto de código y comentarios en inglés mientras la documentación permanece en español.

### Buffers físicos por conexión en el motor de audio – Fase 3 (primer paso)
- Se ha extendido `AudioEngine` (`core/src/AudioEngine.{h,cpp}`) con una infraestructura básica de **taps por conexión**: se introduce la constante `kMaxConnectionTaps` (64 taps simultáneos), una estructura `ConnectionTap` interna y un array `connectionWaveformBuffers_[kMaxConnectionTaps][kWaveformHistorySize]` que mantiene un historial mono de waveform para cada conexión de audio que se desee monitorizar. Todos estos historiales comparten el índice global `waveformWriteIndex_`, de modo que quedan temporalmente alineados con el mix global y los buffers por voz ya existentes.
- La API pública del motor incorpora ahora:
  - `enum class ConnectionTapSourceKind { kNone, kVoicePre, kVoicePost, kSampleplay }`, que modela el tipo de fuente de señal de bajo nivel que se observa en cada tap.
  - `clearAllConnectionWaveformTaps()`, que borra la configuración de taps activos y resetea sus metadatos sin tocar el historial global.
  - `configureConnectionWaveformTap(const std::string& key, ConnectionTapSourceKind kind, int voiceIndex)`, que asocia una clave lógica de conexión (la misma que usa la UI/Scene) a una fuente de señal concreta: pre-filtro de una voz (`VoicePre`), post-filtro (`VoicePost`) o la ruta mono de Sampleplay (`Sampleplay`). Las llamadas repetidas con la misma clave actualizan la configuración del tap; claves nuevas van reservando entradas hasta un máximo de `kMaxConnectionTaps`.
  - `getConnectionWaveformSnapshot(const std::string& key, float* dst, int numPoints, double windowSeconds)`, que devuelve un snapshot downsampleado del historial de waveform para la conexión indicada, reutilizando la misma lógica de ventana y muestreo que `getWaveformSnapshot` y las APIs por voz. Si no hay tap configurado para esa clave o todavía no hay historia suficiente, el buffer de destino se rellena con ceros.
- En el callback de audio (`audioDeviceIOCallbackWithContext`) se actualizan ahora estos taps en tiempo real y sin locks adicionales: al comienzo del callback se captura `tapCount = min(numConnectionTaps_, kMaxConnectionTaps)` y, para cada muestra, se recorre la lista de taps activos. Para taps tipo `VoicePre`/`VoicePost` se escribe en el buffer de conexión correspondiente justo después de calcular, por voz, las señales `raw` (pre-filtro) y `s` (post-filtro); para taps tipo `Sampleplay` se escribe la muestra mono procedente del path de SoundFont (`sampleplayLeft_`) en el mismo índice `bufIndex` en el que se actualiza `sampleplayWaveformBuffer_`. De este modo, cada conexión monitorizada mantiene su propio historial sin que el hilo de audio tenga que consultar estructuras de alto nivel (`Scene`, `AudioGraph` o maps de C++).
- `MainComponent` conecta esta nueva infraestructura con la abstracción ya existente `ConnectionVisualSource` (Fase 1): al final de `timerCallback`, justo después de llamar a `updateConnectionVisualSources()`, se invoca `audioEngine_.clearAllConnectionWaveformTaps()` y se recorre `Scene::connections()`. Para cada conexión de audio con una `ConnectionVisualSource` válida:
  - Si `kind == kSampleplay`, se configura un tap `ConnectionTapSourceKind::kSampleplay` para esa clave, sin necesidad de índice de voz.
  - Si `kind == kVoicePre` o `kVoicePost` y `voiceIndex` está en rango, se configura un tap `kVoicePre`/`kVoicePost` asociado a ese índice de voz.
  - Las conexiones no audio o sin `ConnectionVisualSource` se ignoran, de forma que sólo las rutas de audio reales consumen taps.
- La capa de pintado de conexiones en `MainComponent_Paint.cpp` deja de leer directamente buffers por voz (`voiceWaveformsPre`/`voiceWaveformsPost`) o el buffer global de Sampleplay para decidir qué waveform mostrar en cada línea. En su lugar, para cada conexión de audio (dinámica, hardlink o en estado de “hold”) se llama a `audioEngine_.getConnectionWaveformSnapshot(connKey, ...)` y, si la señal resultante tiene energía (`maxAbs > 1e-4`), se calcula una normalización simple (`1/maxAbs`) y un periodo aproximado usando el mismo estimador de autocorrelación que ya se usaba para las voces. Con estos datos se dibuja la waveform a lo largo de la línea (o del segmento hasta el punto de split en caso de hold), dejando como fallback un simple trazo recto cuando no hay historial válido para esa conexión.
- Este primer paso de la **Fase 3** no cambia aún la estructura DSP interna (se sigue trabajando con voces de oscilador + filtro y una ruta global de Sampleplay), pero consigue que la visualización de cada conexión dependa de un buffer de waveform **propio**, gestionado en el motor, alineando el comportamiento real con el diseño del documento `research/audio_graph_connection_buffers.md` y preparando el terreno para fases posteriores donde el grafo de audio (`AudioGraph`) pueda dirigir taps aún más finos sobre cadenas más complejas.

### Integración inicial de AudioGraph dentro de AudioEngine
- `AudioEngine` ahora posee un grafo lógico de audio interno (`std::unique_ptr<rectai::AudioGraph> audioGraph_`) y expone dos métodos públicos: `rebuildAudioGraphFromScene(const rectai::Scene&)`, que reconstruye el grafo llamando a `AudioGraph::RebuildFromScene(scene)`, y `audioGraph() const`, que devuelve una referencia constante al grafo actual. El grafo sigue el diseño de `core/src/core/AudioGraph.{h,cpp}`: nodos por módulo (`Node`) y aristas (`Edge`) anotadas con `PortSignalKind` y flag `is_hardlink`.
- En `MainComponent_Audio.cpp`, tras actualizar hardlinks y conexiones dinámicas en `timerCallback()`, se llama ahora a `audioEngine_.rebuildAudioGraphFromScene(scene_)` para que en cada tick el motor mantenga un snapshot actualizado del grafo lógico derivado de la `Scene`. Esto permite que la lógica audio-side que necesita razonar sobre el ruteo consulte un grafo ya procesado en lugar de re-iterar manualmente sobre `Scene::modules()` y `Scene::connections()`.
- La configuración de taps por conexión introducida en la Fase 3 se ha adaptado para usar este grafo interno como fuente de verdad sobre qué conexiones llevan audio: en lugar de recorrer directamente `Scene::connections()` para decidir qué claves configurar, `MainComponent_Audio` llama a `audioEngine_.audioGraph().audio_edges()` y recorre exclusivamente las aristas cuyo `signal_kind == PortSignalKind::kAudio`. Para cada `Edge` se construye un `rectai::Connection` temporal con `from_module_id`, `from_port_name`, `to_module_id`, `to_port_name` e `is_hardlink`, se obtiene su clave estable con `makeConnectionKey` y se consulta `connectionVisualSources_` para saber si debe observar `VoicePre`, `VoicePost` o `Sampleplay` y con qué `voiceIndex`.
- Sobre ese mismo conjunto de aristas de audio (`audio_edges()`), `timerCallback()` ha dejado de depender de `Scene::connections()` para varias decisiones clave de ruteo:
  - El cálculo de `sampleplayOutputGain` y el muteo efectivo de Sampleplay hacia el master se basan ahora en las aristas con `from_module_id == Sampleplay` y `to_module_id == "-1"`, cruzadas con `mutedConnections_` a través de `makeConnectionKey`.
  - La detección de si un generador está muteado en origen (`srcMuted`) usa las mismas aristas de audio hacia `"-1"` del propio generador, en vez de inspeccionar directamente las conexiones de la escena.
  - La construcción de rutas aguas abajo por generador (qué módulos recibe cada Oscillator: Filters, FX, etc.) itera sobre `audio_edges()` filtrando por `from_module_id == generatorId` y `to_module_id != "-1"`, aplicando después los mismos predicados espaciales (área musical + cono geométrico para conexiones dinámicas) y de mute que antes, pero sin depender ya de `Scene::connections()`.
  - El chequeo de si un módulo downstream está efectivamente muteado hacia el master (`downstreamMutedToMaster`) también utiliza `audio_edges()` para localizar sus conexiones a `"-1"`, manteniendo la misma semántica que la versión previa basada en `Scene::connections()`.
- Adicionalmente, la lógica del Sequencer en `MainComponent_Audio.cpp` se ha migrado para usar el mismo `AudioGraph` como representación de las rutas "lógicas" de pasos:
  - Dentro de `timerCallback()`, la lambda `runSequencerStep` deja de recorrer `Scene::connections()` y pasa a usar el vector completo de aristas del grafo (`audioEngine_.audioGraph().edges()`) para localizar destinos aguas abajo de cada `SequencerModule` (Oscillator/Sampleplay), aplicando las mismas restricciones espaciales (área musical + cono geométrico para conexiones no-hardlink) y de mute a nivel de conexión (`mutedConnections_` via `makeConnectionKey`).
  - Cuando un paso está desactivado y `sequencerControlsVolume_` es verdadero, el muteo explícito de osciladores conectados también se calcula a partir de `edges()`, identificando módulos destino de tipo `OscillatorModule` en lugar de inspeccionar las conexiones de la `Scene`.
  - El chequeo de si un módulo Sampleplay aguas abajo está efectivamente muteado hacia el master dentro de `runSequencerStep` usa ahora `audio_edges()` para buscar conexiones Sampleplay → Output (`"-1"`), alineándose con la semántica usada en el cálculo de `sampleplayOutputGain` y en `triggerSampleplayNotesOnBeat`.
  - La propia función `triggerSampleplayNotesOnBeat` ha sido actualizada para apoyarse en `audioEngine_.audioGraph().audio_edges()` al decidir si un módulo Sampleplay está "ruteado y no muteado" hacia el master antes de disparar una nota sincronizada con el beat, de forma que toda la lógica de gating de Sampleplay a Output se apoya en el grafo en lugar de en `Scene::connections()`.
- Con este cambio, la lista de conexiones candidatas a tener buffer propio por conexión, el ruteo efectivo de generadores **y** las rutas lógicas usadas por el Sequencer y Sampleplay comparten la misma fuente de verdad (`AudioGraph`): el motor deja de tener lógica paralela sobre `Scene::connections()` y pasa a usar el grafo de audio interno como representación canónica del subgrafo de audio, cumpliendo mejor el objetivo de que "todo pase por AudioGraph" sin alterar todavía la ruta DSP principal.

### Implementación inicial del Loop Module (audio y UI)
- Se ha extendido `AudioEngine` (`core/src/AudioEngine.{h,cpp}`) con una infraestructura específica para módulos de tipo `Loop`, basada en dos estructuras nuevas: `LoopSample` (buffer estéreo intercalado, número de frames, sample rate de origen y metadatos de compás en beats) y `LoopInstance` (vector de hasta 4 `LoopSample` por módulo, posiciones de lectura por slot, índice seleccionado atómico y ganancia atómica por módulo).
- El motor incorpora ahora un `juce::AudioFormatManager` dedicado (`loopFormatManager_`) y los métodos públicos `loadLoopSampleFromFile`, `setLoopModuleParams` y `setLoopGlobalTempo`. El primero decodifica archivos de audio (WAV, FLAC, Ogg, Opus) desde rutas absolutas usando los readers de JUCE, normaliza el audio a un buffer estéreo `float` intercalado y lo almacena en el slot indicado de `LoopInstance`; el segundo actualiza, sin reiniciar la fase, el índice de slot activo (0–3) y el gain lineal del módulo; el tercero fija un BPM global que se usa para ajustar la velocidad de reproducción de los loops.
- En `audioDeviceIOCallbackWithContext` se ha integrado el mezclado de loops junto al path de Sampleplay y las voces de oscilador. En cada tick de audio se toma un snapshot lock‑free de los `LoopInstance` activos y, por cada módulo Loop, se recorre el slot seleccionado interpolando linealmente entre frames contiguos del buffer estéreo. El avance de fase por muestra se calcula a partir de la relación entre sample rate de origen y del dispositivo y, cuando se dispone del número de beats de la muestra y del BPM global, se escala adicionalmente para que la duración temporal del loop se adapte al tempo (`step *= rate`), aceptando los cambios de pitch inherentes al time‑stretching por resampleo.
- El gesto de mute en las conexiones no detiene la reproducción de los loops: las posiciones de lectura de cada `LoopInstance` avanzan continuamente en el hilo de audio independientemente de la ganancia, y `setLoopModuleParams` nunca resetea dichas posiciones. El mute y el volumen global sólo afectan a cuánto se suma el loop al mix final, no a su fase interna, cumpliendo el requisito de que silenciar la línea de audio no pause el loop.
- En `MainComponent` se ha añadido un mapa `loopLabelLastChangeSeconds_` y el helper `markLoopSampleLabelActive` para controlar la visibilidad de la etiqueta de nombre de archivo asociada a cada módulo Loop. En el constructor de `MainComponent` se ha introducido una lambda `loadLoopSamples` que recorre los `LoopModule` definidos en la `Scene`, ordena sus `LoopDefinition` por campo `order` y carga hasta 4 muestras por módulo desde `com.reactable/Samples` (`Samples/<filename>`), invocando `audioEngine_.loadLoopSampleFromFile` con el número de beats de cada loop.
- En `MainComponent_Audio.cpp`, dentro de `timerCallback`, se propaga el BPM global actual al motor mediante `audioEngine_.setLoopGlobalTempo(bpm_)` y, para cada `LoopModule` dentro del área musical, se calcula el índice de slot activo y el gain efectivo. El índice se deriva del parámetro normalizado `"sample"` (mapeado a 0–3), mientras que el gain se obtiene a partir de `"amp"` (0–1) convertido a dB y combinado con el volumen global. El resultado se fuerza a 0 cuando todas las conexiones Loop→Output(-1) están muteadas en `mutedConnections_`, pero la reproducción interna del loop continúa. Los módulos Loop con gain efectivo > 0 se añaden a `modulesWithActiveAudio_` para que sus líneas de audio muestren waveform.
- La UI de los módulos Loop se ha especializado en `MainComponent_Paint.cpp`: el control lateral izquierdo deja de usar el parámetro `"freq"` y pasa a interpretar `"sample"` como valor de control. Visualmente, la barra `Freq` se representa ahora como un arco segmentado en 4 tramos verticales, cada uno asociado a un slot de loop; el segmento activo se dibuja con mayor opacidad y un pequeño triángulo indicador aparece a la izquierda alineado con el centro del segmento seleccionado. A la derecha del nodo, cuando hay un loop seleccionado, se pinta una etiqueta de texto con el nombre de archivo (basename) del sample activo, visible con opacidad completa durante 5 segundos desde el último cambio y desvaneciéndose linealmente en los 0.5 segundos siguientes en función de `loopLabelLastChangeSeconds_`.
- En `MainComponent_Input.cpp` el control lateral izquierdo se ha habilitado también para módulos Loop: al hacer click sobre la barra `Freq` de un Loop se calcula el segmento (0–3) en función de la posición vertical del cursor, se fija el parámetro `"sample"` al centro de ese segmento (`(i + 0.5) / 4.0`) y se llama a `markLoopSampleLabelActive` para reiniciar el temporizador de la etiqueta. El comportamiento de la barra derecha sigue mapeando `"amp"` a la ganancia del módulo Loop, reutilizando la misma interacción que en `Sampleplay`.
- Adicionalmente, en `MainComponent_Input.cpp` se ha consolidado la lógica de la rueda de ratón sobre módulos Tempo y Loop en un único bloque: se reutiliza el mismo radio de detección e inspección de objetos/módulos y, en función del tipo concreto, se aplica la acción correspondiente (Tempo: ajuste fino de BPM en pasos de ±1 o ±5 con SHIFT; Loop: avance/retroceso cíclico por los cuatro slots de sample actualizando el parámetro normalizado `"sample"` y llamando a `markLoopSampleLabelActive`). Este gesto tiene prioridad sobre el scroll del dock siempre que el cursor esté sobre el círculo de uno de estos módulos en la mesa.
- Con este conjunto de cambios, los módulos `Loop` pasan de ser entidades solo de modelo a estar completamente integrados en el motor de audio y en la UI: pueden cargar hasta 4 muestras desde disco, reproducirlas en loop con sincronización opcional al BPM global, controlarse desde los arcos laterales (selección discreta de slot y volumen) y mostrar el nombre del loop activo en pantalla con una animación de aparición y fade out pensada para depuración y feedback al usuario.

## 2025-12-13

### Activación inmediata del filtro al crear conexiones
- Se ha ajustado la lógica de ruteo de audio en `MainComponent_Audio.cpp` para que los módulos aguas abajo (incluidos `FilterModule`) empiecen a afectar al sonido en cuanto exista una `Connection` en la `Scene`, tanto si se ha creado dinámicamente por disposición espacial como si es un hardlink explícito.
- En el bucle de asignación de voces dentro de `timerCallback`, la selección del módulo destino (`downstreamModule`) ya no vuelve a comprobar el cono geométrico `isConnectionGeometricallyActive` para decidir si una conexión está activa a nivel de audio; este chequeo sigue aplicándose únicamente en la fase de creación de conexiones dinámicas.
- Diseño de evolución hacia buffers por conexión: documentado en `research/audio_graph_connection_buffers.md` un plan por fases para pasar de buffers por voz a buffers por conexión, alineado con un grafo de audio explícito (`AudioGraph`). Incluye Fase 1 (abstracción de fuente visual por conexión en la UI), Fase 2 (grafos lógicos de audio), Fase 3 (taps físicos por conexión en el motor) y Fase 4 (limpieza).
- Implementada Fase 1 (parcial) en la UI: se añade `MainComponent::ConnectionVisualSource` y un mapa `connectionVisualSources_` que, en `updateConnectionVisualSources()`, asigna a cada `Scene::Connection` de audio una fuente visual concreta (pre-voz, post-voz o Sampleplay) en función del tipo de módulo y del mapeo módulo→voice actual.
- Refactor del pintado de conexiones: `MainComponent_Paint.cpp` deja de decidir ad-hoc si una conexión debe usar `voiceWaveformsPre` o `voiceWaveformsPost` según `FilterModule`; ahora consulta `connectionVisualSources_` tanto para conexiones dinámicas como hardlinks y para el estado de “hold” de una conexión. Esto mantiene el comportamiento existente (Osc→Filter muestra la onda pre-filtro; Filter→Output muestra post-filtro) pero hace que cada conexión tenga una fuente bien definida y extensible a nuevos módulos.
- A partir de este cambio, la ruta de audio considera una conexión válida siempre que su módulo destino esté dentro del área musical y la `Connection` exista en la escena, evitando casos en los que la UI muestra una línea entre un Oscillator y un Filter pero el filtro solo empezaba a sonar tras ajustar manualmente el parámetro `freq`.

### Visualización de loops en radiales
- Se ha ajustado la lógica de radiales en `MainComponent_Paint.cpp` para que `isGeneratorLike` sólo sea cierto para módulos de tipo `ModuleType::kGenerator` (actualmente los osciladores). Esto evita que módulos de tipo `LoopModule` o efectos de audio pierdan su línea radial al master cuando tienen conexiones salientes hacia otros módulos: únicamente los generadores "puros" (Oscillator) esconden su línea directa cuando alimentan una cadena aguas abajo.
- Se ha añadido una ruta específica de visualización para los módulos `LoopModule` en los radiales: como los loops no ocupan voces de oscilador ni disponen de taps por conexión, la UI toma ahora el histórico global de waveform del mezclador (`AudioEngine::getWaveformSnapshot`) para dibujar una forma de onda aproximada sobre la línea radial siempre que el loop tenga ganancia efectiva > 0 y la conexión implícita Loop→Output(-1) no esté muteada. Esto hace que los loops muestren actividad visual en su radial (onda animada) de forma coherente con el resto de módulos que producen audio, incluso en escenas formadas sólo por loops.

- Para que el LoopModule exponga una barra de volumen explícita en el arco derecho, se ha activado `enable_gain_control(true)` en su constructor (`AudioModules.cpp`) con un `set_level_mapping(0.0F, 1.0F)`. La UI ya mapeaba los clics y drags de esa barra al parámetro `"amp"` para módulos Loop/Sampleplay, de modo que ahora la barra se muestra activa y controla directamente el nivel del loop, reutilizando la misma semántica que el control de volumen de Sampleplay.
- En `AudioEngine::audioDeviceIOCallbackWithContext`, rama sin voces de oscilador activas, se ha movido la escritura de `waveformBuffer_[bufIndex]` para que suceda **después** de mezclar los loops. Antes el histórico global de waveform sólo reflejaba el path de Sampleplay en esa rama, dejando a los loops fuera del buffer visual cuando no había osciladores; con el cambio, tanto Sampleplay como Loop (e incluso escenas formadas sólo por loops) quedan representados en el buffer usado por `getWaveformSnapshot`, alineando el sonido real con la forma de onda mostrada.
 - Se ha corregido el mapeo de clics sobre la barra izquierda de los módulos Loop en `MainComponent_Input.cpp`: antes, el índice de segmento se calculaba como `(1.0F - value) * 4.0F`, lo que invertía verticalmente la selección (un clic en la parte alta de la barra activaba el slot 0 y uno en la parte baja el slot 3). Ahora el índice se deriva directamente como `value * 4.0F`, de forma que el segmento inferior corresponde al slot 0 y el superior al slot 3, coherente con el orden en el que se dibujan los segmentos en `MainComponent_Paint.cpp` y con la posición del triángulo selector.

### Normalización del parámetro freq al colocar módulos en la mesa
- En `MainComponent_Input.cpp`, dentro de la rama de `mouseDrag` que actualiza la posición de un objeto arrastrado, se ha añadido una normalización explícita del parámetro `"freq"` cuando un módulo entra por primera vez en el área musical (por ejemplo, al sacar un Filter u Oscillator desde el dock a la mesa).
- Cuando `wasInsideMusic` es falso e `isNowInsideMusic` pasa a verdadero, se localiza el `AudioModule` asociado al `logical_id` del objeto y, si `uses_frequency_control()` está activo, se lee su valor actual de frecuencia mediante `GetParameterOrDefault("freq", default_parameter_value("freq"))` y se vuelve a escribir en la escena con `scene_.SetModuleParameter(module->id(), "freq", currentFreq)`.
- Este ajuste replica el efecto que tenía un primer click sobre el slider lateral de frecuencia (que ya llamaba a `SetModuleParameter`), asegurando que módulos como `FilterModule` tengan su cutoff inicial aplicado de forma consistente al entrar en la mesa, incluso antes de que el usuario interactúe manualmente con el control de `freq`.

### Logs de depuración para cadenas Oscillator → Filter
- En `MainComponent_Audio.cpp` se han añadido logs de depuración justo antes de la llamada a `audioEngine_.setVoiceFilter` cuando la cadena de audio de un generador termina en un `FilterModule`.
- Por cada voz activa cuyo módulo aguas abajo es un filtro, se emite una línea de log con prefijo `[rectai-core][debug][filter]` que incluye el id del módulo generador, el id del filtro, el cutoff calculado en Hz (`cutoffHz`), el valor efectivo de resonancia (`q`) y el modo de filtro seleccionado (`mode`).
- Estos logs permiten comparar fácilmente el estado del filtro en la primera colocación de un módulo Filter (antes de tocar el control de `freq`) con el estado tras interactuar con el slider, ayudando a diagnosticar por qué el filtro sólo parece actuar después de modificar explícitamente ese parámetro.

### Clamping de freq en Filter para evitar cutoffs desorbitados
- Se ha corregido el cálculo de la frecuencia de corte del `FilterModule` en `MainComponent_Audio.cpp` añadiendo un clamping explícito del parámetro normalizado `freq` al rango `[0,1]` antes de traducirlo a Hz mediante `base_frequency_hz` y `frequency_range_hz`.
- Algunos patches `.rtp` pueden cargar valores heredados para `freq` fuera de ese rango (por ejemplo, ≈124), que al aplicarse directamente en la fórmula `fb + fr * freqParam` daban lugar a cutoffs desorbitados en torno a 186 kHz. En esa situación el filtro se vuelve prácticamente transparente aunque la UI muestre sliders en posición “media”, y sólo empezaba a actuar después de que el usuario tocara el control de `freq` (lo que sobrescribía el valor con un normalizado correcto).
- Con el nuevo clamping, cualquier valor de `freq` que exceda `[0,1]` se reduce a ese intervalo antes de calcular `cutoffHz`, garantizando que el filtro opere siempre en el rango previsto (≈200–1700 Hz para el Filter actual) desde la primera vez que se coloca el módulo en la mesa, sin requerir una interacción manual previa con el slider de frecuencia.

### Ajuste de tests CTest para TrackerEngine
- Se ha corregido el fallo de `ctest` asociado al ejecutable `rectai-tracker-tests`, que abortaba al no encontrar fiduciales en las imágenes de prueba `fiducial_30.jpg` y `fiducial_55.jpg`.
- En `tracker/src/TrackerEngine.cpp` se ha reforzado la etapa de binarización previa a `libfidtrack`: en lugar de un único umbral adaptativo, el engine prueba ahora varias estrategias (Otsu global normal e invertido, y umbral adaptativo normal e invertido) hasta encontrar la que produce una detección de fiduciales válida. Esto mejora la robustez frente a distintos niveles de contraste y condiciones de iluminación en las imágenes de entrada, respetando el requisito de `libfidtrack` de trabajar sobre imágenes binarias 0/255.
- El test en `tests/tracker_tests.cpp` se ha endurecido de nuevo, ahora que la detección funciona correctamente con las imágenes de ejemplo: para cada fichero (`fiducial_30.jpg` y `fiducial_55.jpg`) se exige que `TrackerEngine::processFrame` devuelva al menos un objeto (`assert(!objects.empty())`) y se mantiene la comprobación de que entre los IDs detectados aparezca exactamente el ID esperado derivado del nombre del archivo (30 y 55 respectivamente). De este modo, la suite de CTest valida explícitamente que la integración con `libfidtrack` es capaz de reconocer los amoeba markers de ejemplo con los IDs correctos.

### Atajos de teclado para pantalla completa y salida rápida
- Se han añadido hotkeys globales a la ventana principal JUCE en `core/src/Main.cpp` para mejorar el flujo de uso en escritorio sin ratón.
- La clase `MainWindow` ahora sobrescribe `keyPressed(const juce::KeyPress& key)` y captura `Escape` para cerrar inmediatamente la aplicación llamando a `juce::JUCEApplicationBase::quit()`, replicando el comportamiento del botón de cierre nativo.
- Se ha implementado un toggle de pantalla completa asociado tanto a `Alt+Enter` como a `F11`: cuando se detecta cualquiera de estas combinaciones, `MainWindow` invoca `setFullScreen(!isFullScreen())` sobre sí misma, alternando entre modo ventana y modo fullscreen usando la API estándar de `juce::DocumentWindow`.
- El resto de teclas se delegan a la implementación por defecto de `juce::DocumentWindow::keyPressed` para no interferir con futuros componentes que deseen manejar atajos propios.

### Altura de waveform en función del volumen del módulo
- Se ha ajustado la lógica de pintado en `MainComponent_Paint.cpp` para que la altura de las formas de onda sobre las líneas de audio dependa del volumen o nivel del módulo correspondiente, en lugar de usar una amplitud fija. Esto afecta tanto a las líneas radiales módulo→Master como a las conexiones módulo→módulo (dinámicas y hardlink).
- Dentro de `paint`, se ha introducido un helper local `getModuleVisualLevel(const rectai::AudioModule*)` que devuelve un factor normalizado en `[0,1]` a partir de los parámetros del módulo:
  - Para `VolumeModule`, se usa el parámetro `"volume"` (0..1).
  - Para `SampleplayModule`, `LoopModule` e `InputModule`, se usa el parámetro `"amp"` (0..1).
  - Para `OscillatorModule`, se usa el parámetro `"gain"` (0..1).
  - Para `FilterModule`, se usa el parámetro `"q"` como proxy del énfasis del filtro.
  - Para otros módulos con `uses_gain_control()` activo, se intenta leer `"gain"` y, en caso contrario, se devuelve 1.0.
- En las líneas radiales, la amplitud base de la waveform (que ya se había incrementado para hacerla aproximadamente 3 veces más alta) se multiplica ahora por el `visualLevel` del módulo asociado al objeto. De este modo, al bajar el gain/amp de un oscilador o Sampleplay, el “soundwave” sobre su línea a Master se hace más pequeño hasta casi desaparecer cuando el volumen está a 0, manteniendo visible la línea estructural sin waveform.
- En las conexiones entre módulos, tras localizar `fromModulePtr` y `toModulePtr` se calcula un `connectionLevel = max(fromLevel, toLevel)` usando el helper anterior. Todas las ramas que dibujan waveform sobre conexiones (segmento de hold con split, hardlinks con waveform, y conexiones dinámicas con `useWaveformPath=true`) escalan ahora su `waveformAmplitude` por este `connectionLevel`, de forma que las rutas de señal que atraviesan módulos con niveles bajos muestran ondas más planas y las cadenas con módulos a alto volumen mantienen la waveform alta.
- Este cambio mantiene la independencia entre la generación de audio (el motor sigue generando waveform interna incluso a volumen 0 para estabilizar la visualización) y la percepción visual de loudness: la forma de onda representada sigue siendo la misma (gracias al estimador de periodo corregido), pero su altura en pantalla comunica el nivel relativo del módulo o de la conexión según sus parámetros de volumen.

### Estabilización de la forma de onda para notas graves con Sequencer
- Se ha ajustado el estimador de periodo usado por la capa de pintado para repetir una sola onda a lo largo de las líneas de audio. En `MainComponent_Paint.cpp`, la lambda `estimateWaveformPeriod` ahora ignora retardos (lags) demasiado pequeños al calcular la autocorrelación sobre el snapshot de cada voz, imponiendo un `minLag` de 4 muestras y descartando periodos estimados menores que ese umbral.
- Antes del cambio, para ciertas notas graves disparadas desde el `SequencerModule`, la autocorrelación tendía a elegir un periodo degenerado de 1–2 muestras en ventanas donde el contenido variaba lentamente. Al usar ese valor como longitud de periodo, la función `drawWaveformOnLine` terminaba leyendo siempre la misma muestra al recorrer la línea, produciendo una línea prácticamente recta cuyo desplazamiento vertical cambiaba cuadro a cuadro en lugar de mostrar una senoide estable.
- Con el nuevo umbral mínimo, el estimador de periodo sigue detectando correctamente periodos en el rango de frecuencias típico de los osciladores del proyecto, pero evita colapsar a un periodo de una sola muestra. En la práctica, las conexiones de osciladores de tipo seno controlados por el Sequencer muestran ahora una forma de onda sinusoidal coherente tanto en notas agudas como en notas graves, eliminando el efecto visual de “línea que solo vibra arriba y abajo” que se observaba previamente.

### Diseño del módulo Sequencer y capa MIDI interna
- Se ha creado el documento `research/sequencer.md` que define el diseño detallado del módulo `Sequencer` y de una capa de señal MIDI interna para el proyecto. El documento describe una estructura de evento de nota (`MidiNoteEvent` con canal, nota, velocidad normalizada, tiempo en beats y tipo NoteOn/NoteOff) independiente de JUCE pero mapeable a `juce::MidiMessage` o al motor de audio.
- El plan introduce un enum `PortSignalKind` (`kAudio`, `kMidi`, `kControl`) y evoluciona `PortDescriptor` para distinguir explícitamente entre puertos de audio, MIDI y control, además de proponer flags `produces_midi_` y `consumes_midi_` en `AudioModule` y la extensión de `CanConnectTo` para soportar conexiones MIDI→MIDI manteniendo a los controladores globales (`Volume`, `Tempo`, `Tonalizer`) fuera del grafo de conexiones.
- Se define el rol MIDI de los módulos clave: `SequencerModule` como productor de eventos de nota, `SampleplayModule` y `OscillatorModule` como consumidores de MIDI (mapeando notas a presets de SoundFont o a frecuencia/ganancia por voz), y `TonalizerModule` como controlador global que transforma las notas antes de materializarlas en audio.
- Para el `SequencerModule` se plantea una estructura de 6 presets con 16 pasos cada uno (`SequencerPreset` y `SequencerStep`), soportando tres modos (`SequencerMode::kMonophonic`, `kPolyphonic`, `kRandom`), donde el Monophonic se implementará primero pero la representación de datos queda preparada para extensiones polifónicas (varios pitches por step) y lógicas aleatorias sin cambios de API.
- El runtime monofónico se sincroniza con el `TempoModule` usando una fase global en beats y una resolución de 16 pasos por compás; en cada transición de step se generan eventos `NoteOff`/`NoteOn` según los flags `enabled` y `velocity01` del step, almacenados en presets seleccionados mediante la rotación del tangible (6 presets según la posición del marcador/`point` en el `.rtp`).
- El roadmap técnico asociado incluye: 1) introducir la infraestructura MIDI (tipos de puerto, flags y `MidiNoteEvent`), 2) completar el estado y API de `SequencerModule` para presets y pasos, 3) implementar un runtime monofónico sincronizado con tempo en el `AudioEngine`, 4) enrutar los eventos hacia `Sampleplay`/`Oscillator` usando `Scene::connections()` y 5) extender posteriormente a modos Polyphonic y Random con runtimes específicos que compartan el mismo modelo de datos.

### Infraestructura MIDI en `Scene` y presets iniciales del Sequencer
- Se ha extendido el modelo de puertos en `core/src/core/Scene.{h,cpp}` introduciendo el enum `PortSignalKind` (`kAudio`, `kMidi`, `kControl`) y haciendo que `PortDescriptor` almacene explícitamente el tipo de señal. `AudioModule` incorpora ahora flags `produces_midi_` y `consumes_midi_` junto con sus getters, y `CanConnectTo` permite conexiones cuando hay compatibilidad audio→audio o MIDI→MIDI, manteniendo la prohibición de conexiones para módulos marcados como controladores globales.
- Todos los módulos concretos de `core/src/core/AudioModules.cpp` se han actualizado para declarar sus puertos con el tipo correcto: los módulos de audio usan `PortSignalKind::kAudio` en `in`/`out`, el `LfoModule` expone un puerto `out` de tipo `kControl` y el `SequencerModule` declara un puerto `out` de tipo `kMidi`, marcándose además como productor de MIDI (`produces_midi=true`). La lógica de pintado en `MainComponent_Paint.cpp` se ha ajustado para detectar conexiones de audio consultando `PortSignalKind::kAudio` en los puertos en lugar del antiguo flag booleano `is_audio`.
 - Todos los módulos concretos de `core/src/core/AudioModules.cpp` se han actualizado para declarar sus puertos con el tipo correcto: los módulos de audio usan `PortSignalKind::kAudio` en `in`/`out`, el `LfoModule` expone un puerto `out` de tipo `kControl` y el `SequencerModule` declara un puerto `out` de tipo `kMidi`, marcándose además como productor de MIDI (`produces_midi=true`). Los módulos `OscillatorModule` y `SampleplayModule` se han marcado como consumidores de MIDI (`consumes_midi=true`) y ahora exponen un puerto de entrada `in` de tipo `kMidi` además de su salida de audio `out`, permitiendo que el sistema de conexiones espaciales (dinámicas y hardlinks) establezca enlaces `Sequencer → Oscillator` o `Sequencer → Sampleplay` de forma completamente genérica usando `AudioModule::CanConnectTo` y `Scene::AddConnection`, sin código específico para pares de módulos concretos. La lógica de pintado en `MainComponent_Paint.cpp` se ha ajustado para detectar conexiones de audio consultando `PortSignalKind::kAudio` en los puertos en lugar del antiguo flag booleano `is_audio`.
- Se ha añadido `core/src/core/MidiTypes.h` con la estructura `MidiNoteEvent` (canal, nota, velocidad normalizada, tiempo en beats y flag NoteOn/NoteOff), pensada como representación interna de eventos MIDI que el runtime del Sequencer utilizará para disparar notas en `Sampleplay`/`Oscillator` y que podrá mapearse a estructuras de JUCE o directamente al motor de audio.
- `SequencerModule` en `core/src/core/AudioModules.{h,cpp}` incorpora ahora un banco fijo de presets monofónicos (`SequencerPreset`) con 6 presets de 16 pasos cada uno (`SequencerStep` con `enabled`, `velocity01`, `pitch`) y un enum `Mode` (`kMonophonic`, `kPolyphonic`, `kRandom`) preparado para futuras extensiones. Se expone una API mínima para consultar y modificar el modo, el preset actual y el contenido de cada preset.
- El loader de patches Reactable (`ReactableRtpLoader.cpp`) sigue rellenando la estructura de bajo nivel `SequenceTrack` a partir de los elementos `<sequence>` del `.rtp` (filas, `speed`, `speed_type`, `step_frequencies`, `steps`, capas `tenori0..tenori12` y `volumes`), pero ahora, tras cargar todos los tracks en cada `SequencerModule`, llama a `SequencerModule::SyncPresetsFromTracks()`. Este helper recorre como máximo los primeros 6 `SequenceTrack` y, para cada uno, proyecta los datos sobre los 16 pasos del preset correspondiente: `steps` se mapea a `enabled` (0/1 por paso), `volumes` se clampa a `[0,1]` y se usa como `velocity01`, y `step_frequencies` se convierte a nota MIDI aproximada (`pitch`) mediante la fórmula estándar `midi = 69 + 12 * log2(freq/440)` con clamp a `[0,127]`. Cuando no hay datos suficientes, se desactivan los pasos o se mantiene `pitch=60` (C4) como valor por defecto.
- Con este mapeo, cualquier patch `.rtp` que defina secuencias para el módulo `Sequencer` queda traducido automáticamente a un banco interno 6x16 listo para ser consumido por el runtime monofónico: las estructuras de presets/steps ya contienen una representación compacta (enabled/velocity/pitch) independiente de los detalles de `SequenceTrack`, lo que permitirá implementar la lógica de avance por pasos sincronizada con el tempo sin depender directamente del esquema XML original.
 - Se ha implementado un primer runtime monofónico del Sequencer en `MainComponent_Audio.cpp`, sincronizado con el BPM global. `MainComponent` mantiene ahora un estado de fase/step específico para audio (`sequencerAudioPhase_`, `sequencerAudioStep_`) con 16 pasos por compás; en cada tick del `timerCallback` se avanza esta fase según `bps = bpm_ / 60` y, cuando cambia el step, se recorre cada `SequencerModule` presente en la escena (no muteado y dentro del área musical), se lee el preset activo y el `SequencerStep` correspondiente, y si `enabled` y `velocity01 > 0` se disparan acciones sobre los módulos aguas abajo.
 - Para módulos `Sampleplay` conectados al Sequencer (respetando área musical, hardlinks y cono geométrico, así como mute por objeto/conexión), se dispara una nota corta vía `audioEngine_.triggerSampleplayNote(bank, program, midiKey, velocity01)`, usando el `pitch` del step como nota MIDI (clampada a `[0,127]`) y calculando la velocidad combinando `velocity01` con el `amp` del Sampleplay, su `base_level`/`level_range` y el volumen global ya mapeado a dB. Esto permite que cualquier patch con `Sequencer` → `Sampleplay` empiece a producir patrones rítmicos reales desde las secuencias cargadas del `.rtp`.
 - Para módulos `Oscillator` conectados al Sequencer, el runtime traduce `pitch` a frecuencia en Hz (`440 * 2^((pitch-69)/12)`) y la normaliza al rango propio del oscilador (`base_frequency_hz` + `frequency_range_hz`), actualizando el parámetro `freq` de ese módulo mediante `Scene::SetModuleParameter`. El parámetro `gain` del oscilador se alimenta directamente desde `velocity01` (clampado a `[0,1]`). De este modo, los osciladores conectados a un Sequencer siguen el patrón de notas/velocidades definido en los presets, y el motor de audio recoge estos cambios en el siguiente tick sin requerir todavía una cola de `MidiNoteEvent` explícita.
 - El runtime respeta siempre la topología y el estado de la escena: solo se consideran conexiones en las que el Sequencer es `from_module_id`, el objeto destino está dentro del área musical y, si la conexión no es hardlink, el cono geométrico la considera activa (`isConnectionGeometricallyActive`). Además, se ignoran módulos destino muteados o conexiones marcadas como mute en `mutedConnections_`. El secuenciador visual existente (8 pasos por compás para widgets de UI) se mantiene separado usando `sequencerPhase_` / `sequencerStep_`, de manera que la nueva lógica de audio no altera la representación gráfica previa.

## 2025-12-17

### Waveform individual por módulo Loop en radiales
- Se ha extendido `AudioEngine` (`core/src/AudioEngine.{h,cpp}`) con un pequeño sistema de historiales de waveform específicos para módulos `LoopModule`. Se introduce la constante `kMaxLoopWaveforms = 16` y un nuevo bloque de estado privado formado por `loopWaveformBuffers_[kMaxLoopWaveforms][kWaveformHistorySize]`, un `unordered_map<string,int> loopModuleToWaveformIndex_` y un contador `numLoopWaveformSlots_`. Cada módulo Loop que necesite visualización obtiene un índice entero estable en este rango, y el hilo de audio escribe en su buffer dedicado usando el mismo índice de escritura global (`waveformWriteIndex_`) que el resto de historiales.
- La estructura `LoopInstance` incorpora un campo `int visualWaveformIndex{-1}` que apunta al slot de waveform asignado a ese módulo. El campo se copia/mueve explícitamente en los constructores y operadores de copia/move para que la instantánea usada por el hilo de audio (`loopModulesSnapshot_`) conserve el índice visual sin tener que consultar maps en tiempo de audio.
- `AudioEngine::setLoopModuleParams` se encarga ahora de reservar el slot visual la primera vez que se actualizan parámetros de un módulo Loop: si `visualWaveformIndex` es negativo, busca en `loopModuleToWaveformIndex_` un índice ya asignado para ese `moduleId` y, si no existe y aún hay espacio (< `kMaxLoopWaveforms`), crea una entrada nueva e incrementa `numLoopWaveformSlots_`. Tras actualizar los parámetros (slot seleccionado, gain y tiempos de envolvente), el método replica también `visualWaveformIndex` en el snapshot activo (`loopModulesSnapshot_`) para que el hilo de audio conozca el índice sin locks.
- En el callback de audio (`audioDeviceIOCallbackWithContext`), dentro de ambas ramas donde se mezclan loops (con y sin voces de oscilador activas), se aprovecha el bucle que ya recorre los `LoopInstance` activos: justo después de aplicar la envolvente AR y calcular el `finalGain`, se deriva una muestra mono por módulo a partir del canal izquierdo (`const float monoWithGain = l * finalGain;`). Esta muestra se suma al mix estéreo cuando `finalGain > 0` y, en cualquier caso, se escribe en el buffer visual correspondiente siempre que `visualWaveformIndex` esté en rango (`loopWaveformBuffers_[wfIndex][bufIndex] = monoWithGain;`). De este modo, el historial de waveform por módulo refleja la señal post‑gain/envolvente del loop y se va rellenando con ceros cuando el módulo deja de sonar, haciendo que las ondas en la UI se desvanezcan de forma natural.
- Se ha añadido el método público `AudioEngine::getLoopModuleWaveformSnapshot(const std::string& moduleId, float* dst, int numPoints, double windowSeconds)`, que sigue la misma estrategia que `getWaveformSnapshot` y `getConnectionWaveformSnapshot`: localiza el índice del módulo en `loopModuleToWaveformIndex_`, valida rangos y, a partir de `waveformWriteIndex_`, calcula una ventana temporal (por defecto ~50 ms) dentro del historial circular. La ventana se remuestrea de forma uniforme en `numPoints` posiciones escribiendo en `dst`. Si el módulo no tiene historial o aún no hay muestras suficientes, el buffer se rellena con ceros.
- En la capa de pintado (`core/src/MainComponent_Paint.cpp`), la rama específica para radiales de Loop se ha cambiado para usar el nuevo API per‑módulo en lugar del buffer global mezclado. Donde antes se llamaba a `audioEngine_.getWaveformSnapshot(loopRadialWave, kWaveformPoints, 0.05)`, ahora se invoca `audioEngine_.getLoopModuleWaveformSnapshot(object.logical_id(), loopRadialWave, kWaveformPoints, 0.05)`. La normalización posterior (`maxAbs` y `loopRadialNorm`) y el dibujo vía `drawWaveformOnLine` se mantienen igual, pero ahora cada Loop radial refleja únicamente la forma de onda del sample y ganancia de ese módulo, en lugar de la suma global de todos los loops y demás fuentes.
- Con este cambio, cuando se colocan varios módulos Loop con samples distintos, la “línea soundwave” radial de cada uno muestra su waveform individual (derivada de su propio sample + envolvente) y ya no aparece idéntica entre módulos. La visualización sigue respetando el mute por conexión (`isRadialMuted`) y el gating por `modulesWithActiveAudio_`/`lineCarriesAudio`, y los tests (`ctest`) siguen pasando sin cambios adicionales.

### Fade temporal del título de instrumento en Sampleplay
- El título del instrumento activo de los módulos `Sampleplay` (texto que se pinta a la derecha del nodo) ahora se muestra de forma destacada solo durante unos segundos tras una interacción relevante y luego se desvanece progresivamente. `MainComponent` mantiene un mapa `sampleplayLabelLastChangeSeconds_` que asocia el id de módulo con un timestamp en segundos; este valor se actualiza tanto cuando un `SampleplayModule` entra en el área musical (al arrastrar el tangible desde el dock o desde fuera del círculo) como cuando se cambia de instrumento o banco con click derecho (`CycleInstrument` / `CycleBank`). En `MainComponent_Paint.cpp`, la sección de render del título de Sampleplay consulta dicho timestamp y calcula una alpha: el texto permanece al 100% hasta 3 segundos después del último cambio y, entre los 3 y 3.5 segundos, hace un fade lineal hasta desaparecer; si no existe aún entrada en el mapa (escenas cargadas al inicio), la primera vez que se pinta se inicializa el temporizador para garantizar un comportamiento consistente. De esta forma, el nombre del instrumento es claramente visible justo después de colocar o reconfigurar un Sampleplay, pero la UI se limpia automáticamente tras un breve periodo de inactividad.

### Control opcional de volumen desde el Sequencer
- En `MainComponent` se ha añadido el flag `sequencerControlsVolume_` (por defecto `true`) que gobierna si el runtime del `SequencerModule` está autorizado a modificar el volumen de los módulos destino. Cuando está activado (valor por defecto actual), los pasos del secuenciador siguen modulando la velocidad de las notas disparadas en `Sampleplay` (multiplicando `velocity01` de cada step en `runSequencerStep`) y escribiendo el parámetro `gain` de los `OscillatorModule` conectados, forzando además `gain = 0.0` en los pasos desactivados para garantizar silencios claros: si un Oscillator está conectado a un Sequencer y el paso correspondiente tiene `enabled = 0`, el oscilador no suena en ese beat. Cuando se desactiva este flag, el Sequencer sigue controlando pitch/trigger (frecuencia destino y disparo de notas) pero deja de escalar la velocidad de las notas y no toca el parámetro `gain` en osciladores ni fuerza silencio en pasos vacíos, permitiendo que el volumen llegue desde otras fuentes MIDI o controladores globales sin ser sobreescrito por el patrón del secuenciador.

### Duración de nota derivada de `speed` (figura binaria)
- Aunque `SequenceTrack` ya almacenaba los campos `speed` y `speed_type` de cada `<sequence>` del `.rtp`, hasta ahora el runtime del Sequencer no los utilizaba y todas las notas tenían una duración efectiva ligada al envelope del destino o a cambios manuales de `gain`. Se ha dado el primer paso para respetar la semántica original de Reactable donde, con `speed_type="binary"`, el entero `speed` codifica la **figura musical** de la nota: `0=fusa (1/32)`, `1=semicorchea (1/16)`, `2=corchea (1/8)`, `3=negra (1/4)`, `4=blanca (2/4)`, `5=redonda (4/4)`.
- En `MainComponent_Audio.cpp` se ha introducido el helper `binarySpeedToBeats(int)` (en un namespace anónimo) que mapea estos valores a longitudes en beats asumiendo compás 4/4 y negra=1 beat: `0→1/8` (0.125 beats), `1→1/4`, `2→1/2`, `3→1`, `4→2`, `5→4`. Este helper sólo se aplica cuando el `SequenceTrack.speed_type` es exactamente `"binary"`; para otros tipos el runtime mantiene, por ahora, una duración por defecto de negra (1 beat).
- El runtime del Sequencer en `runSequencerStep` consulta ahora, para cada `SequencerModule`, el `SequenceTrack` asociado al preset activo (`tracks()[current_preset]`) y, cuando `sequencerControlsVolume_` es verdadero y el destino es un `OscillatorModule`, calcula una `noteLengthBeats` llamando a `binarySpeedToBeats(track.speed)`. Con esa longitud programa un **note-off en beats** para el módulo destino almacenándolo en `moduleNoteOffBeats_[oscModule->id()] = transportBeats_ + noteLengthBeats`.
- `MainComponent` mantiene el mapa `moduleNoteOffBeats_` y, en cada `timerCallback`, calcula la posición global de transporte como `transportBeats_ + beatPhase_`. Para cada entrada cuya hora de corte se haya alcanzado o superado, fuerza `Scene::SetModuleParameter(moduleId, "gain", 0.0F)` (sólo si el módulo sigue siendo un `OscillatorModule`) y elimina la entrada del mapa. De esta forma, mientras un Oscillator esté conectado a un Sequencer y `sequencerControlsVolume_` sea `true`, el valor `speed` de su `SequenceTrack` determina cuánto tiempo permanece el `gain` distinto de cero tras cada disparo de paso, aproximando la duración audible de la nota a la figura binaria especificada en el patch.

### Scroll con rueda en el dock de módulos
- `MainComponent` implementa ahora `mouseWheelMove` para permitir hacer scroll vertical en el dock derecho usando la rueda del ratón siempre que el cursor esté dentro del área del dock. El manejo de la rueda reutiliza el mismo cálculo de límites que el drag vertical del dock (`minOffset` basado en `contentHeight` y `availableHeight`), actualizando `dockScrollOffset_` mediante un pequeño desplazamiento en píxeles proporcional a `wheel.deltaY` y forzando un `repaint()`. De este modo, cuando hay más módulos dockeados de los que caben en pantalla, el usuario puede navegar por la lista tanto arrastrando con el ratón como empleando la rueda, sin afectar al resto de la superficie musical.

### Normalización de idioma en comentarios de código (core)
- Se han revisado los archivos de código en `core/src/` relacionados con entrada de usuario, pintado de escena y modelo de audio (`MainComponent_Input.cpp`, `MainComponent_Paint.cpp`, `MainComponent.cpp`, `MainComponent.h`, `core/Scene.{h,cpp}`, `core/ReactableRtpLoader.cpp`, `core/AudioModules.{h,cpp}`) para localizar comentarios escritos en español y traducirlos al inglés, alineando así el código con la convención general del proyecto.
- En `MainComponent_Input.cpp` se han traducido los comentarios que describen el comportamiento del scroll con rueda en el dock, la selección y mute de líneas centro→objeto y la lógica de corte de líneas, manteniendo la semántica original (limitación del scroll al área del dock, criterios de clic/corte sólo sobre módulos que producen o consumen audio, exclusión de controladores globales y módulos sólo MIDI/control).
- En `MainComponent_Paint.cpp` se ha ajustado el comentario que documenta la reutilización de `drawWaveformOnLine` para conexiones dinámicas ya renderizadas como líneas rectas.
- En `MainComponent.cpp` y `core/AudioModules.{h,cpp}` se han traducido los comentarios que explican la heurística de mapeo entre bancos lógicos de `Sampleplay` y presets reales del SoundFont (drums vs synths), así como el avance de banco lógico (`CycleBank`) y el uso de `default_preset_indices_`.
- En `MainComponent.h` se han pasado a inglés las descripciones de fase/step del sequencer visual y de audio, el contador de beats (`transportBeats_`) y el flag `sequencerControlsVolume_`, aclarando su rol en la modulación opcional de volumen desde el Sequencer.
- En `core/src/core/Scene.{h,cpp}` se han traducido los encabezados de sección de gestión de módulos, conexiones y objetos, y los comentarios que documentan la eliminación de conexiones asociadas a un módulo borrado y la prevención de duplicados al añadir conexiones.
- En `core/src/core/ReactableRtpLoader.cpp` se han traducido los comentarios que describen la normalización del volumen del módulo `Volume` desde porcentaje (0..100) a rango [0,1] y la derivación de presets monofónicos de `Sequencer` a partir de `SequenceTrack`, eliminando las frases en español dentro de explicaciones mixtas.

### Enumeración de presets SF2 con FluidSynth y Sampleplay integrado
- Se ha completado la integración de FluidSynth para el módulo `Sampleplay`, de forma que el audio ya no depende de tonos senoidales de prueba sino de los instrumentos reales del archivo SoundFont2 (`.sf2`). La clase `SampleplaySynth` en `core/src/core/SampleplaySynth.{h,cpp}` encapsula `fluid_settings_t` y `fluid_synth_t` y expone métodos para cargar un soundfont, ajustar el sample rate y renderizar audio estéreo hacia buffers `float*`, además de lanzar notas (`noteOn`) y liberarlas (`noteOff`) según banco/programa y nota MIDI.
- `AudioEngine` (`core/src/AudioEngine.{h,cpp}`) utiliza ahora `SampleplaySynth` como fuente de audio para todos los módulos de tipo `Sampleplay`. En el callback de audio mezcla el resultado de FluidSynth (buffers izquierdo/derecho) con las voces procedurales existentes (osciladores, etc.), aplicando limitación suave por canal y manteniendo el buffer circular de muestras para la visualización de formas de onda en las líneas.
- En `MainComponent_Audio.cpp` se ha introducido la función `triggerSampleplayNotesOnBeat(bool strongBeat)`, invocada en `timerCallback` cada vez que `beatPhase_` supera un nuevo beat. Esta función recorre los `SampleplayModule` activos en el área musical, calcula una nota MIDI a partir del parámetro `midifreq`, deriva una velocidad normalizada desde `amp` y el volumen global y llama a `audioEngine_.triggerSampleplayNote(bank, program, midiKey, velocity01)` usando el banco y programa del instrumento activo. De este modo, los Sampleplay lanzan notas sincronizadas con el tempo global utilizando el motor de SoundFont real.
- Se ha implementado la enumeración de presets de SoundFont en `core/src/core/SoundfontUtils.{h,cpp}` mediante la función `EnumerateSoundfontPresets`. Para evitar problemas con tipos opacos de FluidSynth en C++, esta función declara solo el subconjunto mínimo de la API C necesario y trata los handles de soundfont y preset como punteros opacos (`void*`). A partir de un soundfont cargado con `fluid_synth_sfload`, la función recorre un rango razonable de bancos y programas (0–127) usando `fluid_sfont_get_preset` y, para cada preset encontrado, obtiene `bank`, `program` y `name` con `fluid_preset_get_*`, rellenando un `std::vector<SoundfontPreset>` que alimenta el modelo de `Sampleplay`.
- El lambda `loadSampleplaySoundfonts` en `MainComponent.cpp` sigue siendo el punto central para inicializar los módulos `Sampleplay` tras cargar un patch `.rtp`: resuelve la ruta del `.sf2` desde `com.reactable/Soundfonts`, llama a `SampleplayModule::LoadSoundfont` para validar el archivo y, si la carga es correcta, usa `EnumerateSoundfontPresets` para reconstruir la lista de `SampleInstrument` del módulo a partir de los presets reales del SF2. La lista de instrumentos declarada en el `.rtp` se utiliza solo como pista para elegir el preset por defecto cuando hay coincidencia de nombre.
- Una vez que se encuentra al menos un `SampleplayModule` con SoundFont válido, `loadSampleplaySoundfonts` informa también al `AudioEngine` de la ruta del soundfont llamando a `audioEngine_.setSampleplaySoundfont(sampleModule->soundfont_path())`, asegurando que el motor de audio y el modelo de escena utilizan exactamente el mismo archivo SF2. El comportamiento de la UI (título de instrumento a la derecha del módulo y cambio de instrumento por click derecho) se mantiene, pero ahora los nombres y presets provienen directamente del contenido del SoundFont.
- Se ha refinado la interpretación de los Sampleplay respecto al archivo `default.rtp`: el atributo `channel` de los tangibles Sampleplay se interpreta como índice de banco lógico (0 → primer `<instrument>` del `.rtp`, 1 → segundo `<instrument>`, etc.) y el orden de los elementos `<instrument>` se usa como mapeo de “modos” (por ejemplo, drums vs synths). `MainComponent::loadSampleplaySoundfonts` construye ahora un vector de índices de preset por banco (`default_preset_indices_` en `SampleplayModule`) buscando cada nombre de `<instrument>` entre los presets enumerados del SF2 y selecciona como preset activo el correspondiente al canal declarado por el patch, con fallback razonable cuando no hay coincidencia.
- `SampleplayModule` mantiene ahora un campo `channel_` y un vector `default_preset_indices_` que enlaza bancos lógicos con presets concretos de SoundFont. El método `CycleInstrument()` cicla preferentemente entre los presets del mismo banco físico (mismo `bank` SF2 que el preset por defecto del canal actual), y se ha añadido `CycleBank()` para rotar entre bancos lógicos (canales) actualizando el preset activo al índice por defecto de cada banco.
- En la interacción de la UI (`MainComponent_Input.cpp`), el click derecho sobre un Sampleplay sin modificadores sigue ciclando los instrumentos dentro del banco actual, mientras que un click derecho con la tecla CONTROL pulsada alterna entre los bancos lógicos (por ejemplo, del banco de drums al banco de synths), seleccionando automáticamente el preset por defecto de cada banco según lo definido por el `.rtp` y resuelto contra el contenido real del SF2.

### Volumen dedicado y waveform visual para Sampleplay
- Se ha activado un control de ganancia específico para `SampleplayModule` en `core/src/core/AudioModules.cpp` habilitando `uses_gain_control_` y ajustando el mapeo de nivel con `set_level_mapping(0.05F, 0.95F)`. Esto hace que el arco derecho de cada Sampleplay en la UI represente su volumen principal y que el parámetro `amp` pueda recorrer un rango útil de loudness cuando se combina con la curva de volumen global (`VolumeModule`).
- En `MainComponent_Paint.cpp`, el cálculo del valor de ganancia para los sliders laterales distingue ahora explícitamente entre módulos: `Volume` sigue usando `volume`, los `Filter` usan `q`, y los módulos `Loop`/`Sampleplay` leen su nivel desde `amp`. De este modo, el arco derecho de Sampleplay refleja siempre el valor real que se aplicará al disparar notas vía SoundFont.
- La lógica de input en `MainComponent_Input.cpp` se ha ampliado para que el side control derecho escriba sobre el parámetro `amp` en módulos `Loop` y `Sampleplay` tanto al hacer click en la barra como durante el drag continuo (antes solo actualizaba `gain` salvo en `Volume` y `Filter`). Esto alinea el gesto de usuario con el modelo de parámetros: el slider derecho de Sampleplay ajusta realmente el volumen de sus disparos, y el gesto de drop seguro con CONTROL sigue pudiendo forzar `amp = 0.0` al colocar el módulo sobre la mesa.
- En el motor de audio (`core/src/AudioEngine.{h,cpp}`) se ha añadido un buffer circular mono dedicado a Sampleplay (`sampleplayWaveformBuffer_`) y un método público `getSampleplayWaveformSnapshot`, que capturan la contribución de SoundFont antes de mezclarla con las voces procedurales. El callback de audio escribe en este buffer a partir del canal izquierdo de `SampleplaySynth::render` manteniendo el mismo índice de escritura que el resto de historiales de waveform.
- `MainComponent_Paint.cpp` consume ahora este snapshot específico para Sampleplay al dibujar las líneas radiales módulo→Master: cuando el módulo asociado es un `SampleplayModule` y el historial tiene energía suficiente, la línea se pinta con la forma de onda tomada de `sampleplayWaveformBuffer_` en lugar de intentar reutilizar los buffers por voz del oscilador (que no representan el audio de Sampleplay). Esto hace que la conexión entre Sampleplay y Master muestre un soundwave animado análogo al de los osciladores, pero basado en la señal real del SoundFont.

- Se ha añadido un control de ganancia global para la ruta de Sampleplay (SoundFont) en `AudioEngine` (`sampleplayOutputGain_` más el método `setSampleplayOutputGain`). El callback de audio multiplica los buffers `sampleplayLeft_`/`sampleplayRight_` por este valor antes de mezclarlos con las voces del oscilador, permitiendo silenciar inmediatamente todo el audio procedente del SoundFont sin afectar a las voces procedurales.
- `MainComponent_Audio.cpp` actualiza este gain en cada `timerCallback`: cuando el master está muteado o no existe ningún `SampleplayModule` dentro del área musical con su línea a Master sin mutear, fija `sampleplayOutputGain` a 0.0; en caso contrario lo iguala al `globalVolumeGain`. De esta forma, al mutear la línea de sonido de un Sampleplay (o el master), el audio de SoundFont se detiene en seco (stop), incluso si había muestras largas en reproducción, mientras que al reactivar la línea el volumen vuelve a seguir la curva del módulo `Volume`.
 - Para evitar que las notas disparadas sobre el motor de SoundFont se acumulen cuando el `SequencerModule` envía eventos repetidos a `Sampleplay`, se ha ajustado `SampleplaySynth::noteOn` en `core/src/core/SampleplaySynth.cpp` para que llame a `fluid_synth_all_notes_off(…, channel)` antes de seleccionar preset y disparar una nueva nota en el único canal de FluidSynth que usamos. Esto implementa un comportamiento monofónico sencillo: cada nueva nota enviada por el secuenciador marca el final de las notas previas (que pasan a su fase de release según el envelope del SF2), evitando el efecto de notas “infinitas” o colas superpuestas cuando se tocan varios pasos seguidos.

### Preparación del Sequencer para modos polifónicos
- La estructura `SequencerStep` en `core/src/core/AudioModules.h` se ha ampliado para incluir un contenedor `std::vector<int> pitches` además del campo escalar `pitch`. La implementación actual del runtime sigue siendo monofónica y consume únicamente `pitch`, pero el vector `pitches` permite adjuntar varias notas a un mismo paso sin cambiar el modelo de datos cuando se implementen los modos Polyphonic/Random descritos en `research/sequencer.md`.
- En el constructor de `SequencerModule` (`AudioModules.cpp`), el preset de demo que genera la escala de C mayor inicializa ahora también `step.pitches`, limpiando el vector y añadiendo el `step.pitch` como única entrada para los pasos activos; los pasos desactivados mantienen el vector vacío. Esto garantiza que cualquier código futuro que itere sobre `pitches` vea una representación coherente incluso cuando no hay datos procedentes de un `.rtp`.
- `SequencerModule::SyncPresetsFromTracks()` se ha actualizado para mantener sincronizados `pitch` y `pitches` al proyectar los `SequenceTrack` derivados del `.rtp`: después de calcular y clamplear el `pitch` por step, se vacía `step.pitches` y, si el paso está habilitado, se inserta ese `step.pitch` como único elemento. De esta forma, el loader de patches ya rellena una vista "poly-ready" (un vector por step) aunque el runtime que dispara notas desde `MainComponent_Audio` siga tratando cada step como estrictamente monofónico.

### Introducción de MidiNoteEvent en el runtime del Sequencer
- Se ha incluido `core/src/core/MidiTypes.h` en `MainComponent_Audio.cpp` y se ha introducido una estructura `MidiNoteEvent` real en el runtime del `SequencerModule`. La lambda `runSequencerStep` construye ahora, para cada paso activo, un `rectai::MidiNoteEvent` con `channel=0`, `note` igual al `pitch` del step (clamp a `[0,127]`), `velocity01` clampada a `[0,1]` y `timeBeats` tomado de un nuevo contador `transportBeats_` que se incrementa en cada beat del transporte global.
- En lugar de usar directamente `step.pitch`/`step.velocity01` al disparar módulos destino, el runtime pasa por este `MidiNoteEvent`: para `SampleplayModule`, el evento se combina con el nivel propio del módulo (`amp`, `base_level`, `level_range`) y el volumen global `globalVolumeGain` para obtener una `effectiveVelocity` que se usa al llamar a `audioEngine_.triggerSampleplayNote(bank, program, noteEvent.note, effectiveVelocity)`; cuando `sequencerControlsVolume_` es `false`, la velocidad del step se ignora y solo afectan el volumen global y el nivel del módulo.
- Para `OscillatorModule`, el runtime convierte `noteEvent.note` a frecuencia en Hz (`440 * 2^((note-69)/12)`) y actualiza el parámetro `freq` normalizado del oscilador como antes, pero ahora usa `noteEvent.velocity01` (clampado) para el parámetro `gain` cuando `sequencerControlsVolume_` está activado. De este modo, tanto Sampleplay como Oscillator consumen la misma descripción lógica de nota, y el paso a modos polifónicos o a un scheduler MIDI más rico podrá concentrarse en cómo se generan/encolan `MidiNoteEvent` sin cambiar la firma de los módulos destino.

### Ajuste de enumeración de bancos SF2 para presets de percusión
- Se ha ampliado el rango de bancos que recorre `EnumerateSoundfontPresets` en `core/src/core/SoundfontUtils.cpp`: antes solo se probaban combinaciones `bank 0..127`, ahora se exploran bancos `0..255` manteniendo el rango de programas en `0..127`. Esto permite detectar presets que algunos soundfonts colocan en bancos superiores (por ejemplo, bancos de percusión en `bank >= 128`) sin depender de APIs de iteración internas de FluidSynth.
- La herramienta de depuración `tools/list_sf2_presets.cpp` se ha actualizado en paralelo para listar también presets en bancos `0..255`, de forma que al inspeccionar el archivo `com.reactable/Soundfonts/default.sf2` desde línea de comandos se vean todos los presets relevantes, incluidos posibles kits de percusión o bancos extendidos que no aparecían cuando solo se iteraba hasta el banco 127.
 - `MainComponent::loadSampleplaySoundfonts` incorpora ahora una heurística específica para los bancos de drums definidos en los patches Reactable que se apoya principalmente en los bancos físicos del SoundFont: cuando un `<instrument>` del `.rtp` tiene un nombre que contiene `"Drumset"` o `"Drum"` y no existe ningún preset SF2 con ese nombre exacto, se intenta primero asignar un preset que viva en un banco distinto de 0 (priorizando bancos altos `>= 128`, típicamente usados para percusión en SoundFonts GM/GS). Si el soundfont sólo usa el banco 0, como ocurre con el `default.sf2` incluido en el repo, se hace un último intento genérico buscando presets cuyo nombre sugiera percusión (`"Percussion"`, `"Kit"` o `"Drum"`). Si aun así no hay candidato específico, se deja el índice sin asignar y la lógica de fallback posterior elige el primer preset válido disponible. De esta manera el banco lógico de drums suele acabar asociado a un kit percusivo real, pero sin depender de nombres hardcodeados de un SF2 concreto.


## 2025-12-12
 - Ajustado el runtime del Sequencer para avanzar un paso por beat global y no por subdivisión continua, de modo que la demo de escala suene claramente a tiempo.
 - Introducido flag `sequencerControlsVolume_` en `MainComponent` para permitir experimentalmente que el Sequencer module el volumen (velocidad/gain) de módulos destino; valor por defecto `false` para no interferir con volumen que pueda venir por MIDI u otras fuentes.
 - Alineada la lógica de hit-testing de líneas a Master en `MainComponent_Input` con el pintado en `MainComponent_Paint`: solo módulos que producen/consumen audio tienen línea (y click) hacia Master, evitando que `Sequencer` (solo MIDI) tenga una línea invisible que pueda silenciarse por accidente.
 - Extendida la lógica de gesto de corte en `mouseDrag` para que también sólo considere líneas objeto->centro de módulos de audio, de nuevo excluyendo `Sequencer` y otros módulos sólo MIDI/control de los cortes que mutearían por accidente.
  - Primero pide a `SampleplaySynth::render` que escriba el audio de todos los Sampleplay activos en los buffers izquierdo/derecho.
  - Luego genera como antes las voces procedurales (osciladores/ruido) y suma su mezcla mono (`oscMixed`) sobre el contenido de FluidSynth, aplicando limitación suave por canal y escribiendo una salida estéreo (`leftOut`, `rightOut`) a los canales de dispositivo, manteniendo el buffer de historia `waveformBuffer_` basado en el canal izquierdo mezclado.
  - Se han añadido métodos públicos `setSampleplaySoundfont(const std::string&)` (para cargar el `.sf2` en el motor) y `triggerSampleplayNote(int bank, int program, int midiKey, float velocity01)` (para lanzar notas desde la capa de UI/escena).
- En `MainComponent.cpp`, el lambda `loadSampleplaySoundfonts` vuelve a recorrer los `SampleplayModule` de la escena y, tras validar el SF2 con `SampleplayModule::LoadSoundfont` y reconstruir la lista de instrumentos desde `EnumerateSoundfontPresets`, informa al `AudioEngine` de la ruta definitiva del primer soundfont válido encontrado llamando a `audioEngine_.setSampleplaySoundfont(sampleModule->soundfont_path())`. De este modo, el motor de audio y el modelo de dominio comparten el mismo archivo SoundFont cargado desde `com.reactable/Soundfonts`.
- En `MainComponent_Audio.cpp` se ha introducido el método privado `MainComponent::triggerSampleplayNotesOnBeat(bool strongBeat)`, invocado desde `timerCallback` cada vez que `beatPhase_` cruza el límite de un nuevo beat. Este método:
  - Calcula de nuevo el volumen global (mapeo dB desde el parámetro `volume` del `VolumeModule`).
  - Recorre todos los objetos `Sampleplay` dentro del área musical que no estén muteados.
  - Para cada módulo toma el instrumento activo (`SampleInstrument` con `bank` y `program` desde el SF2), deriva una nota MIDI desde el parámetro `midifreq` (redondeando a entero) y calcula una `velocity` normalizada en función de `amp`, `base_level`, `level_range` y el volumen global, con un ligero refuerzo en los beats fuertes (`strongBeat`).
  - Llama a `audioEngine_.triggerSampleplayNote(bank, program, midiKey, velocity01)` para disparar la nota correspondiente en FluidSynth, y marca el id del módulo en `modulesWithActiveAudio_` para que la capa de pintura pueda seguir resaltando sus conexiones como “activas”.

### Ajuste de mute master y rendimiento de audio
- Se ha desacoplado el estado visual de mute del master (`masterMuted_`, derivado del tangible `Output` con atributo `muted`) de la ruta real de audio en `MainComponent_Audio.cpp`. Antes, si el patch `.rtp` marcaba el Output como muteado, tanto los osciladores como el audio de Sampleplay quedaban silenciados completamente, lo que hacía que escenas que venían con el master en `muted=1` no reprodujeran nada aunque el resto de módulos estuvieran activos.
- La ganancia global de Sampleplay (`sampleplayOutputGain`) ahora solo depende del volumen global y de la presencia de al menos un `SampleplayModule` no muteado dentro del área musical; el flag `masterMuted_` ya no fuerza `sampleplayOutputGain = 0`. El mute del master sigue afectando únicamente a la representación visual del nodo central (alpha de color y pulsos), manteniendo compatibilidad con patches antiguos sin introducir silencios inesperados.
- De forma análoga, el cálculo del nivel por voz para generadores (`OscillatorModule` y similares) ya no incluye `masterMuted_` en la condición que fuerza `outputLevel = 0.0F`; solo se considera el estado de mute de la cadena (módulo fuente, módulo destino y conexión) y el “hold” temporal introducido por los gestos de click-and-hold sobre líneas. Esto garantiza que el audio de los generadores no desaparezca simplemente porque el Output tangible venga marcado como muteado en el patch.
- Se han eliminado los logs de depuración de filtros en `MainComponent_Audio.cpp` que se emitían en builds de depuración (`!NDEBUG`) para cada cadena `Oscillator → Filter` en cada tick del `timerCallback`. Estos logs resultaban útiles para diagnosticar el cutoff/Q del filtro, pero generaban un volumen de salida elevado que degradaba notablemente el rendimiento en builds de desarrollo; al retirarlos, el bucle de audio vuelve a ejecutarse sin coste extra de logging.
- La lógica provisional anterior de Sampleplay en `MainComponent_Audio.cpp` que generaba un tono senoidal simple sincronizado al tempo (gate de `beatPhase_ < 0.25` y uso de voces del `AudioEngine`) se ha eliminado: ahora el audio de Sampleplay proviene exclusivamente del motor de SoundFont (FluidSynth) y ya no ocupa voces procedurales del oscilador. La UI de Sampleplay (título de instrumento, click derecho para ciclar instrumentos) se mantiene sin cambios.

### Módulo Sampleplay: instrumentos, SoundFont y tono básico al tempo
- `SampleplayModule` en `core/src/core/AudioModules.{h,cpp}` ahora mantiene una lista de instrumentos (`SampleInstrument`) con un índice de instrumento activo (`active_instrument_index_`), incluyendo helpers para obtener el instrumento actual (`active_instrument()`), fijar el índice y ciclarlo (`CycleInstrument()`), de forma que la UI pueda mostrar y cambiar el instrumento seleccionado.
- El loader de patches Reactable `.rtp` en `core/src/core/ReactableRtpLoader.cpp` captura el atributo `filename` de los tangibles `Sampleplay`, lo almacena en el módulo mediante `set_raw_soundfont_name`, omite este atributo de la conversión numérica genérica y selecciona por defecto el primer `<instrument>` como instrumento activo cuando exista.
- En `MainComponent.cpp` se añade una pasada posterior a la carga de la escena (`loadSampleplaySoundfonts`) que recorre todos los `SampleplayModule` y resuelve su SoundFont2 usando `rectai::ui::loadFile("Soundfonts/<filename>")`. Para cada módulo encontrado intenta cargar el archivo con `SampleplayModule::LoadSoundfont`, validando el encabezado SF2 y dejando trazas de log en caso de error o ausencia de fichero.
- `MainComponent_Paint.cpp` dibuja ahora, a la derecha de cada nodo `Sampleplay`, el nombre del instrumento activo (texto alineado a la izquierda) respetando la rotación del módulo dentro del área musical, de modo que el título acompaña visualmente al cubo y refleja siempre el instrumento seleccionado.
- `MainComponent_Input.cpp` extiende el manejo de click derecho sobre módulos: además de ciclar la forma de onda de `OscillatorModule` y el modo de `FilterModule`, un click derecho sobre un `SampleplayModule` llama a `CycleInstrument()`, alternando entre los instrumentos declarados en el patch y provocando que el título mostrado junto al módulo se actualice inmediatamente.
- En `MainComponent_Audio.cpp` se integra un comportamiento provisional de audio para `Sampleplay`: cada Sampleplay presente en el área musical genera un tono senoidal simple sincronizado con el tempo global (una nota por beat). La altura se deriva del parámetro `midifreq` (conversión MIDI→Hz) y el nivel del parámetro `amp`, escalado por la curva de volumen global. El tono sólo suena durante el primer cuarto de cada beat (ventana de `beatPhase_ < 0.25`), de modo que, por defecto, el módulo Sampleplay produce ya un patrón rítmico básico ligado al BPM sin requerir un motor de reproducción de SoundFont completo.

### Mejora de visibilidad de la base circular de los módulos
- En `MainComponent_Paint.cpp` se ha añadido un contorno explícito de alto contraste alrededor del cuerpo circular de cada módulo, tanto en la mesa como en el dock, de forma que la “redonda” bajo cada módulo sea claramente visible incluso cuando el color de relleno está muy próximo al fondo.
- El color del contorno se elige dinámicamente en función del brillo del módulo (blanco sobre módulos oscuros, negro sobre módulos claros), manteniendo la legibilidad de la silueta sin interferir con la paleta de colores cargada desde los patches `.rtp`.
 - Además, el color de relleno del nodo se fuerza a ser completamente opaco (`alpha = 1.0`) en la función `getBodyColourForObject`, de modo que aunque algún color ARGB procedente del `.rtp` lleve un canal alpha bajo, la base circular siempre se renderiza como un disco sólido y coloreado.

### Color por defecto unificado y simplificación de nodos
- En `ReactableRtpLoader.cpp`, cuando un `<tangible>` no declara explícitamente un atributo `color`, el loader ya no conserva el color por defecto definido en el constructor del módulo, sino que sobrescribe el color visual con un valor unificado oscuro `#111111` (`0xFF111111`). Esto garantiza que todos los módulos sin color definido en el `.rtp` comparten una base visual coherente y claramente diferenciable de los módulos coloreados (loops, sampleplays, oscillators, etc.).
- En `MainComponent_Paint.cpp` se han eliminado los dos círculos adicionales de “aura” bajo cada módulo, tanto en la mesa como en el dock; ahora solo se dibuja el círculo principal del módulo (más su contorno), simplificando la lectura visual y acercando el diseño a la representación más plana que estamos buscando para depurar la paleta de colores.

### Corrección de conversión ARGB → `juce::Colour`
- Corregida la función `colourFromArgb` en `MainComponentHelpers.cpp`: antes construía `juce::Colour` pasando los cuatro componentes como si el constructor fuera `(alpha, red, green, blue)`, cuando en realidad el constructor de 4 parámetros espera `(red, green, blue, alpha)`. Esto provocaba un corrimiento de canales y que muchos colores se vieran rojizos/blanquecinos.
- La función ahora extrae los componentes ARGB y usa explícitamente `juce::Colour::fromARGB(alpha, red, green, blue)`, de forma que los colores procedentes de `colour_argb()` (incluidos los `color="..."` del `.rtp`) se respetan exactamente en la UI.
### Opacidad diferenciada para pulsos de tempo
- Ajustado el render de los anillos de pulso en `MainComponent_Paint.cpp` para que los pulsos secundarios de tempo (beats intermedios) se dibujen con menor opacidad que el pulso que marca el beat principal del compás.
- La estructura `Pulse` sigue marcando los beats fuertes con `strong = true` cada 4 golpes (`beatIndex_`), pero ahora el cálculo de alpha distingue entre ambos: el pulso principal mantiene la opacidad base dependiente de la edad del pulso y del estado de mute del master, mientras que los pulsos secundarios escalan esa opacidad por un factor adicional (≈40%).
- Este cambio hace que el ritmo siga siendo claramente visible, pero refuerza visualmente el beat fuerte del compás como referencia rítmica principal, alineando la jerarquía de brillo con el diseño descrito para la UI rítmica de la mesa.

### Fondo de mesa sólido y borde difuminado
- Actualizado el fondo de la mesa en `MainComponent_Paint.cpp` para que el disco principal se pinte con un color sólido `#001a80` (sin gradiente interno), alineado con la paleta azul oscura descrita para la superficie de la mesa.
- Introducido un anillo exterior alrededor de la mesa que se renderiza como una elipse con gradiente radial desde `#001a80` en el borde de la mesa hasta negro en el radio exterior, creando un difuminado suave entre la superficie y el fondo negro general.
- Eliminada la viñeta anterior basada en un simple trazo negro grueso alrededor del círculo y sustituida por este borde degradado, que integra mejor la mesa con el lienzo negro sin añadir contornos duros.

### Indicador visual de fallo de audio en la inicialización
- Se ha extendido `AudioEngine` en `core/src/AudioEngine.{h,cpp}` para detectar de forma genérica cualquier error que devuelva JUCE al inicializar el dispositivo de audio por defecto mediante `initialiseWithDefaultDevices(0, 2)`. Si la cadena de error no está vacía, se marca un flag interno `initError_` que indica que la inicialización de audio no ha sido satisfactoria (falta de backend, dispositivo inválido, ausencia de canales, etc.).
- Para mantener información más detallada cuando está disponible, se conserva también el flag específico `noOutputChannels_`, que se activa si el mensaje de error contiene la cadena `"no channels"`, de forma que futuras capas puedan distinguir este caso concreto si lo necesitan.
- Se han añadido dos getters ligeros en `AudioEngine`: `hasInitialisationError()` (estado genérico de fallo en la inicialización) y `hasNoOutputChannels()` (caso particular de ausencia de canales). La UI solo depende del primero para decidir el color de la mesa.
- En `MainComponent_Paint.cpp`, el color de la mesa ya no es fijo: si `audioEngine_.hasInitialisationError()` devuelve `true`, el disco principal de la mesa se pinta en rojo oscuro `#801a1a`; en caso contrario, mantiene el azul `#001a80` definido previamente. El anillo degradado exterior sigue utilizando como color interior el color actual de la mesa, de modo que el borde se adapta automáticamente al estado de audio.
- El mensaje de log existente `[rectai-core] Failed to initialise audio: ...` se conserva tal cual, pero ahora **cualquier** error de inicialización se refleja también visualmente en la UI a través del cambio de color de la mesa, facilitando detectar de un vistazo que la aplicación está corriendo sin un dispositivo de audio operativo o en un estado de audio degradado.

### Separación de gestos: sliders de módulo vs corte de líneas
- Introducido un flag explícito `isCutModeActive_` en `MainComponent` que distingue entre el modo de **interacción** (cursor blanco) y el modo de **corte de sonido** (cursor rojo con trail).
- `MainComponent::mouseDown` ahora solo activa `isCutModeActive_ = true` cuando el click comienza en espacio vacío del área musical (dentro del círculo de música, fuera del dock y sin haber capturado ni un módulo, ni un slider lateral, ni una línea para mute hold); en cualquier otra interacción el gesto permanece en modo blanco.
- `MainComponent::mouseDrag` condiciona la detección de cortes de líneas (`touchCutObjects_` y `touchCutConnections_`) a que `isCutModeActive_` sea verdadero y, además, a que no se esté arrastrando un módulo (`draggedObjectId_ == 0`), ajustando sliders (`sideControlKind_ == kNone`) ni manteniendo una línea en mute temporal (`!activeConnectionHold_`).
- `MainComponent::paint` usa ahora este flag para dibujar el cursor en blanco en todos los gestos de interacción (ajuste de frecuencia/ganancia, click-and-hold sobre líneas) y en rojo solo en gestos de corte iniciados en espacio vacío. Al arrastrar módulos sobre la mesa el cursor se oculta; en el caso de módulos sacados desde el dock, el cursor solo es visible mientras el puntero permanece dentro del propio dock.
- El hit-test de las barras laterales de frecuencia/ganancia se ha ampliado: ahora un click en **cualquier punto de la barra** mueve inmediatamente el valor del parámetro hasta esa posición y comienza un gesto de drag desde ahí, en lugar de requerir que el usuario acierte específicamente sobre el handle.

### Drop seguro con CONTROL para Loop/Oscillator/Sampleplay
- En `MainComponent_Input.cpp` se ha añadido la función auxiliar privada `applyControlDropMuteIfNeeded`, ahora invocada desde `mouseDrag` justo después de actualizar la posición del objeto arrastrado.
- Cuando, durante un drag con la tecla CONTROL pulsada, el objeto está sobre la mesa (posición actual en el área musical) y el módulo asociado es de tipo `OscillatorModule`, `LoopModule` o `SampleplayModule`, la función fuerza el parámetro de nivel correspondiente a 0: `gain = 0.0` para osciladores y `amp = 0.0` para loops y sampleplays.
- De este modo, el silencio se aplica en cuanto el módulo entra o se mueve dentro del área musical mientras se mantiene CONTROL, sin esperar al `mouseUp`, proporcionando una forma rápida de “colocar en silencio” estos módulos al situarlos en la mesa y permitiendo luego subir el nivel desde los controles laterales de ganancia.

### Mapeo de ganancia con verdadero 0% de volumen
- En `MainComponent_Audio.cpp` se ha ajustado el cálculo de `calculatedLevel` para que un parámetro de ganancia normalizado igual a `0.0` produzca un nivel efectivo de `0.0` (silencio real), en lugar de mantener siempre un mínimo basado en `base_level_`.
- El mapeo pasa de `calculatedLevel = base_level + level_range * gainParam` a una versión que devuelve 0 cuando `gainParam <= 0.0` y solo aplica el offset `base_level` para valores de ganancia mayores que 0, de forma que poner el slider de ganancia al mínimo realmente apaga el oscilador en audio (aunque se siga generando la forma de onda interna para visualización).

## 2025-12-16

### Barra lateral de Tempo ligada al BPM global
- El módulo `TempoModule` aprovecha ahora la misma barra lateral izquierda de "frecuencia" que usan los generadores, pero reinterpretada como control de tempo: cuando el tangible de Tempo está en la mesa (o en el dock), se muestra una barra vertical a su izquierda cuya posición refleja el BPM global normalizado en el rango [40, 400].
- En `MainComponent_Paint.cpp`, la frecuencia normalizada de los controles laterales se calcula, para `TempoModule`, a partir del valor global `bpm_` en lugar de leer un parámetro `freq`; además, la barra se fuerza a mostrarse aunque el módulo no marque `uses_frequency_control()` para no interferir con el mapeo genérico de frecuencia de otros módulos.
- En `MainComponent_Input.cpp`, tanto el click como el drag sobre la barra izquierda de un `TempoModule` actualizan el BPM global (`bpm_`) y sincronizan el parámetro lógico `tempo` del propio módulo, reutilizando la misma geometría de slider que el resto de tangibles pero mapeando la posición vertical a un BPM en el intervalo [40, 400]. También se actualiza `bpmLastChangeSeconds_` para que la etiqueta numérica de BPM siga mostrándose y haciendo fade tras interacciones con el slider, igual que ocurre con los gestos de rotación.
 - Además, la rueda del ratón sobre el nodo de Tempo en la mesa ajusta ahora el BPM global en pasos de ±1 por notch, o en pasos de ±5 cuando la tecla Shift está pulsada, manteniendo siempre el parámetro `tempo` del `TempoModule` sincronizado y respetando el mismo rango [40, 400].

## 2025-12-11

### Corrección de estiramiento de formas de onda según distancia
- Ajustado el render de formas de onda en `MainComponent_Paint.cpp` para que la muestra de audio utilizada en las líneas dependa de la **distancia en píxeles** y no de la longitud normalizada de la línea.
- `drawWaveformOnLine` ahora mapea un desplazamiento a lo largo de la línea (en píxeles) a la ventana de samples usando un factor fijo de "muestras por píxel" (con wrapping en el buffer), manteniendo así un patrón visual consistente (por ejemplo, el diente de sierra) aunque cambie la distancia entre un módulo y el Master o entre dos módulos conectados.
- `drawWaveformOnQuadratic` sigue el mismo principio utilizando una longitud aproximada de la curva (distancia entre extremos) para definir el avance por el buffer, de modo que las conexiones curvadas también conservan el mismo patrón de onda al mover los módulos.
- Este cambio elimina el efecto observado de formas de onda "comprimidas" cerca del centro y "estiradas" cuando los nodos se alejan, ya que la frecuencia espacial de la onda en pantalla pasa a ser estable e independiente de la longitud de la conexión.
 - Se ha incrementado la resolución del snapshot usado para visualización de cada voz de `128` a `512` samples (`kWaveformPoints`), mejorando la definición del patrón (especialmente en saw) a la vez que se sigue usando solo un ciclo estimado para repetir la forma a lo largo de líneas largas.

## 2025-12-09


### Servicio de tracking: modo sintético vs live y esqueleto de engine
- El binario `rectai-tracker` se ha estructurado para soportar dos modos de ejecución diferenciados:
  - Modo `--mode=synthetic` (por defecto), que conserva el comportamiento anterior: envía un único objeto sintético `/rectai/object` con `trackingId=1` y `logicalId="osc1"` moviéndose horizontalmente.
  - Modo `--mode=live`, que inicializa un nuevo `rectai::tracker::TrackerEngine` y pasa cada frame capturado para que devuelva una lista de `TrackedObject` con coordenadas normalizadas y ángulo en radianes.

### Validación de `default.rtp`, logs de depuración y mute persistente de una sola conexión

- Se añade un test específico en `tests/scene_tests.cpp` que busca `default.rtp` en varias rutas relativas (incluyendo `com.reactable/Resources/default.rtp`) usando `std::ifstream` para evitar dependencias de JUCE en los tests y, una vez localizado, lo carga con `LoadReactablePatchFromFile`. El test comprueba:
  - Presencia de los módulos clave: Output (`"-1"`), Volume (`"1"`), Tempo (`"2"`), Oscillator (`"46"`).
  - Que el master no arranca muteado (`metadata.master_muted == false`).
  - Que el Volume de `default.rtp` (volume="90") se normaliza a ~0.9 en el modelo.
  - Que el Oscillator `46` tiene un `gain` por defecto > 0 para poder sonar al colocarlo en la mesa.
  - Que existe una conexión auto-creada de `"46"` → `"-1"` (`out`→`in`) en `Scene::connections()`.
- Se añaden logs ligeros de depuración para investigar la ausencia de sonido y la desaparición de la línea entre Oscillator y Output:
  - En `MainComponent_Audio::timerCallback()` se registra, una vez por tick, el primer generador activo con: id, frecuencia en Hz, nivel calculado, nivel de salida tras volumen global, estado de mute de la cadena y módulo downstream (si lo hay).
  - En `MainComponent_Paint.cpp`, dentro del bucle que dibuja las líneas radiales centro→objeto, se añade un log por módulo de audio dentro del área musical indicando: `logical_id`, si es generador y si `objectsWithOutgoingActiveConnection` lo marca como alimentando otro módulo. Esto sirve para entender por qué una radial (Oscillator→master) puede ocultarse después de uno o pocos frames.
- Se introduce un estado de mute persistente a nivel de módulo para el caso en que un módulo sólo tenga **una** conexión activa (dinámica o hardlink, ignorando el auto-wiring a Output -1):
  - Nuevo miembro `modulesWithPersistentMute_` en `MainComponent` (set de `module_id`) que marca módulos cuyo "mute de línea única" debe conservarse aunque su única conexión cambie de destino.
  - En `MainComponent_Input::mouseUp`, al aplicar los cortes en `touchCutConnections_`, se localiza la `Connection` correspondiente a cada `connKey` y se calcula cuántas conexiones salientes activas tiene el módulo fuente (dentro del área musical, respetando el cono geométrico y excluyendo conexiones hacia `"-1"`).
    - Si el corte pasa de no muteado a muteado y el módulo tiene exactamente una conexión activa, se añade su `module_id` a `modulesWithPersistentMute_` además de marcar el `connKey` en `mutedConnections_`.
    - Si el corte pasa de muteado a no muteado, se elimina su `module_id` de `modulesWithPersistentMute_` para que la siguiente acción vuelva a comportarse como un toggle completo.
  - En `MainComponent_Audio.cpp`, tanto el flag `srcMuted` (mute de objeto) como `connectionMuted` combinan ahora `mutedObjects_`/`mutedConnections_` con `modulesWithPersistentMute_`, de forma que una vez que un Oscillator ha sido silenciado en condición de única conexión, la cadena de audio permanece muteada aunque la conexión se rehaga hacia otro módulo o al master.
  - En `MainComponent_Paint.cpp`, las líneas radiales centro→módulo y los cuerpos de los nodos (en mesa y dock) consideran también `modulesWithPersistentMute_` para reflejar visualmente este mute persistente, y las conexiones módulo→módulo tratan cualquier enlace saliente desde un módulo persistente como silenciado (línea discontinua) aunque su `connKey` no estuviera todavía en `mutedConnections_`.
  - Resultado: cuando un módulo tiene sólo una conexión activa y se corta esa línea (p.ej. Oscillator→Filter), el sistema recuerda que el módulo está globalmente silenciado; si más adelante su única conexión pasa a ser Oscillator→Master o a otro destino, el mute se conserva tanto en audio como en la representación de las líneas.
- Se ha introducido un pequeño modelo de tracking en `tracker/src/TrackerTypes.h` (`TrackedObject` + alias `TrackedObjectList`) y un esqueleto de `TrackerEngine` en `tracker/src/TrackerEngine.{h,cpp}` con API:
  - `bool initialise(int cameraIndex, int requestedWidth, int requestedHeight, std::string& errorMessage)` para preparar parámetros internos.
  - `TrackedObjectList processFrame(const cv::Mat& frame) const` para extraer objetos de cada frame (por ahora implementación placeholder sin detección real).
- `tracker/src/main.cpp` ahora:
  - Parsea `--mode=synthetic` / `--mode=live` desde línea de comandos.
  - En modo live, inicializa `TrackerEngine` con la resolución actual de la cámara y, en cada frame, obtiene una lista de objetos y envía un mensaje `/rectai/object` por cada uno, usando una función `mapLogicalId(int markerId)` para traducir ids numéricos a `logicalId` (por ahora mapeo fijo `1→osc1`, `2→filter1`).
  - Mantiene el cálculo de FPS y los mensajes de log con prefijo `[rectai-tracker]`.
- `tracker/CMakeLists.txt` se ha actualizado para compilar e incluir los nuevos archivos de tracking en el ejecutable `rectai-tracker`.
  - `Connection` y operaciones de alta coherencia sobre la escena.
- Tests sencillos en `tests/scene_tests.cpp` que validan:
  - Inserción única de módulos.
  - Creación y eliminación de conexiones.
  - Semántica de upsert/borrado de `ObjectInstance`.
- UI JUCE mínima (`rectai-core`):
  - `MainComponent` pinta una escena de ejemplo con dos módulos (`osc1`, `filter1`).
  - Dibujo de objetos como círculos y conexiones como líneas entre ellos.
  - Interacción básica de ratón: click-and-drag sobre los círculos actualiza la posición normalizada de los objetos en la `Scene` y repinta.

### Servicio de tracking (skeleton)
- Binario `rectai-tracker` basado en OpenCV (`tracker/src/main.cpp`):
  - Abre la cámara por defecto.
  - Bucle principal que lee frames y calcula FPS aproximados cada segundo.
  - Mensajes de log en inglés con prefijo `[rectai-tracker]`.
  - Emisor OSC mínimo (`OscSender`) que envía mensajes `/rectai/object` sintéticos
    hacia `localhost:3333` para ejercitar el flujo tracking → core → UI incluso
    sin detección real de marcadores.

### Integración inicial de protocolo de tracking (OSC)
- Añadido módulo de JUCE `juce_osc` a la aplicación principal (`core/CMakeLists.txt`).
- Nueva clase `TrackingOscReceiver` en `core/src/TrackingOscReceiver.{h,cpp}`:
  - Usa `juce::OSCReceiver` con callbacks en el message loop.
  - Escucha en el puerto UDP `3333` (alineado con configuraciones típicas de TUIO).
  - Protocolo OSC minimalista para MVP:
    - `/rectai/object` (int32 trackingId, string logicalId, float x, float y, float angleRadians) → `Scene::UpsertObject`.
    - `/rectai/remove` (int32 trackingId) → `Scene::RemoveObject`.
  - Mensajes de log en caso de fallo al bindear el puerto o recibir argumentos inválidos.
- `MainComponent` mantiene ahora un miembro `TrackingOscReceiver trackingOscReceiver_{scene_, 3333};` que conecta la `Scene` con el receptor OSC.

### Motor de audio (esqueleto)
- Añadido `AudioEngine` en `core/src/AudioEngine.{h,cpp}`:
  - Envuelve un `juce::AudioDeviceManager` inicializado con las salidas por defecto (estéreo, sin entradas).
  - Implementa `juce::AudioIODeviceCallback` para generar un tono senoidal de prueba (A4, 440 Hz) a nivel bajo, validando la canalización de audio.
  - Punto de partida para evolucionar hacia un grafo de módulos que mapee `rectai::ModuleType`/`AudioModule` a nodos de procesamiento.
- `RectaiApplication` instancia un `AudioEngine` de larga vida para que el audio se active junto con la aplicación JUCE.

### Diseño de UI rítmica inicial
- Fondo y mesa:
  - Lienzo circular centrado con gradiente azul (más claro en el centro, más oscuro hacia el borde), simulando la "superficie" de la mesa reactiva descrita en `ui-interface.md`.
  - Ligeras viñetas y contorno para reforzar la sensación de proyección de luz.
- Pulso central:
  - Círculo blanco constante en el centro de la mesa.
  - Ondas concéntricas (anillos que se expanden y se desvanecen) sincronizadas con el tempo (BPM), con el primer pulso de cada 4 más grande y grueso (marcando el compás 4/4).
- Objetos/nodos:
  - Renderizados como círculos con un aura luminosa (dos halos concéntricos suaves) bajo cada objeto.
  - Cada nodo muestra un arco de parámetro alrededor (actualmente mapeado a la posición X normalizada) con un punto brillante indicando el valor actual.
  - La paleta sigue la guía de colores: fondo azul oscuro, nodos activos en azul eléctrico y UI en blanco con distintos niveles de transparencia.
- Conexiones:
  - Todos los objetos/instrumentos se conectan visualmente con el centro mediante líneas blancas.
  - Línea continua si el objeto está activo y línea discontinua si el objeto está en estado mute.
  - Click sobre una línea centro→objeto alterna el mute del instrumento, que a su vez controla el nivel del tono generado por `AudioEngine`.

### Limpieza de idioma y comentarios
- Comentarios de `Scene.h` traducidos al inglés para seguir la convención del proyecto.
- Título de la UI en `MainComponent::paint` actualizado a "RectaiTable - Example scene".

## 2025-12-10

### AudioModules y metadata unificada
- `rectai::Scene` ahora almacena instancias polimórficas de `AudioModule`, cada una con:
  - `ModuleType` (SEQUENCER, AUDIO, GENERATOR, FILTER, SETTINGS) para clasificar familias lógicas.
  - Capacidades de audio (`produces_audio`, `consumes_audio`) y políticas de conexión overrideables por módulo.
  - Metadatos UI (`colour_argb`, `label`, `description`, `icon_id`) más flags para reutilizar los sliders de frecuencia y ganancia según convenga.
- Nuevos módulos concretos:
  - `OscillatorModule`: generador con salida audio, sliders de freq/gain activos, color azul y conexión permitida hacia módulos FILTER/AUDIO.
  - `FilterModule`: módulo de paso con entrada/salida audio, sliders de cutoff/gain activos y política de conexión abierta.
- `MainComponent` consume ahora esta metadata para:
  - Pintar colores/aura basados en el color declarado por cada `AudioModule`.
  - Mostrar u ocultar los sliders laterales en función de `uses_frequency_control` / `uses_gain_control`.
  - Renderizar iconos mediante `icon_id` y etiquetar cada nodo con `label (logical_id)`.
  - Consultar valores por defecto de parámetros (`freq`, `gain`, etc.) a través de `AudioModule::default_parameter_value`, de modo que los `0.5F` por defecto viven en `AudioModules.cpp` en lugar de estar duplicados en `MainComponent`.
- `tests/scene_tests.cpp` se actualiza para instanciar módulos concretos (`OscillatorModule`, `FilterModule`) usando `std::unique_ptr`, reflejando la API `Scene::AddModule(std::unique_ptr<AudioModule>)`.
- Nueva cabecera `core/src/core/AudioModules.{h,cpp}` centraliza las implementaciones concretas para que puedan reutilizarse tanto por la UI como por futuros motores de audio.

### Refinado de interfaz visual según `ui-interface.md`
- Fondo y núcleo central:
  - Se mantiene el lienzo circular azul con gradiente y viñeta, actuando como superficie principal de la mesa reactiva.
  - El núcleo central incorpora ahora ondas expansivas más rítmicas y se usa como punto de convergencia visual de las conexiones.
- Nodos/objetos tangibles:
  - Cada `ObjectInstance` toma su color base del metadato `colour_argb()` expuesto por el `AudioModule` asociado (oscillator, filter, effect, sampler, controller), manteniendo la paleta de azules, verdes, púrpuras y naranjas para diferenciar tipos.
  - El aura bajo cada nodo está tintada con el color del módulo y se dibujan dos halos concéntricos suaves, aproximando el efecto de glow/bloom descrito en `ui-interface.md`.
  - Dentro del cuerpo del nodo se renderizan iconos estilizados según el tipo de módulo (onda sinusoidal para osciladores, curva tipo filtro, barras estilo sampler, anillos para controladores, etc.).
- Anillos de parámetros:
  - Se ha sustituido el único arco de parámetro por dos anillos concéntricos: uno interior que representa un valor derivado de la posición X del objeto y otro exterior que actúa como barra de progreso circular ligada a la fase de tempo global.
  - Ambos anillos se orientan usando la rotación (`angle_radians`) del objeto, de forma que los parámetros “siguen” la orientación física del tangible sobre la mesa.
- Conexiones y flujo de señal:
  - Las conexiones entre módulos (`Scene::connections`) se dibujan como curvas de Bézier suaves.
  - Se añade un pequeño pulso luminoso que recorre cada conexión con un desfase por índice, simulando el flujo de audio entre módulos además de las líneas centro→objeto que ya existían.
- Widgets especiales:
  - El widget de secuenciador (grid de puntos) se posiciona ahora utilizando la rotación del objeto cuya `logical_id` empieza por `"seq"`, proyectando la cuadrícula hacia la dirección del cubo físico.
  - Se mantiene el menú radial de parámetros alrededor del objeto seleccionado, alineado con la estética de menús radiales flotantes descrita en `ui-interface.md`.

### Flujo de señal por sectores y mute por instrumento
- Conexiones espaciales entre instrumentos por sectores:
  - La heurística `isConnectionGeometricallyActive` ahora divide el área musical en cuatro sectores angulares alrededor del centro (90º cada uno en coordenadas normalizadas de la mesa).
  - Dos instrumentos se consideran conectados (p.ej. `osc1 → filter1`) solo si ambos caen en el mismo sector; en ese caso se dibuja la línea curvada entre ellos con su pulso animado.
- Rutas hacia Master y líneas individuales:
  - Cada instrumento mantiene siempre su línea directa `instrumento → Master`, independientemente de si está conectado a otro. Esto permite que cada fiducial tenga un control de mute propio, visible y clickable en todo momento.
- Mute independiente pero con efecto en la cadena de audio:
  - Cada instrumento gestiona su propio estado de mute (click sobre su línea al centro), de forma independiente de las conexiones activas.
  - En el caso `osc1`/`filter1`, cuando hay conexión activa en el mismo sector, el audio que se oye sigue siendo la cadena oscilador→filtro→Master, pero si cualquiera de los dos instrumentos está en estado mute, la salida conjunta se silencia.
  - Cuando no hay conexión activa por sector, solo el mute del oscilador afecta al audio generado (el filtro no forma parte de la ruta audible en ese caso, aunque su estado de mute se conserve para cuando vuelva a entrar en cadena).

### Ajuste de conexiones según área de música
- Las conexiones visuales `instrumento → instrumento` (curvas con pulso) solo se consideran activas y se dibujan cuando **ambos** instrumentos están dentro del círculo de música y el destino cae dentro de un cono desde el centro en dirección al origen (inicialmente 90º, ampliado posteriormente a 120º).
- Si cualquiera de los dos objetos sale fuera del área de música, la conexión desaparece visualmente y deja de participar en el routing lógico:
  - En el caso `osc1 → filter1`, si el filtro queda fuera del círculo, la cadena osc→filtro se considera no válida y el audio se silencia para evitar una ruta incoherente hacia el Master.
- El hit-test para mutear conexiones entre instrumentos también respeta esta regla: solo se puede mutear una conexión clicando sobre ella si ambos instrumentos están dentro del área de música.

### Ajuste del ángulo del cono de conexión
- Se ha reajustado el cono geométrico de conexión entre instrumentos para que `isConnectionGeometricallyActive` utilice ahora un ángulo total de 120º alrededor del origen (60º de semicono). Esto mantiene la idea de sectores angulares alrededor del centro y ofrece una tolerancia algo más amplia, de modo que cuando dos módulos están razonablemente alineados dentro de ese cono se considera que la conexión dinámica está activa.

### Forma de las conexiones dinámicas en la UI
- Las conexiones entre módulos (`Scene::connections`) que no son hardlink (conexiones dinámicas) se renderizan ahora como segmentos rectos en lugar de curvas de Bézier. El pulso animado que recorre la conexión se mueve linealmente desde el módulo de origen al de destino, y la visualización de waveform también se dibuja sobre la línea recta (`drawWaveformOnLine`), lo que hace que la geometría de las conexiones dinámicas coincida mejor con la expectativa visual de "línea directa" entre módulos cercanos.

### Creación automática de conexiones dinámicas por disposición espacial
- En `MainComponent::timerCallback` se ha añadido una pasada de mantenimiento que recorre los pares de objetos dentro del área musical y, para cada par de módulos compatibles según `AudioModule::CanConnectTo`, crea automáticamente una conexión dinámica (`Connection` con `is_hardlink = false`) desde el módulo origen al destino cuando el objeto destino cae dentro del cono geométrico de 105º definido por `isConnectionGeometricallyActive`.
- Estas conexiones automáticas utilizan siempre los puertos estándar `out → in` y solo se crean cuando no existe ya ninguna conexión entre ese par de módulos, de modo que no interfieren con hardlinks existentes ni con conexiones explícitas que se puedan definir en el futuro.

### Alineación del área de música con la UI
- La función de utilidad `isInsideMusicArea` se ha movido a `MainComponent` y ahora calcula el área musical en coordenadas de píxel usando exactamente el mismo centro y radio que el círculo de la mesa renderizado en `paint`.
- Esto garantiza que un instrumento se desactive justo cuando su nodo sale visualmente del círculo azul (zona con fondo negro), independientemente de la relación de aspecto de la ventana.

### Próximos pasos sugeridos (UI)
- Introducir un efecto de glow/bloom real mediante un pipeline de renderizado con OpenGL o similar, en lugar de aproximarlo solo con halos y transparencias.
- Experimentar con blending aditivo global para que las intersecciones de líneas y halos incrementen el brillo de forma más marcada.
- Hacer que algunos parámetros visuales (arcos, intensidad de auras, velocidad de pulsos) respondan a métricas de audio reales en `AudioEngine` (niveles RMS, envolventes, etc.).

## Próximos pasos sugeridos (Roadmap corto)
- **Tracking/protocolo**:
  - Extender `rectai-tracker` para enviar mensajes OSC reales compatibles con el protocolo `/rectai/object` y `/rectai/remove` (más allá de los datos sintéticos actuales).
  - Evaluar si se quiere aproximar al formato TUIO estándar o mantener este canal OSC simplificado como modo de debug.
- **Audio**:
  - Evolucionar `AudioEngine` desde el tono único actual hacia varias voces/módulos (p.ej., una voz por `ObjectInstance` asociado a un `OscillatorModule`).
  - A medio plazo, introducir un `AudioProcessorGraph` o equivalente que mapee `AudioModuleType` a nodos de procesamiento reutilizables.
- **UI/Escenas**:
  - Completar la deserialización (carga) de escenas usando el formato line-based `rectai_scene_v1` de `SceneSerialization` o migrar a un formato JSON cuando se introduzca una librería dedicada.
  - Añadir comandos básicos a la UI para guardar la `Scene` actual en disco y recargarla (presets simples).

### Corrección visual de mute en cadenas Oscilador → Filtro
- Ajustada la lógica de dibujo de líneas centro→objeto en `MainComponent` para que los instrumentos silenciados mantengan siempre visible su línea discontinua hacia el centro, incluso cuando están alimentando a otro módulo mediante una conexión activa.
- Ahora, si un oscilador está en mute pero conectado a un filtro, su línea hacia el Master sigue mostrándose como discontinua, evitando que la “línea silenciada” desaparezca cuando se configura la cadena `osc1 → filter1`.

### Cambio de mapeo de frecuencia del oscilador
- La frecuencia del oscilador deja de depender de la posición X del objeto en la mesa y pasa a controlarse únicamente mediante el parámetro `freq` del módulo (`slider` lateral en la UI).
- En `MainComponent::timerCallback`, la frecuencia se calcula ahora como un rango fijo (aprox. 200–1000 Hz) derivado solo del valor del slider, manteniendo la interacción tangible para mute/posición dentro del área musical pero sin afectar al pitch.

### Visibilidad de líneas y rutas activas hacia Master
- Ajustadas las conexiones centro→objeto en `MainComponent` para que **todas** las líneas de instrumentos permanezcan siempre visibles mientras el objeto esté dentro del área musical; cada instrumento conserva su propia línea hacia el centro.
- Cuando un instrumento alimenta a otro mediante una conexión espacial activa, su línea se dibuja ligeramente atenuada y sin pulso animado, de modo que solo el instrumento aguas abajo (p.ej. el filtro) muestra el pulso hacia Master, reflejando mejor la ruta de audio efectiva sin perder el control visual de mute por instrumento.

### Enrutado visual y mute de conexión Oscilador → Filtro
- Cuando el oscilador (`osc1`) tiene una conexión espacialmente activa hacia el filtro (`filter1`), deja de dibujarse la línea directa oscilador→Master (centro); solo el filtro mantiene la línea activa hacia el núcleo central, reforzando visualmente que la ruta efectiva pasa por el filtro.
- Se ha introducido un estado de mute por conexión (`mutedConnections_` en `MainComponent`) indexado por un identificador estable de `rectai::Connection`.
- Las conexiones entre módulos se dibujan como:
  - Curvas con pulso animado cuando están activas.
  - Líneas rectas punteadas (sin pulso) cuando la conexión está silenciada, manteniendo la legibilidad topológica de la escena.
- El click sobre la línea entre instrumentos ya no mutea el objeto de origen, sino que conmuta el estado de mute de la conexión correspondiente (por ahora especialmente útil en la cadena `osc1 → filter1`).
- La lógica de audio en `timerCallback` tiene en cuenta el mute de conexión: si la conexión `osc1→filter1` está silenciada, la cadena completa osc→filtro→Master se considera muda (el oscilador no vuelve a alimentarse directamente al Master mientras exista esa conexión), respetando siempre los estados de mute por objeto.

### Esquema del formato Reactable `.rtp`
- Documentado el archivo `research/reactable_rtp_schema.md` describiendo la estructura XML de Reactable (`<reactablepatch>`, `<background>`, `<tangibles>/<tangible>`, `<author>`, `<patch>`), con detalle por tipo de tangible (`Output`, `Tonalizer`, `Volume`, `Tempo`, `Accelerometer`, `LFO`, `Sequencer`, `Filter`, `Delay`, `Modulator`, `WaveShaper`, `Input`, `Loop`, `Oscillator`, `Sampleplay`).
- Se definen los subelementos compartidos (`<envelope>`, `<loop>`, `<hardlink>`, `<tone>`, `<sequence>`, `<instrument>`) y su significado, así como los atributos relevantes de cada uno.
- El documento establece el mapeo conceptual entre cada `<tangible>` y el modelo actual de Rectai: cada tangible se descompone en un `ObjectInstance` (instancia física sobre la mesa) y un `AudioModule` concreto (módulo lógico de audio/control) con parámetros y estructuras auxiliares.
- Se identifican los tipos de módulos y estructuras que faltan en el proyecto (por ejemplo, `TonalizerModule`, `SequencerModule`, `LoopModule`, `SampleplayModule`, estructuras `Envelope`, `SequenceTrack`, `LoopDefinition`, `ToneDefinition`, `SampleInstrument`, etc.) para que el futuro loader pueda reconstruir escenas completas a partir de archivos `.rtp` originales.
 
### Nuevos módulos y estructuras derivadas del esquema `.rtp`
- Añadidas estructuras de datos en `core/src/core/AudioModules.h` para representar elementos del formato Reactable: `Envelope`, `LoopDefinition`, `ToneDefinition`, `SequenceTrack` (incluyendo capas `tenori0..tenori12`) y `SampleInstrument`.
- Extendidos los módulos existentes `OscillatorModule` y `FilterModule` con soporte interno para un `Envelope`, preparando el terreno para mapear directamente los `<envelope>` del `.rtp`.
- Implementados nuevos módulos concretos alineados con los tipos de `<tangible>` de Reactable: `OutputModule`, `TonalizerModule`, `VolumeModule`, `TempoModule`, `AccelerometerModule`, `LfoModule`, `SequencerModule`, `DelayModule`, `ModulatorModule`, `WaveShaperModule`, `InputModule`, `LoopModule` y `SampleplayModule`, todos heredando de `AudioModule` y configurando metadatos de UI, puertos y parámetros por defecto inspirados en los atributos del `.rtp`.
- Estos módulos todavía no se usan en la UI ni en los tests, pero proporcionan una capa de modelo coherente para implementar a continuación el loader de archivos `.rtp` y poblar `rectai::Scene` con instancias que reflejen fielmente los patches originales de Reactable.

### Loader de patches Reactable `.rtp` y hardlinks
- Añadido `core/src/core/ReactableRtpLoader.{h,cpp}` con una API `LoadReactablePatchFromString` / `LoadReactablePatchFromFile` que parsea directamente archivos `.rtp` XML (sin cambiar su estructura) y construye un `rectai::Scene` con módulos concretos (`OutputModule`, `DelayModule`, `OscillatorModule`, `SequencerModule`, `LoopModule`, etc.) y `ObjectInstance` para cada `<tangible>`.
- El loader rellena también estructuras auxiliares (`Envelope`, `ToneDefinition`, `SequenceTrack`, `LoopDefinition`, `SampleInstrument`) a partir de los subelementos correspondientes (`<envelope>`, `<tone>`, `<sequence>`, `<loop>`, `<instrument>`), y extrae metadatos de `<author>`/`<patch>` en `ReactablePatchMetadata`.
- Implementada la traducción de `<hardlink to="..." />` dentro de tangibles `Delay` a conexiones reales del modelo: para cada hardlink, se crea un `rectai::Connection` que une el puerto `out` del módulo delay con el puerto `in` del módulo destino (por ejemplo, `Output` con id `-1`). Estas conexiones se marcan ahora explícitamente en el modelo con `is_hardlink = true`.
- Actualizado `tests/scene_tests.cpp` con pruebas de humo que validan tanto la carga básica de un Oscillator desde un `.rtp` mínimo como la creación de una conexión `Delay -> Output` derivada de un hardlink.

### Módulo Sampleplay y soporte básico de SoundFont
- Extendido `SampleplayModule` en `core/src/core/AudioModules.{h,cpp}` para asociar un único archivo SoundFont (.sf2) por módulo.
- Añadido método `bool LoadSoundfont(const std::string& path, std::string* error_message)` que realiza una validación ligera del encabezado SF2 (RIFF + "sfbk") usando solo C++ estándar y, en caso de éxito, almacena el path en el módulo (`soundfont_path_`) y marca `has_soundfont()`.
- Añadido un test en `tests/scene_tests.cpp` que genera un archivo SF2 sintético mínimo en disco, invoca `SampleplayModule::LoadSoundfont`, verifica que se marca como cargado y elimina el archivo temporal.

### Interacción de hardlinks en la UI
- Ampliada la semántica de `Connection::is_hardlink` para que también se use en la interacción de la UI, no solo en el loader `.rtp`.
- En `MainComponent` se introducen hardlinks dinámicos creados por colisión: cuando dos objetos (módulos) hacen contacto en la interfaz (sus círculos se tocan dentro del área musical), se detecta el evento de choque y se llama a un helper que alterna la conexión hardlink entre ambos módulos siempre que `AudioModule::CanConnectTo` lo permita.
- Cada nuevo choque entre un par de objetos alterna el estado: si no existe conexión, se crea una `Connection` con `is_hardlink = true`; si ya existe un hardlink entre esos módulos, se elimina; si existe una conexión normal, se “promueve” a hardlink.
- Los hardlinks se pintan ahora en rojo (línea y pulso animado) en `MainComponent::paint`, distinguiéndose de las conexiones dinámicas blancas.
- El cálculo de conexiones “activas” y el ruteo de audio en `timerCallback` consideran los hardlinks como siempre activos dentro del área musical, ignorando las restricciones geométricas de cono, pero se eliminan automáticamente si cualquiera de los dos módulos sale fuera del área de música.

### Visualización de forma de onda sobre líneas de audio
- Se ha extendido `MainComponent::paint` para que cada línea que genera o transporta sonido muestre una forma de onda superpuesta sobre la línea blanca base.
- Se añaden helpers internos para:
  - Detectar si una `rectai::Connection` es de audio (consultando los `PortDescriptor` de `AudioModule` y, en su defecto, las flags `produces_audio`/`consumes_audio`).
  - Dibujar una forma de onda senoidal animada sobre un segmento recto (`drawWaveformOnLine`) o sobre una curva cuadrática de Bézier (`drawWaveformOnQuadratic`).
- Las líneas radiales centro→objeto que corresponden a módulos que producen o consumen audio ahora se dibujan como una única línea ondulada, sin duplicar la línea blanca estática. Esta línea se obtiene a partir de una muestra real del audio mezclado en `AudioEngine`.
- Las conexiones entre módulos (`Scene::connections`) marcadas como de audio sustituyen igualmente su trazo base por una única curva ondulada (recta o Bézier según el tipo de conexión) siempre que la conexión no esté muteada, reforzando visualmente qué rutas llevan señal.
- Se ha añadido un pequeño buffer circular de muestras mono en `AudioEngine` (unos ~90 ms de historial) y un método `getWaveformSnapshot` que devuelve una ventana de ~50 ms ya decimada a un número fijo de puntos para que la UI pueda normalizar y dibujar la forma de onda.
- Las conexiones y líneas muteadas mantienen su aspecto atenuado/punteado pero no muestran forma de onda, reflejando que no están transportando audio, y cuando el nivel de audio es prácticamente nulo la línea ondulada converge visualmente a una recta.

### Ajustes de rendimiento y precisión de la onda
- El `MainComponent` ahora usa un timer a 120 Hz (en lugar de 60 Hz) y calcula el `dt` real entre ticks mediante `juce::Time::getMillisecondCounterHiRes`, lo que hace que las animaciones y la visualización de la forma de onda respondan con menor latencia y sin depender de una frecuencia fija.
- Se ha eliminado la animación antigua del “punto” que viajaba desde cada módulo al centro (línea módulo→Master), para reducir ruido visual y dejar que la forma de onda sea el principal indicador de flujo de audio.
- En `MainComponent::timerCallback` se mantiene ahora un conjunto `modulesWithActiveAudio_` con los ids de módulos que realmente están contribuyendo audio al master (generadores y, cuando procede, sus módulos destino aguas abajo).
- El pintado de líneas radiales y conexiones consulta este conjunto, de forma que solo los módulos y conexiones con audio activo muestran una onda: por ejemplo, un filtro colocado en el área musical sin estar conectado a ningún oscilador ya no dibuja onda, y su línea vuelve a ser plana.

### Eliminación de la animación de bola en hardlinks
- Se ha eliminado también el pequeño círculo rojo animado que recorría las conexiones marcadas como `is_hardlink`, de forma que estas rutas se representan únicamente mediante su línea (recta u ondulada si llevan audio) sin elementos adicionales que distraigan de la lectura del grafo de módulos.

### Debug view del tracker con resaltado de fiduciales
- En `tracker/src/main.cpp` se ha extendido el modo `--debug-view` para que, en modo live, dibuje un rectángulo rojo alrededor de cada fiducial estable detectado.
- Se reutiliza la lista de `TrackedObject` estabilizada (tras el filtro de detecciones consecutivas) para que solo se resalten objetos “confiables”; si un fiducial desaparece de la escena deja de aparecer también su rectángulo.
- Las coordenadas normalizadas (`x_norm`, `y_norm`) de cada objeto se convierten a píxeles sobre el frame binarizado que ya se mostraba en la ventana de debug, compensando el `flip` horizontal aplicado para que la posición del rectángulo coincida con la del marcador en la imagen.

### Rango de IDs válidos para fiduciales amoeba
- En `tracker/src/TrackerEngine.cpp` se han introducido constantes para definir el rango de IDs de fiduciales “reconocidos” por el tracker (`kMinRecognisedMarkerId = 1`, `kMaxRecognisedMarkerId = 107`).
- La función `detectAmoebaFiducials` ahora descarta cualquier fiducial cuyo `id` esté fuera de ese intervalo y, además, ignora explícitamente el ID `1` aunque sea el mínimo, de modo que solo los marcadores previstos en el sistema se tienen en cuenta para el tracking y el envío OSC.
 - El umbral de choque para crear/eliminar hardlinks se ha afinado usando un radio virtual de 30px por nodo y exigiendo al menos 4px de “solapamiento” entre esos círculos virtuales (distancia entre centros ≤ 2*30 - 4), de forma que el hardlink solo se activa cuando los módulos se acercan de manera clara, sin romper la restricción de que los nodos no se sobrepongan visualmente.

### Tamaño mínimo de imagen para detección de fiduciales amoeba
- En `tracker/src/TrackerEngine.cpp` se ha introducido la constante `kMinFiducialImageSize = 32` dentro del namespace interno del tracker.
- `detectAmoebaFiducials` ahora comprueba también que la imagen binarizada tenga al menos `32x32` píxeles antes de llamar a `step_segmenter`/`find_fiducialsX`; si el frame es más pequeño, devuelve una lista vacía y `TrackerEngine::processFrame` cae automáticamente al modo de tracking por blobs.
- Este filtro reduce falsos positivos en escenas con fondo blanco o ruido muy pequeño que no corresponde realmente a un patrón amoeba, especialmente cuando se trabaja con resoluciones reducidas o zonas recortadas.

### Validación local del patrón amoeba por contenido negro
- Además del tamaño mínimo global, `detectAmoebaFiducials` realiza ahora una validación local por patrón sobre la imagen binarizada.
- Para cada `FiducialX` detectado se recorta una región alrededor de su centro de `64x64` píxeles (ajustada a los bordes si es necesario) en el frame binario.
- Se calcula el porcentaje de píxeles negros dentro de ese recorte (recordando que el binarizado produce 0 para negro y 255 para blanco) y, si el ratio de negro es inferior al 10%, el fiducial se descarta como falso positivo.
- Este chequeo adicional evita aceptar “marcadores” que en realidad son parches casi blancos con muy poco contenido de patrón, lo que ayuda a filtrar ruido visual o reflejos en fondos claros.

### Carga de `default.rtp` desde `com.reactable`
- La aplicación JUCE principal (`rectai-core`) ahora intenta cargar automáticamente el patch Reactable por defecto ubicado en `com.reactable/Resources/default.rtp` al inicializar `MainComponent`.
- Se reutiliza el loader existente `LoadReactablePatchFromFile` de `core/src/core/ReactableRtpLoader.{h,cpp}` para poblar directamente un `rectai::Scene` con módulos, conexiones y objetos a partir del `.rtp` original.
- La ruta al recurso se resuelve de forma robusta probando varias ubicaciones relativas tanto al directorio de trabajo actual como al ejecutable (por ejemplo, `com.reactable/Resources/default.rtp`, `../com.reactable/Resources/default.rtp`, etc.), de manera que funcione tanto al lanzar desde la raíz del repo como desde el árbol `build/`.
- Si la carga falla (por ausencia de archivo o error de parseo), `MainComponent` recupera el comportamiento anterior creando la pequeña escena de ejemplo hardcodeada (`osc1` → `filter1`) para mantener un fallback visible.

### Iconos de módulos desde atlas Reactable
- Añadido cargador ligero de atlas en `MainComponent` que localiza `atlas_2048.png` y `atlas_2048.xml` dentro de `com.reactable/Resources`, parsea sus `<sprite>` y construye un mapa en memoria `icon_id → rect` (usando el nombre corto, p.ej. `"oscillator"`, `"filter"`).
- La UI de nodos utiliza ahora este atlas para dibujar los iconos originales de Reactable dentro de cada círculo cuando existe sprite para el `icon_id` del módulo; en caso contrario, conserva los iconos vectoriales procedurales que ya existían.
- Cuando un icono del atlas está disponible (por ejemplo, para `OscillatorModule` y `FilterModule`), el texto del módulo deja de renderizarse dentro del nodo y se sustituye visualmente por dicho icono, manteniendo la estética original de Reactable y evitando duplicar label + icono.

### Flag `docked` en `ObjectInstance` y área musical
- `rectai::ObjectInstance` se ha ampliado con un flag booleano `docked`, expuesto mediante `bool docked() const`, que indica si el tangible procede de un elemento `docked="1"` en el `.rtp`.
- El loader de patches Reactable (`ReactableRtpLoader.cpp`) ahora lee el atributo `docked` de cada `<tangible>` y lo propaga al construir el `ObjectInstance` correspondiente, manteniendo el resto de la semántica (tracking_id como `id`, posición `x`,`y` y ángulo en radianes).
- La función `MainComponent::isInsideMusicArea` utiliza ahora este flag: cualquier objeto marcado como `docked` se considera automáticamente fuera del área musical, incluso si sus coordenadas geométricas cayeran dentro del círculo de la mesa.
- Con este cambio, los tangibles acoplados (`docked=1` en `default.rtp`, como Tonalizer, Volume, Tempo, LFO, Loop, Sampleplay, etc.) se tratan como módulos “apartados” que no participan en las conexiones espaciales ni en las heurísticas del área musical, alineando la semántica con el comportamiento esperado de la Reactable original.
 - Además, `ObjectInstance` incorpora ahora un flag `inside_music_area` que se recalcula en `MainComponent::refreshInsideMusicAreaFlags` (y al arrastrar objetos desde la UI) para que toda la lógica de audio y pintura consulte un atributo precalculado en lugar de revaluar la geometría de `isInsideMusicArea` en cada llamada.

### Semántica de `Output` (master) y visualización del nodo central
- El tangible `type="Output"` del patch Reactable se interpreta ahora explícitamente como el **master** de la escena y ya no se representa como un módulo normal en la mesa (no aparece como nodo ni en la barra de dock).

### Controladores globales sin conexiones explícitas (Volume, Tempo, Tonalizer)
- Se ha introducido en `AudioModule` el método virtual `is_global_controller()` para distinguir módulos que actúan como controladores de sesión (p.ej. `VolumeModule`, `TempoModule`, `TonalizerModule`) del resto del grafo de audio.
- `VolumeModule`, `TempoModule` y `TonalizerModule` sobreescriben `is_global_controller()` devolviendo `true`, marcándolos como Global Controllers.
- `Scene::AddConnection` y `AudioModule::CanConnectTo` rechazan ahora cualquier conexión (dinámica o hardlink) en la que participe un Global Controller, de forma que estos módulos nunca aparecen en `Scene::connections` ni se encadenan con otros módulos ni con `Output`.
- En la UI (`MainComponent_Paint.cpp`), los módulos marcados como Global Controller ya no dibujan la línea radial blanca hacia el nodo central, manteniendo el rol de estos tangibles como controladores globales de sesión sin routing explícito.
- Se han añadido tests en `tests/scene_tests.cpp` que verifican que `VolumeModule`, `TempoModule` y `TonalizerModule` no pueden crear conexiones en `Scene` ni ser destino de ellas.

### Alineación de hit-test y pintado en el Dock de módulos
- Se ha corregido la geometría del Dock en `MainComponent::mouseDown` y `MainComponent::mouseDrag` para que utilicen la misma área de contenido que el pintado en `MainComponent_Paint.cpp`, descontando explícitamente la altura del título del Dock antes de calcular alturas disponibles, offsets y centros (`cy`) de cada módulo dockeado.
- Antes del cambio, el cálculo de `cy` para el hit-test de los módulos del Dock ignoraba la franja de título superior, lo que desplazaba hacia arriba el centro lógico de los círculos respecto a su posición real en pantalla; como consecuencia, solo era posible seleccionar/arrastrar un módulo haciendo click en la parte alta del círculo, por encima del icono.
- Con la corrección, el círculo dibujado y el área de hit-test vuelven a coincidir en el Dock: ahora se puede clicar y arrastrar un módulo desde cualquier punto del círculo o de su icono para sacarlo hacia el área musical, manteniendo el mismo comportamiento de scroll vertical del Dock.

### Oscillator con subtipos y cambio por click derecho
- `OscillatorModule` incorpora ahora un enum `Waveform` con cuatro subtipos alineados con la Reactable original: `sine`, `saw`, `square` y `noise`.
- El constructor de `OscillatorModule` inicializa la forma de onda a `sine` y asigna automáticamente el `icon_id` correspondiente del atlas (`oscillator_sine`).
- Se exponen helpers en el modelo:
  - `set_waveform(Waveform)` y `waveform()` para gestionar el estado interno.
  - El estado interno de forma de onda se mantiene mediante el enum `Waveform` y el índice derivado de `supported_modes()` (`id`/`type`), pero no se expone ya helpers específicos de mapeo; toda la información relevante para UI y loaders vive en `AudioModuleMode` (id, type, icon_id).
- El loader de patches `ReactableRtpLoader` ahora lee el atributo `subtype` de los tangibles `Oscillator` y busca una entrada correspondiente en `supported_modes()` comparando el campo `type`; cuando encuentra coincidencia, llama a `set_mode(i)` con el índice adecuado, de modo que un `<tangible type="Oscillator" ... subtype="sine" ...>` se traduce a un módulo con icono `oscillator_sine` y estado de forma de onda coherente.
- En la UI (`MainComponent_Input`), un click derecho sobre el círculo de un Oscillator (en la superficie musical) invoca el helper genérico `cycle_mode_forward()` sobre el módulo asociado, cambiando inmediatamente el icono según el modo seleccionado.
- El pintado de iconos (`MainComponent_Paint`) se ha ajustado para que los `icon_id` que comienzan por `"oscillator"` (`oscillator_sine`, `oscillator_saw`, etc.) sigan usando el mismo fallback vectorial que el icono genérico `oscillator` cuando el atlas de sprites no está disponible, conservando la legibilidad en modo degradado.
- Se han añadido tests en `tests/scene_tests.cpp` que validan:
  - El ciclo completo de formas de onda e iconos (`sine → saw → square → noise → sine`).
  - Que un patch `.rtp` mínimo con un Oscillator de subtipo `sine` se carga como `OscillatorModule` y expone el icono `oscillator_sine` en el modelo.

### Filtro con cambio de modo por click derecho e iconos específicos
- `FilterModule::Mode` se aprovecha ahora no solo para la lógica interna del filtro sino también para la selección de icono: `set_mode(Mode)` actualiza siempre tanto el estado `mode_` como el `icon_id` asociado del módulo.
- Los tres modos (`kLowPass`, `kBandPass`, `kHighPass`) se mapean directamente a los sprites del atlas `atlas_2048.xml`: `filter_lowpass`, `filter_bandpass` y `filter_hipass` respectivamente.
- El constructor de `FilterModule` inicializa el módulo llamando a `set_mode(Mode::kBandPass)`, de modo que el icono por defecto queda alineado con el modo efectivo (band-pass) sin duplicar lógica de selección de iconos.
- Se añade el helper `cycle_mode()` en `FilterModule`, que recorre cíclicamente los tres modos (`lowpass → bandpass → highpass → lowpass`) reutilizando `set_mode` para mantener `mode_` e `icon_id` siempre sincronizados.
- `set_mode_from_subtype(const std::string&)` continúa leyendo el atributo `subtype` de los tangibles de tipo filtro en los patches `.rtp`, pero ahora delega toda la actualización de estado e icono en `set_mode`, garantizando que cualquier cambio de modo (ya sea por loader o por interacción en la UI) use el mismo código.
- En la UI (`MainComponent_Input`), el bloque de click derecho que antes solo afectaba a los Oscillator se amplía: un click derecho sobre un tangible asociado a `FilterModule` invoca `cycle_mode()`, cambiando el modo del filtro y actualizando inmediatamente el icono renderizado en la mesa.

### Módulo de filtro con modos y resonancia
- `FilterModule` se ha ampliado para soportar tres modos explícitos (`lowpass`, `bandpass`, `highpass`) mediante un enum interno y un helper `set_mode_from_subtype` que inicializa el modo a partir del atributo `subtype` del `.rtp` (por defecto `bandpass` cuando no se reconoce el valor).
- La rotación física del tangible de filtro sigue mapeándose al parámetro normalizado `freq` del módulo, que en adelante se interpreta como frecuencia de corte (low/high-pass) o frecuencia central (band-pass), delegando en el futuro motor de audio la traducción a Hz según el modo.
- La barra lateral derecha del filtro deja de controlar el volumen de la cadena y pasa a representar el parámetro de calidad/resonancia `q`; la UI utiliza ahora `q` para pintar y editar ese control, mientras que el motor de audio ignora dicho valor como ganancia global.
- En el cálculo de nivel por voz en `MainComponent::timerCallback`, los módulos de filtro ya no modifican la ganancia efectiva de la cadena `osc → filtro → master`; el nivel se deriva del generador (u otros módulos aguas abajo como `VolumeModule`), preservando la intención de que el control del filtro afecte solo a su carácter espectral (resonancia) y no al volumen general.
- `ReactablePatchMetadata` se amplía con `master_colour_argb` y `master_muted`, que el loader rellena leyendo los atributos `color` y `muted` del tangible `Output` (admitiendo colores en formato ARGB de 8 dígitos o RGB de 6 dígitos, asumiendo alfa opaco).
- `MainComponent` usa `master_colour_argb` para colorear el punto central y sus ondas de pulso, en lugar de un blanco fijo, de modo que el aspecto del master respeta el patch original (`default.rtp` u otros `.rtp`).
- El atributo `muted` del `Output` se traduce en un flag `masterMuted_` en la UI: cuando está activo, atenúa visualmente el nodo central y fuerza el nivel de mezcla global a cero en `timerCallback`, actuando como un mute maestro sobre todo el sonido generado por los módulos.

### Helpers de UI con namespace explícito en `MainComponent`
- Se ha alineado el uso de los helpers de UI definidos en `MainComponentHelpers.h` (`makeConnectionKey`, `makeObjectPairKey`, `makeModulePairKey`, `isConnectionGeometricallyActive`) para que se invoquen siempre cualificados como `rectai::ui::...` desde `MainComponent.cpp`.
- Esto corrige errores de compilación recientes por símbolos no resueltos y deja más clara la separación entre la lógica de modelo (`rectai`) y las utilidades puramente gráficas/de UI (`rectai::ui`).

### Helper genérico `loadFile` para recursos de Reactable
- Se ha extraído la lógica de búsqueda de recursos (antes duplicada en `MainComponent` y `MainComponent_Atlas`) a un helper `rectai::ui::loadFile` definido en `MainComponentHelpers.{h,cpp}`.
- `loadFile` recibe una ruta relativa (por ejemplo, `"com.reactable/Resources/default.rtp"`) y prueba varias ubicaciones plausibles relativas al directorio actual y al ejecutable (`.`, `..`, `../..`, y el parent del binario), devolviendo el primer `juce::File` existente o un archivo vacío si no encuentra nada.
- `MainComponent` usa ahora `loadFile` para localizar `default.rtp` antes de invocar `LoadReactablePatchFromFile`, eliminando el array local de 8 candidatos.
- `MainComponent_Atlas` también usa `loadFile` para hallar `com.reactable/Resources/atlas_2048.png` y deriva de ahí el `atlas_2048.xml` en el mismo directorio, unificando la estrategia de búsqueda de recursos Reactable y reduciendo duplicación de código.

### Alineación del hit-test de líneas centro→objeto con hardlinks
- Ajustada la lógica de `mouseDown` en `MainComponent_Input.cpp` para que el hit-test sobre las líneas centro→objeto siga exactamente las mismas reglas de visibilidad que el dibujado en `MainComponent_Paint.cpp`.
- Ahora, los módulos generadores (`ModuleType::kGenerator`) que tengan una conexión saliente activa (incluyendo conexiones marcadas como `is_hardlink`) dejan de dibujar su línea directa al Master **y** dejan de ser clicables a través de esa línea, evitando que un “link invisible” al centro pueda mutear el módulo.
- El filtro de hit-test también ignora objetos `docked` y el tangible `Output` (`logical_id == "-1"`), de forma que solo los instrumentos realmente representados con una línea visible hacia el Master pueden togglear su estado de mute mediante click cerca de dicha línea.

### Giro de módulos y modulación de frecuencia por rotación
- El protocolo OSC de tracking (`TrackingOscReceiver`) interpreta ahora el quinto argumento de `/rectai/object` como ángulo en grados dentro del rango `[0, 360]` y lo convierte internamente a radianes antes de poblar `rectai::ObjectInstance`, manteniendo la semántica del modelo (`angle_radians`) coherente con el loader `.rtp`.
- `MainComponent` mantiene un mapa `lastObjectAngleDegrees_` indexado por `tracking_id` que almacena el último ángulo conocido (en grados) de cada `ObjectInstance` presente en la escena.
- En `MainComponent::timerCallback`, antes de calcular la mezcla de frecuencia/nivel hacia `AudioEngine`, se recorre la lista de objetos y para cada uno que:
  - tenga un `AudioModule` asociado,
  - exponga control de frecuencia (`uses_frequency_control()`), y
  - esté dentro del área musical (`isInsideMusicArea`),
  se calcula el delta de rotación entre el ángulo actual y el previo.
- El ángulo almacenado en la escena se convierte de radianes a grados, se obtiene la diferencia y se normaliza al rango `[-180, 180]` para tratar correctamente el cruce 0/360°; a partir de ahí se deriva una variación de frecuencia normalizada `deltaFreq = diff / 360.0f` en el rango aproximado `[-0.5, 0.5]`.
- Esta `deltaFreq` se suma al parámetro `freq` del módulo correspondiente, usando `Scene::SetModuleParameter` y limitando siempre el resultado a `[0.0, 1.0]` mediante `juce::jlimit`, de forma que un giro completo de 360° equivale a un desplazamiento de ±1.0 en el parámetro de frecuencia.
- Los objetos que desaparecen de la escena (se borran vía `/rectai/remove` o por otros caminos) se eliminan también del mapa `lastObjectAngleDegrees_` en cada frame, evitando fugas de memoria y dejando el tracking preparado para nuevas apariciones con un historial limpio.

### Alineación del ángulo OSC entre tracker y core
- `tracker/src/OscSender.{h,cpp}` espera ahora explícitamente el ángulo en **grados** en `sendObject` y lo empaqueta tal cual en el mensaje `/rectai/object` (tipo `float`).
- En `tracker/src/main.cpp`, el modo live convierte `obj.angle_rad` (radianes provenientes de `TrackerEngine`) a grados con `angleDegrees = obj.angle_rad * 180.0f / M_PI` antes de enviarlo por OSC, y escribe un log detallado por fiducial con `angle_deg=...` para poder depurar visualmente la rotación.
- El modo synthetic también usa ya una variable `angleDegrees` coherente, de modo que cualquier futura animación de giro sintético respetará la misma convención de grados/plano `[0,360]` utilizada por el core.
- En el core, `TrackingOscReceiver` sigue recibiendo el quinto argumento como grados y lo transforma a radianes al construir `ObjectInstance`, de forma que `MainComponent` y el resto del modelo continúan trabajando internamente siempre en radianes.
- La lógica de modulación por rotación en `MainComponent::timerCallback` se ha relajado para aplicar el delta de giro a cualquier objeto **no docked**, independientemente de que esté o no estrictamente dentro del círculo musical, evitando casos en los que la barra de `freq` no se actualizaba al girar un fiducial situado muy cerca del borde.

### Orientación radial de módulos respecto a su línea de audio
- Los módulos que se encuentran dentro del área musical se renderizan ahora con una orientación radial alineada con su propia línea de audio (línea blanca) hacia el centro: antes todos los nodos tenían una orientación fija en pantalla, independientemente de su posición.
- En `MainComponent::paint`, al dibujar cada nodo dentro del círculo musical se calcula el ángulo polar entre el centro de la mesa y la posición del objeto y se aplica una `AffineTransform::rotation` alrededor del centro del nodo; con esto, el cuerpo del módulo, sus barras laterales de `freq`/`gain` y el icono interno giran como un bloque al mover el tangible por la superficie.
- El widget de secuenciador asociado a objetos cuyo `logical_id` empieza por `"seq"` adopta la misma orientación radial cuando están en el área musical: en lugar de usar únicamente `angle_radians()` del `ObjectInstance`, el ángulo efectivo se recalcula respecto al centro de la mesa, de modo que la cuadrícula proyecta siempre “hacia fuera” siguiendo la misma dirección que la línea de audio.

### Hardlinks rectos y controles laterales con hit-test rotado
- Las conexiones marcadas como `is_hardlink` en el modelo se dibujan ahora como líneas rectas rojas entre módulos, con un pulso animado que se desplaza linealmente de origen a destino; las conexiones dinámicas siguen renderizándose como curvas de Bézier blancas con su propio pulso siguiendo la trayectoria curva.
- La lógica de hit-test de los controles laterales de `freq` y `gain` en `MainComponent::mouseDown` y el arrastre correspondiente en `mouseDrag` transforman ahora el punto de ratón al sistema de coordenadas local del módulo (invirtiendo la misma rotación que se aplica en `paint`), de forma que el área interactiva de los sliders gira junto con las barras y permanece coherente con su aspecto visual aunque el nodo esté rotado en la mesa.

### Unicidad de objetos por `logical_id` en la Scene
- `rectai::Scene::UpsertObject` garantiza ahora que solo exista un `ObjectInstance` por cada `logical_id` en la escena: antes de insertar/actualizar el nuevo objeto, recorre el mapa interno `objects_` y elimina cualquier entrada previa cuyo `logical_id()` coincida pero cuyo `tracking_id()` sea distinto.
- Esto resuelve situaciones en las que un mismo módulo podía aparecer dos veces en la superficie musical (por ejemplo, una posición “manual” definida en el `.rtp` y otra proveniente de tracking OSC) manteniendo **solo** la posición más reciente, que típicamente es la enviada por el tracker.
- Con esta política, cuando el tracker envía `/rectai/object` para un módulo que ya tenía un objeto asociado, la ubicación controlada por OSC pasa a ser la única referencia espacial para ese `logical_id`, de modo que las heurísticas de UI y audio (conexiones, área musical, barras de `freq`/`gain`) siempre operan sobre una única instancia coherente por módulo.

### Mapeo de múltiples osciladores a voces independientes
- `AudioEngine` expone ahora públicamente la constante `kMaxVoices` (actualmente 16), que define el número máximo de voces senoidales que puede mezclar en paralelo.
- `MainComponent::timerCallback` deja de colapsar todos los generadores (`ModuleType::kGenerator`, típicamente osciladores) en una sola frecuencia/nivel global; en su lugar recorre los objetos de la `Scene` y, para cada generador activo dentro del área musical y con ruta de conexión válida, calcula una frecuencia absoluta y un nivel efectivo teniendo en cuenta:
  - El parámetro `freq` propio del módulo.
  - El parámetro `gain` tanto del generador como del módulo aguas abajo (por ejemplo, un filtro o volumen) siguiendo las conexiones de `Scene`.
  - Los flags de mute por objeto (`mutedObjects_`), por conexión (`mutedConnections_`) y el estado `masterMuted_`.
- Cada generador audible se asigna a una voz distinta de `AudioEngine` mediante `setVoice(voiceIndex, frequency, level)`, hasta un máximo de `AudioEngine::kMaxVoices`; las voces no utilizadas en ese frame se fuerzan explícitamente a `(frequency=0.0, level=0.0)` para garantizar que osciladores que desaparecen de la escena dejan de sonar inmediatamente.
- El callback de audio en `AudioEngine` sigue mezclando todas las voces en una salida estéreo simple, pero ahora cada oscilador tangible se traduce en una contribución independiente al mix, permitiendo escuchar simultáneamente varios osciladores conectados al Master o encadenados a filtros según la topología definida en la `Scene`.

### Retorno automático al dock cuando desaparece el fiducial
- El manejador `/rectai/remove` en `TrackingOscReceiver` deja de llamar directamente a `Scene::RemoveObject` y, en su lugar, busca el `ObjectInstance` asociado al `trackingId` que llega por OSC.
- Si existe, se crea una nueva instancia con los mismos `tracking_id`, `logical_id`, posición y ángulo, pero con el flag `docked=true`, y se reinyecta en la escena mediante `Scene::UpsertObject`.

### Colores base de módulos desde `default.rtp`
- Alineado el color base de `OscillatorModule` en `AudioModules.cpp` con el valor definido en el patch Reactable por defecto `com.reactable/Resources/default.rtp`, usando el color azul `#2366e1` especificado para los tangibles `type="Oscillator"` de subtipo `sine`.
- Revisados los colores de otros módulos (`Output`, `Input`, `Loop`, `Sampleplay`, controladores globales) para confirmar que ya coincidían con los valores de `default.rtp` o, cuando no había color explícito en el XML, mantenían la paleta gris definida previamente.
 - Añadido un setter público `AudioModule::OverrideColour(uint32_t)` que permite a loaders externos sobreescribir el color visual de un módulo a partir de datos de escena sin exponer directamente `set_colour`.
 - Actualizado `ReactableRtpLoader.cpp` para que, al crear cada módulo desde un `<tangible>`, lea el atributo `color` (cuando existe) y llame a `OverrideColour`, de modo que los colores de `Output`, `Input`, `Loop`, `Sampleplay` y los distintos `Oscillator` (por ejemplo `sine` azul y `saw` rojo) reflejen exactamente los valores del `default.rtp` y de cualquier otro patch Reactable cargado.
 - El color del tangible `type="Output"` se sincroniza además con `ReactablePatchMetadata::master_colour_argb`, garantizando que el nodo central y sus pulsos compartan el mismo color definido en el archivo `.rtp`.

### Overlay de IDs de módulo en modo debug
- Añadido un overlay de texto en `MainComponent_Paint.cpp` que, solo en compilaciones de depuración (`#if !defined(NDEBUG)`), dibuja a la derecha de cada nodo (tanto en la mesa como en el dock) el `logical_id` asociado al `ObjectInstance`/`AudioModule`.
- Este overlay facilita depurar problemas de mapeo de colores y rutas (por ejemplo, distinguir rápidamente los cuatro `Loop` sampler `24/29/34/39` y su color de `default.rtp`) sin contaminar la apariencia de los builds de Release.

### Color de fondo del dock
- Actualizado el color de fondo del panel de dock en `MainComponent_Paint.cpp` para que use un gris sólido `#404040` en lugar de un negro semitransparente, mejorando el contraste visual de los módulos dockeados (especialmente los que tienen colores oscuros o negros por defecto) frente al fondo general.
- Dado que `isInsideMusicArea` considera automáticamente que cualquier objeto `docked` está fuera del área musical, el módulo desaparece de la mesa central y vuelve a aparecer en la barra de dock de la UI, manteniendo intacto su módulo lógico en la escena.
- Combinado con la unicidad por `logical_id`, esto asegura que cada módulo tiene siempre **una sola** representación espacial: mientras el fiducial está presente, la controla el tracking OSC; cuando desaparece, la representación vuelve al dock sin duplicados.

### Tracker basado en blobs tipo "amoeba" y eliminación de ArUco
- `TrackerEngine` deja de depender de `cv::aruco` y ya no intenta detectar marcadores ArUco ni usar diccionarios predefinidos.
- La ruta de detección se basaba inicialmente únicamente en segmentación de blobs: conversión a escala de grises, `GaussianBlur`, `adaptiveThreshold` y `findContours` para localizar regiones orgánicas de un tamaño mínimo configurable.
- Para cada contorno suficientemente grande se calculaba el centroide mediante momentos y la orientación aproximada con `cv::fitEllipse`, generando un `TrackedObject` con coordenadas normalizadas y ángulo en radianes.
- Se mantenía un pequeño estado interno (`lastObjects_` + `nextId_`) que asociaba cada nueva detección con el objeto previo más cercano en coordenadas normalizadas, asignando así IDs numéricos estables entre frames sin depender de IDs codificados en el marcador.
- `tracker/CMakeLists.txt` y `tests/CMakeLists.txt` se han simplificado para pedir solo los módulos de OpenCV necesarios (`core`, `imgproc`, `videoio`, `highgui`) eliminando `aruco` e `imgcodecs` del flujo de compilación.

### Detección real de fiduciales "amoeba" usando libfidtrack
- El ejecutable `rectai-tracker` ahora enlaza directamente con el código original de reacTIVision (`reacTIVision/ext/libfidtrack`), añadiendo a su target los archivos `segment.c`, `fidtrackX.c`, `topologysearch.c` y `treeidmap.cpp`, e incluyendo su cabecera pública.
- `TrackerEngine` inicializa en `initialise` las estructuras de libfidtrack (`TreeIdMap`, `Segmenter`, `FidtrackerX`) usando el set de símbolos `"default"` de amoeba incluido en `default_trees.h`, alineado con el comportamiento por defecto de reacTIVision.
- En `processFrame`, tras convertir el frame a escala de grises y aplicar un `GaussianBlur` + `adaptiveThreshold` con `THRESH_BINARY` (0 negro, 255 blanco), se pasa la imagen binaria a `step_segmenter` y se invoca `find_fiducialsX` para obtener un array de `FiducialX` con `id`, posición y ángulo.
- Cada `FiducialX` con `id >= 0` se normaliza a coordenadas [0,1] usando el ancho/alto configurados en `initialise`, y se traduce a un `TrackedObject` cuyo `id` coincide con el ID amoeba real del marcador físico; el ángulo se preserva en radianes desde libfidtrack.
- Si en un frame no se detecta ningún fiducial válido (por ausencia de marcadores amoeba o por condiciones de iluminación), el engine mantiene un **fallback** basado en blobs: se ejecuta la ruta anterior de `findContours` + `fitEllipse` y se siguen asignando IDs estables mediante proximidad (`lastObjects_` + `nextId_`), de manera que los tests sintéticos y escenarios sin marcadores físicos siguen funcionando.
- El destructor de `TrackerEngine` libera correctamente los recursos de libfidtrack (`terminate_segmenter`, `terminate_fidtrackerX`, `terminate_treeidmap`), evitando fugas de memoria en ejecuciones prolongadas del servicio de tracking.

### Target Earthly para AppImage
- Añadido un nuevo target `appimage` en el `Earthfile` que reutiliza la imagen base `the-base`, compila los binarios en modo Release y prepara un `AppDir` con `RectaiTable` y `rectai-tracker` en `usr/bin`.
- El target descarga `linuxdeploy` y `appimagetool` como AppImages y los usa para recolectar todas las dependencias compartidas (incluyendo `curl`, OpenCV y librerías del sistema necesarias para JUCE) y empaquetarlas en un único `rectai-table-x86_64.AppImage`.
- Se genera un archivo `.desktop` mínimo para `RectaiTable` mediante un comando `printf` (en lugar de heredocs), evitando problemas de sintaxis en Earthly/Docker debidos a la indentación del marcador `EOF`.
- El AppImage resultante se exporta como artefacto local en `build/rectai-table-x86_64.AppImage` al ejecutar `earthly -P +appimage` desde la raíz del repositorio.

### Tests del tracker con PNGs de fiduciales amoeba
- `tests/tracker_tests.cpp` utiliza ahora explícitamente los recursos `fiducial_30.png` y `fiducial_55.png` ubicados en `tests/`, cargándolos directamente desde disco mediante `cv::imread` (en modo escala de grises) sin necesidad de copiarlos al directorio de binarios.
- El test inicializa `TrackerEngine` con las dimensiones de la primera imagen y procesa cada PNG, verificando que entre los `TrackedObject` devueltos se encuentra al menos uno cuyo `id` coincide exactamente con el número codificado en el nombre del archivo (30 y 55 respectivamente). Esto endurece la aserción anterior (que solo comprobaba que hubiera algún ID positivo) y valida de forma más directa la decodificación de fiduciales amoeba vía libfidtrack.

### Vista de debug del tracker alineada con `processFrame`
- `TrackerEngine` expone ahora una sobrecarga `TrackedObjectList processFrame(const cv::Mat& frame, cv::Mat& debugFrame)` que, además de devolver la lista de `TrackedObject`, rellena `debugFrame` con la imagen binarizada (`adaptiveThreshold`) que se utiliza internamente para la detección de fiduciales amoeba y el fallback de blobs.
- La implementación pública sin imagen de debug (`processFrame(const cv::Mat& frame)`) delega en un helper privado `processFrameInternal(const cv::Mat& frame, cv::Mat* debugFrame)`, garantizando que ambos caminos comparten exactamente el mismo pipeline de procesamiento.
- En `tracker/src/main.cpp`, cuando se ejecuta en modo `--mode=live` y con `--debug-view`, el bucle principal llama a la nueva variante de `processFrame` con `debugFrame`, y la ventana OpenCV de debug muestra ese `debugFrame` (espejado en horizontal), que es una imagen de un solo canal (grises/0-255) exactamente igual a la que consume libfidtrack.
- En modo sintético (o si no hay `debugFrame` disponible por cualquier motivo), el debug view ya no enseña el frame de cámara en color, sino que convierte el frame a escala de grises antes de mostrarlo, de forma que la vista de debug se parezca siempre al input que espera reacTIVision.

### Vista de depuración de cámara en `rectai-tracker`
- Añadido flag `--debug-view` al ejecutable `rectai-tracker`.
- Cuando se pasa este flag (en cualquier modo), el proceso abre una ventana de OpenCV titulada `rectai-tracker debug` donde muestra el frame de la webcam espejado horizontalmente (`cv::flip`), permitiendo verificar que la cámara está capturando correctamente y que el área de trabajo está bien encuadrada.
- Mientras la vista de depuración está activa, pulsar `Esc`, `q` o `Q` cierra la ventana y termina el tracker con un mensaje de log `[rectai-tracker] Debug view exit requested by user`.

### Estabilización de fiduciales por frames consecutivos en `rectai-tracker`
- En el modo `--mode=live`, el bucle principal de `rectai-tracker` mantiene ahora un contador por ID de fiducial con el número de frames consecutivos en los que se ha detectado cada marcador.
- Solo se consideran "objetos estables" aquellos fiduciales que se han visto al menos en un umbral configurable de **N frames consecutivos** (actualmente 10); únicamente estos objetos se usan para actualizar `TrackerState` y para enviar mensajes OSC `/rectai/object` al core JUCE.
- Además del número de frames, se comprueba que la posición normalizada del fiducial no cambie bruscamente entre frames: si la distancia entre posiciones sucesivas supera ~10% del tamaño de la mesa, se resetea el contador a 1 para ese ID.
- Si un fiducial deja de aparecer en un frame, su contador y su última posición se eliminan de las tablas internas, de modo que detecciones espurias que solo duran uno o dos frames (o que saltan de sitio) nunca llegan a producir logs ni eventos OSC.
- Las eliminaciones (`/rectai/remove`) siguen basándose en `TrackerState::collectRemovals`, pero este estado solo se alimenta con los objetos estables, por lo que también se reducen los mensajes de "fiducial X removed" causados por falsos positivos de la cámara.

### Control de Tempo por rotación del módulo Tempo
- El core JUCE (`MainComponent`) trata ahora explícitamente el módulo `TempoModule` como controlador del **BPM global de la sesión**, inicializando `bpm_` a partir del parámetro `tempo` del patch Reactable cargado (por ejemplo, el `tempo="128"` de `default.rtp`), limitado al rango `[40, 400]` BPM.
- En `MainComponent::timerCallback` se calcula para cada `ObjectInstance` un delta de rotación por frame en grados, normalizado a `[-180, 180]` y almacenado en un mapa `rotationDeltaDegrees` compartido tanto por la modulación de frecuencia de osciladores como por el control de tempo.
- Para objetos asociados a `TempoModule`, cada variación de **5º** de rotación incrementa o decrementa el tempo en **1 BPM**, aplicando la misma convención de sentido (clockwise/counter-clockwise) que ya se utiliza para el control de frecuencia; el valor resultante se almacena en `bpm_` como `double` y se limita siempre a `[40, 400]` BPM.
- Cada vez que se actualiza el BPM global se sincroniza también el parámetro lógico `tempo` del propio `TempoModule` vía `Scene::SetModuleParameter`, de forma que futuras serializaciones o inspecciones del modelo vean el tempo actualizado.
- La UI de nodos (`MainComponent_Paint.cpp`) dibuja ahora un pequeño texto con el valor de BPM **entero** (sin decimales) en la esquina superior izquierda del círculo del módulo Tempo, tanto cuando está en la superficie musical como cuando aparece acoplado en la barra de dock, reflejando siempre el valor de `bpm_` que alimenta las ondas concéntricas y la fase del secuenciador.

### Control de Volume global por rotación y slider
- El `VolumeModule` se inicializa ahora explícitamente con el parámetro lógico `volume` a `0.9F`, de forma que el volumen global arranca al **90%** por defecto, alineado con el comportamiento esperado de la mesa original.
- El slider lateral derecho asociado al módulo Volume, que en la UI se renderiza como un único control visible, deja de mapearse al parámetro genérico `gain` y pasa a leer/escribir directamente el parámetro `volume` del módulo, manteniendo el resto de parámetros de dinámica/FX (`compression_level`, `reverb_level`, `delay_fb`, etc.) fuera de esta interacción.
- En `MainComponent::mouseDrag`, cuando el usuario arrastra el control lateral derecho de un tangible asociado a `VolumeModule`, el valor normalizado calculado se aplica únicamente a `Scene::SetModuleParameter(..., "volume", value)`, dejando el mapeo a `gain` intacto para el resto de módulos y usando aún `q` para el control derecho de los filtros.
- `MainComponent::timerCallback` reutiliza el mapa `rotationDeltaDegrees` para aplicar también la rotación de los tangibles `Volume` al parámetro `volume`: cada vuelta completa (`±360º`) suma o resta aproximadamente `±1.0` al valor normalizado de volumen (clampado siempre a `[0.0, 1.0]`), con el mismo sentido de giro que se usa para frecuencia y tempo.
- El valor actual de `volume` se interpreta como **volumen global de Master**: antes de mapear los generadores a voces en `AudioEngine`, `MainComponent::timerCallback` busca el primer `VolumeModule` presente en la escena, lee su parámetro `volume` (por defecto `0.9F`) y lo usa como multiplicador global sobre el nivel de cada voz (`level * globalVolume`), aplicado después de la lógica de mute por objeto/conexión y del flag `masterMuted_`.
- Gracias a este cambio, cada módulo sigue teniendo su propio control de nivel local (`gain` en osciladores y otros módulos de audio), mientras que el módulo Volume actúa como un control maestro que escala toda la salida del sistema por encima del módulo `Output`, cumpliendo la separación "volumen por módulo" vs "volumen global de la mezcla".
 - Se ha alineado también la detección de clicks del slider lateral derecho del módulo Volume en `MainComponent::mouseDown` para que el handle seleccionado use el mismo parámetro lógico `volume` que se pinta en la UI; antes, el hit-test seguía leyendo el parámetro genérico `gain`, lo que desplazaba la zona de click hacia el 0% aunque el círculo visible estuviera cerca del 90%.

### Filtro de audio estable con JUCE DSP
- El motor de audio (`AudioEngine`) ha dejado de usar un biquad RBJ implementado a mano por voz y ahora emplea `juce::dsp::StateVariableTPTFilter<float>` para aplicar el filtro por voz de manera estable.
- En `audioDeviceAboutToStart` se inicializa un `StateVariableTPTFilter` por cada voz con un `ProcessSpec` mono (1 canal) y el tamaño máximo de bloque reportado por el dispositivo de audio; cada filtro se resetea tanto al iniciar como al detener el dispositivo.
- El método `setVoiceFilter` configura ahora directamente el tipo (`lowpass`, `bandpass`, `highpass`) con `setType`, y ajusta frecuencia de corte y resonancia con `setCutoffFrequency` y `setResonance`, tras limitar la frecuencia al rango físico válido por debajo de Nyquist.
- En `audioDeviceIOCallbackWithContext`, cuando una voz tiene modo de filtro distinto de cero, la muestra senoidal generada para esa voz se pasa por `filters_[v].processSample(0, raw)`, y solo entonces se acumula en la mezcla y en el buffer de forma de onda, eliminando los artefactos de “crispado” que producía la implementación biquad anterior.

### Evitar reseteos continuos del filtro por voz
- `AudioEngine::setVoiceFilter` ya no resetea incondicionalmente el estado interno del filtro en cada tick del `timerCallback`; en su lugar, actualiza solo el tipo (`lowpass`, `bandpass`, `highpass`), la frecuencia de corte (clampada a < Nyquist) y la resonancia (`Q`) en el filtro JUCE sin borrar su memoria interna.
- Si el modo de filtro es 0 (bypass) o la frecuencia de corte resulta ≤ 0 tras el clamping, el filtro se deja efectivamente en bypass (no se aplica procesamiento adicional), pero sin reseteos periódicos que pudieran introducir clicks.
- Esta eliminación de reseteos innecesarios reduce los chasquidos y el ruido "crisp" que se apreciaban al escuchar un oscilador pasando por un filtro estático, manteniendo a la vez un flujo de audio continuo incluso cuando los parámetros del filtro se mantienen fijos.

## 2025-12-11

### Configuración de envelope ADSR en FilterModule
- El módulo `FilterModule` incluye ahora valores por defecto para los parámetros de envelope ADSR (Attack, Decay, Duration, Release), inicializados en milisegundos:
  - `attack = 500.0F` ms
  - `decay = 500.0F` ms
  - `duration = 1000.0F` ms
  - `release = 500.0F` ms
- Estos valores se almacenan tanto en la estructura `Envelope` interna del módulo (`envelope_`) como en los parámetros lógicos del `AudioModule` mediante `SetParameter`, garantizando que estén disponibles tanto para el procesamiento futuro como para la UI y serialización.
- Se han añadido métodos públicos para configurar cada componente del envelope de forma independiente:
  - `set_envelope_attack(float attack_ms)`
  - `set_envelope_decay(float decay_ms)`
  - `set_envelope_duration(float duration_ms)`
  - `set_envelope_release(float release_ms)`
- Cada uno de estos métodos actualiza tanto el miembro `envelope_` como el parámetro correspondiente en el mapa de parámetros del módulo, manteniendo ambos sincronizados.
- El método `default_parameter_value` de `FilterModule` se ha extendido para devolver los valores configurados del envelope cuando se soliciten los parámetros `"attack"`, `"decay"`, `"duration"` o `"release"`, permitiendo que la UI y otros componentes lean estos valores mediante `GetParameterOrDefault`.
- Se han añadido tests en `tests/scene_tests.cpp` que verifican:
  - Los valores por defecto del envelope (500/500/1000/500 ms).
  - Que los parámetros pueden leerse correctamente mediante `GetParameterOrDefault`.
  - Que los setters actualizan tanto el envelope interno como los parámetros lógicos del módulo de forma coherente.
- Esta implementación prepara el terreno para que el motor de audio utilice estos parámetros de envelope en el procesamiento del filtro y para que la UI pueda exponer controles que permitan al usuario ajustar el envelope de forma dinámica.

### Touch interface visual feedback
- `MainComponent` incorpora ahora un sistema de feedback visual para simular interacciones táctiles sobre la interfaz:
  - **Cursor circular**: al hacer click/touch en la ventana, aparece un círculo con borde vacío (12px de radio, grosor de borde 8px) que representa la posición del dedo:
    - **Color rojo** (#FF0000 con opacidad 0.298, equivalente visual a #4C0000 sobre negro) cuando el touch se inicia en el área principal de la ventana (excluida la barra dock).
    - **Color gris claro** (0xFFCCCCCC) cuando el touch se inicia desde la barra dock.
  - **Rastro de movimiento con fade-out**: mientras el cursor se mantiene presionado (hold) en el área de la ventana (excluyendo el dock), se dibuja un rastro rojo (#FF0000) fino (1.5px) que sigue la trayectoria del movimiento.
    - El rastro implementa un sistema de desvanecimiento (fade-out) temporal: cada punto del rastro tiene un timestamp asociado y su opacidad disminuye linealmente durante 400ms hasta desaparecer completamente.
    - Los puntos se dibujan segmento por segmento con transparencia calculada en función de su edad: `alpha = 1.0 - (edad / 0.4s)`.
    - Los puntos que han superado los 400ms se eliminan automáticamente del vector durante `mouseDrag`, manteniendo el consumo de memoria bajo control.
    - El sistema de fade-out está controlado por la constante `kEnableTrailFade` (por defecto `true`), permitiendo desactivarlo por código si fuera necesario sin cambios estructurales.
  - **Limitación de memoria**: el rastro mantiene un máximo de 500 puntos (`kMaxTrailPoints`) como límite absoluto para prevenir consumo excesivo de memoria en movimientos largos.
- Variables de estado añadidas a `MainComponent.h`:
  - `isTouchActive_`: indica si hay un touch activo (mouseDown).
  - `isTouchHeld_`: indica si el touch está siendo mantenido (mouseDrag).
  - `touchStartedInDock_`: registra si el touch inicial fue dentro de la zona del dock, determinando el color del círculo.
  - `currentTouchPosition_`: posición actual del cursor/toque.
  - `touchTrail_`: vector de `TrailPoint` (estructura con `position` y `timestamp`) que acumula la trayectoria con información temporal para el fade-out.
  - `kEnableTrailFade`: constante booleana (true) que controla el sistema de desvanecimiento del rastro.
  - `kTrailFadeDurationSeconds`: constante que define la duración del fade-out (0.4 segundos).
- Actualizaciones en `MainComponent_Input.cpp`:
  - `mouseDown`: inicializa el estado del touch, determina si comenzó en el dock mediante el cálculo del área del dock con `calculateDockWidth`, limpia el trail previo y dispara `repaint()`.
  - `mouseDrag`: marca `isTouchHeld_` como true, actualiza la posición del cursor, añade puntos al trail con timestamp actual (usando `juce::Time::getMillisecondCounterHiRes()`), elimina puntos obsoletos (edad > 400ms) si el fade está activo, y dispara `repaint()`.
  - `mouseUp`: resetea todo el estado del touch (`isTouchActive_`, `isTouchHeld_`, `touchStartedInDock_`), limpia el trail y dispara `repaint()`.
- Renderizado en `MainComponent_Paint.cpp`:
  - El rastro se dibuja segmento por segmento (línea entre puntos consecutivos), calculando la transparencia de cada segmento según la edad del punto destino.
  - Luego se dibuja el círculo del cursor con `drawEllipse` usando el color correspondiente (#4C0000 o gris claro) y un grosor de 2px.
- El estado `isTouchHeld_` queda almacenado para poder extenderlo en futuras features que requieran conocer si el usuario está manteniendo presionado el cursor.

### Touch line cutting para alternar mute
- Implementado sistema de "corte" de líneas de audio mediante gestos táctiles para alternar el estado de silencio (mute/unmute) de forma intuitiva:
  - **Detección de intersección**: mientras el cursor está en hold (arrastre), el sistema detecta cuando el trail cruza líneas de audio:
    - **Líneas objeto-a-centro** (blancas): representan el output de sonido de cada módulo hacia el master.
    - **Hardlinks módulo-a-módulo** (rojas): conexiones fijas entre módulos.
    - **Conexiones dinámicas** (blancas curvas): conexiones que dependen del cono geométrico de 120º.
  - **Marcado visual con toggle**: cada vez que el cursor cruza una línea, ésta se marca o desmarca (toggle) y cambia a **color amarillo con grosor aumentado (3px)**, proporcionando feedback visual inmediato de que está marcada para alternar su mute.
  - **Aplicación al soltar**: cuando se suelta el ratón (`mouseUp`), todas las líneas marcadas alternan su estado de mute:
    - Líneas mutadas pasan a activas.
    - Líneas activas pasan a mutadas.
  - **Algoritmo de intersección**: nueva función helper `lineSegmentsIntersect` en `MainComponentHelpers` que calcula la distancia mínima entre dos segmentos de línea y detecta intersección con un threshold de 15px.
  - **Sistema de transiciones enter/exit**: mantiene sets de intersección actual (`touchCurrentlyIntersectingConnections_`, `touchCurrentlyIntersectingObjects_`) que detectan cuando el cursor **entra** en la zona de intersección (intersects && !wasIntersecting) para hacer toggle, y cuando **sale** (!intersects && wasIntersecting) para actualizar el estado, permitiendo cruzar repetidamente la misma línea con toggle alternado en cada cruce:
    - 1ª pasada: marca para mute (amarillo).
    - 2ª pasada: desmarca (vuelve a color original).
    - 3ª pasada: vuelve a marcar (amarillo), etc.
  - **Exclusión de drag de módulos**: no detecta líneas cuando se está moviendo un módulo (`draggedObjectId_ != 0`), evitando marcados accidentales al reposicionar objetos en la mesa.
  - **Estructuras de tracking**:
    - `touchCutConnections_`: set de claves de conexión marcadas para toggle al soltar.
    - `touchCutObjects_`: set de IDs de objetos cuyas líneas al centro están marcadas para toggle.
    - `touchCurrentlyIntersectingConnections_`/`touchCurrentlyIntersectingObjects_`: sets temporales para tracking de transiciones.
- El sistema respeta la lógica existente de visibilidad de líneas (área musical, conexiones activas, controladores globales).
- Código actualizado:
  - `MainComponent.h`: añadidos 4 sets de tracking (cut + currentlyIntersecting).
  - `MainComponent_Input.cpp`: detección de transiciones en `mouseDrag` con condición `draggedObjectId_ == 0`, aplicación de toggle en `mouseUp`, limpieza en `mouseDown`.
  - `MainComponent_Paint.cpp`: renderizado condicional de líneas en amarillo con grosor aumentado.
  - `MainComponentHelpers.{h,cpp}`: función `lineSegmentsIntersect` para geometría de intersección.

### Click-and-hold temporary mute con split rendering en líneas de audio
- Implementado nuevo comportamiento para la interacción con líneas de audio: al hacer click en una línea, el módulo se silencia temporalmente mientras se mantiene presionado el botón, con visualización parcial de la waveform:
  - **Mute temporal durante hold**: al hacer click en una línea de audio (tanto object-to-center como module-to-module), el sistema:
    - Calcula la posición normalizada (0-1) del punto de click a lo largo de la línea.
    - Aplica mute inmediato al módulo/conexión correspondiente.
    - Almacena el estado de mute previo: si la línea ya estaba silenciada antes del click, se recuerda para no desmutar al soltar.
    - Al soltar el click (`mouseUp`), se desmutea automáticamente solo si la línea no estaba previamente muteada.
  - **Split rendering visual**: durante el hold, la línea se renderiza en dos segmentos:
    - **Segmento activo** (source → split point): muestra la waveform de audio normalmente si hay señal activa, demostrando que hasta ese punto la señal sigue siendo audible.
    - **Segmento silenciado** (split point → destination): se dibuja con línea punteada (dashed) con transparencia reducida (0.6F), indicando visualmente que desde ese punto en adelante la señal está muted.
  - **Cursor blanco sin trail**: mientras se mantiene el click en una línea de audio:
    - El cursor cambia a **color blanco** (`juce::Colours::white.withAlpha(0.8F)`), diferenciándose del rojo normal para indicar modo de interacción especial.
    - El **trail rojo desaparece** (no se dibuja), eliminando el rastro de movimiento y proporcionando feedback visual claro de que estamos en modo "hold mute" y no en modo "line cutting".
  - **Estructuras de estado**:
    - Nuevo `ConnectionHoldState` en `MainComponent.h` que almacena:
      - `connection_key` o `object_id`: identifica la línea afectada.
      - `is_object_line`: distingue entre línea object-to-center (true) o module-to-module (false).
      - `split_point`: posición normalizada (0-1) donde se hizo click.
      - `was_previously_muted`: estado de mute anterior al click para restauración correcta.
    - Variable `std::optional<ConnectionHoldState> activeConnectionHold_` que marca si hay una línea siendo held.
  - **Implementación**:
    - `MainComponent_Input.cpp`:
      - `mouseDown`: al detectar click en línea (segment hit-test), calcula el `splitPoint` mediante proyección vectorial del punto de click sobre el segmento (producto punto normalizado), almacena el estado previo de mute, activa el mute inmediato y guarda todo en `activeConnectionHold_`.
      - `mouseUp`: si hay `activeConnectionHold_` activo, desmutea la línea solo si `!was_previously_muted`, luego resetea `activeConnectionHold_`.
    - `MainComponent_Paint.cpp`:
      - Render de líneas object-to-center: si `activeConnectionHold_` está activo y coincide con la línea, calcula `splitPoint` interpolado y renderiza:
        - Primer segmento con waveform (si audio activo) desde center hasta split.
        - Segundo segmento dashed desde split hasta object.
      - Render de conexiones module-to-module: similar split rendering aplicado a hardlinks y dynamic connections, usando líneas rectas desde p1 a splitPoint con waveform, y dashed desde splitPoint a p2.
      - Cursor: condición `activeConnectionHold_.has_value()` cambia color a blanco y desactiva el dibujado del trail rojo.
  - **Compatibilidad con line cutting**: el sistema convive con el mecanismo de line cutting previo (drag con trail para toggle permanente de mute), diferenciándose por el cursor blanco vs rojo y la ausencia de trail durante hold.
- Este comportamiento proporciona control temporal fino sobre el audio, permitiendo escuchar cómo suena la señal hasta un punto específico de la cadena, útil para debugging y performance en vivo.
- Código actualizado:
  - `MainComponent.h`: añadidos `#include <optional>`, estructura `ConnectionHoldState` y variable `activeConnectionHold_`.
  - `MainComponent_Input.cpp`: cálculo de split point en hit-test de líneas, almacenamiento de estado hold, lógica de unmute condicional en `mouseUp`.
  - `MainComponent_Paint.cpp`: render condicional de split en líneas object-to-center y module-to-module, cambio de cursor a blanco y supresión de trail durante hold.

#### Correcciones de bugs en click-and-hold mute
- **Separación de interacciones**: se ha corregido la lógica para prevenir que el sistema de "line cutting" (cursor rojo con trail) se active durante el modo "hold mute" (cursor blanco sin trail):
  - Añadida condición `!activeConnectionHold_.has_value()` en la detección de intersecciones de líneas durante `mouseDrag`.
  - Esto asegura que ambos modos de interacción sean mutuamente excluyentes y no interfieran entre sí.
- **Corrección de dirección de split rendering**: se ha invertido la dirección de los segmentos visuales para reflejar correctamente el flujo de audio:
  - **Segmento con waveform**: ahora va desde el **módulo (origen)** hasta el **punto de click**, mostrando que la señal de audio se genera en el módulo y viaja hasta donde el usuario presiona.
  - **Segmento punteado/silenciado**: ahora va desde el **punto de click** hasta la **salida (centro/master o módulo destino)**, indicando que desde ese punto hacia adelante la señal está cortada/muteada.
  - En líneas object-to-center: waveform de `{cx, cy}` (objeto) a `splitPoint`, dashed de `splitPoint` a `centre` (master).
  - En líneas module-to-module: waveform de `p1` (from/source) a `splitPoint`, dashed de `splitPoint` a `p2` (to/destination).
- **Visualización de waveform durante mute**: se ha corregido para que la waveform se muestre **siempre** en el segmento activo (origen → split) cuando hay señal de audio, **incluso si el módulo está temporalmente muteado** durante el hold:
  - El código de render durante `isBeingHeld` ya no filtra por estado de mute para decidir si dibuja la waveform.
  - Esto permite al usuario ver visualmente que el módulo está generando audio hasta el punto de corte, proporcionando feedback más intuitivo.
- **Unmute incondicional al soltar**: se ha corregido la lógica de `mouseUp` para que **siempre desmutee** la línea al soltar el click, independientemente de si estaba muteada previamente o no:
  - Eliminado el campo `was_previously_muted` de `ConnectionHoldState`.
  - Eliminadas las condiciones que chequeaban el estado previo antes de desmutar.
  - Ahora `mouseUp` simplemente llama a `erase()` en `mutedObjects_` o `mutedConnections_` sin condiciones, garantizando que al soltar el click la línea siempre quede activa (no muted).
- Estas correcciones mejoran la coherencia visual y funcional del sistema de control temporal de mute, alineando el comportamiento con las expectativas del usuario sobre el flujo direccional de la señal de audio.
- **Corrección crítica - generación de waveform en AudioEngine con level=0**: se ha corregido el problema fundamental donde la waveform no se mostraba durante el hold mute (mostrando solo línea blanca):
  - **Problema raíz en tres capas**:
    1. En `MainComponent_Audio.cpp`: cuando un módulo se muteaba, `level = 0` y no entraba en `if (level > 0)`, no asignando voice index.
    2. Tras corregir eso para procesar con `isBeingHeld`, el voice se configuraba con `outputLevel = 0` en el AudioEngine.
    3. **Problema final**: En `AudioEngine.cpp`, la condición `if (level > 0.0F && freq > 0.0)` impedía la generación del oscillador cuando `level = 0`, por lo que `voiceWaveformBuffer_` quedaba en 0 y no había datos que visualizar.
  - **Solución implementada en tres capas**:
    1. **AudioEngine** (`AudioEngine.cpp`): Modificada la lógica de generación de waveform para que funcione **independientemente del level**:
       - Cambiada condición de `if (level > 0.0F && freq > 0.0)` a solo `if (freq > 0.0)`.
       - Los oscilladores (sine, saw, square, noise) ahora generan waveform a **amplitud completa** (sin multiplicar por level).
       - La waveform sin escalar se almacena en `voiceWaveformBuffer_[v][bufIndex]` para visualización.
       - El `level` se aplica **después**, solo para el output mezclado: `scaledOutput = s * level`.
       - Esto permite capturar la forma de onda real del oscillador incluso cuando `level = 0`.
    2. **Motor de audio** (`MainComponent_Audio.cpp`): Lógica para procesar voices durante `isBeingHeld`:
       - Añadida detección de `isBeingHeld` verificando si objeto/conexión está en hold.
       - Cambiada condición a `if ((calculatedLevel > 0.0F || isBeingHeld))` para forzar procesamiento.
       - El `outputLevel` es 0 durante hold, silenciando la salida pero permitiendo generación interna.
    3. **Capa de renderizado** (`MainComponent_Paint.cpp`): Búsqueda directa de `voiceIndex` sin dependencias de flags de mute durante `isBeingHeld`.
  - **Resultado**: La waveform ahora se visualiza correctamente en el segmento activo (módulo → split point) durante el hold mute, mostrando la forma de onda real del audio generado internamente aunque la salida esté completamente silenciada.
  - **Corrección adicional - consistencia de waveform**: se ha corregido un problema donde la forma de onda mostrada cambiaba completamente al hacer click en diferentes posiciones de la línea:
    - **Problema**: El número de segmentos usado para dibujar la waveform variaba según `splitT` (posición del click), causando diferente muestreo del buffer `voiceWaveforms[]` en cada click.
    - **Solución**: Mantener siempre el mismo número de segmentos fijo (72 para object-to-center, 64 para module-to-module), independientemente de la longitud de la línea dibujada.
    - Esto garantiza que se muestree siempre la misma porción del buffer de waveform, mostrando un patrón consistente de la forma de onda sin importar dónde se haga click en la línea.
